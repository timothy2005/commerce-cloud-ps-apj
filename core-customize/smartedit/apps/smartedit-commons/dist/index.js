'use strict';

$exceptionHandler.$inject = ["$log"];
GatewayProxiedAnnotationFactory.$inject = ["gatewayProxy"];
$translateStaticFilesLoader.$inject = ["$q", "translationsFetchService"];
Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _static = require('@angular/upgrade/static');
var utils = require('@smart/utils');
var angular$1 = require('angular');
var lodash = require('lodash');
var core = require('@angular/core');
var $script = require('scriptjs');
var elements = require('@angular/elements');
var moment = _interopDefault(require('moment'));
var http = require('@angular/common/http');
var common = require('@angular/common');
var core$1 = require('@ngx-translate/core');
var rxjs = require('rxjs');
var core$2 = require('@fundamental-ngx/core');
var router = require('@angular/router');
var operators = require('rxjs/operators');
var Popper = _interopDefault(require('popper.js'));
var ResizeObserver = _interopDefault(require('resize-observer-polyfill'));
var dragDrop = require('@angular/cdk/drag-drop');
var forms = require('@angular/forms');
var animations = require('@angular/platform-browser/animations');
var platformBrowser = require('@angular/platform-browser');
var upgrade = require('@angular/common/upgrade');

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * # Module
 *
 * **Deprecated since 2005, use {@link TabsModule}**.
 *
 * # Component
 *
 * **Deprecated since 2005, use {@link TabsComponent}**.
 *
 * ### Example AngularJS
 *
 *      <se-tabs [model]='myModel' [tabs-list]="tabsList" [num-tabs-displayed]="3"></se-tab>
 *
 * ### Example Angular
 *
 *      <se-tabs [model]='myModel' [tabList]="tabsList" [numTabsDisplayed]="3"></se-tab>
 *
 * @deprecated
 */
angular
    .module('tabsetModule', [])
    .component('yTabset', {
        transclude: false,
        templateUrl: 'yTabsetTemplate.html',
        controller: 'yTabsetController',
        controllerAs: 'yTabset',
        bindings: {
            model: '=',
            tabsList: '<',
            tabControl: '=',
            numTabsDisplayed: '@'
        }
    })
    .controller('yTabsetController', function () {});

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * This module manages the use of the lodash library in SmartEdit. It makes sure the library is introduced
 * in the Angular lifecycle and makes it easy to mock for unit tests.
 */
angular
    .module('yLoDashModule', [])
    /**
     * Makes the underscore library available to SmartEdit.
     *
     * Note: original _ namespace is removed from window in order not to clash with other libraries especially in the storefront AND to enforce proper dependency injection.
     */
    /* forbiddenNameSpaces window._.:false */
    .factory('lodash', function () {
        if (!window.smarteditLodash) {
            if (window._ && window._.noConflict) {
                window.smarteditLodash = window._.noConflict();
            } else {
                throw 'could not find lodash library under window._ namespace';
            }
        }
        return window.smarteditLodash;
    });

(function(){
      var angular = angular || window.angular;
      var SE_NG_TEMPLATE_MODULE = null;
      
      try {
        SE_NG_TEMPLATE_MODULE = angular.module('coretemplates');
      } catch (err) {}
      SE_NG_TEMPLATE_MODULE = SE_NG_TEMPLATE_MODULE || angular.module('coretemplates', []);
      SE_NG_TEMPLATE_MODULE.run(['$templateCache', function($templateCache) {
         
    $templateCache.put(
        "HelpComponent.html", 
        "<se-tooltip [triggers]=\"['mouseenter', 'mouseleave']\" placement=\"auto\" [isChevronVisible]=\"true\" [title]=\"title\" class=\"se-help\"><span se-tooltip-trigger class=\"sap-icon--sys-help se-y-help-icon\"></span><ng-container se-tooltip-body><div *ngIf=\"template\" [seCompileHtml]=\"template\"></div><div *ngIf=\"templateUrl\" [ngInclude]=\"templateUrl\"></div></ng-container><ng-content se-tooltip-body></ng-content></se-tooltip>"
    );
     
    $templateCache.put(
        "legacyHasOperationPermissionTemplate.html", 
        "<div data-ng-if=\"ctrl.isPermissionGrantedFlag\" ng-transclude></div>"
    );
     
    $templateCache.put(
        "ClientPagedListCellComponent.html", 
        "<ng-container *ngIf=\"key.component; else cellText\"><ng-container *ngComponentOutlet=\"key.component; injector: componentInjector\"></ng-container></ng-container><ng-template #cellText><span>{{ item[key.property] }}</span></ng-template>"
    );
     
    $templateCache.put(
        "ClientPagedListComponent.html", 
        "<div class=\"fluid-container se-paged-list-result\"><p class=\"se-page-list__page-count\" *ngIf=\"displayCount\"><span>({{ totalItems }} {{ 'se.pagelist.countsearchresult' | translate }})</span></p><table class=\"se-paged-list-table table table-striped table-hover techne-table\"><thead><tr><th *ngFor=\"let key of keys; trackBy: keysTrackBy\" (click)=\"onOrderByColumn(key.property)\" [ngStyle]=\"{ 'width': columnWidth + '%' }\" class=\"se-paged-list__header\" [ngClass]=\"'se-paged-list__header-' + key.property\"><ng-container *ngIf=\"key.i18n\">{{ key.i18n | translate }} <span class=\"header-icon\" [hidden]=\"visibleSortingHeader !== key.property\" [ngClass]=\"{                          'sap-icon--navigation-down-arrow': headersSortingState[key.property],                          'sap-icon--navigation-up-arrow': !headersSortingState[key.property]                      }\"></span></ng-container></th><th class=\"se-paged-list__header\"></th><th class=\"se-paged-list__header\" *ngIf=\"dropdownItems\"></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of filteredItems\" class=\"techne-table-xs-right techne-table-xs-left se-paged-list-item\"><td *ngFor=\"let key of keys\" [ngClass]=\"'se-paged-list-item-' + key.property\"><se-client-paged-list-cell [item]=\"item\" [key]=\"key\"></se-client-paged-list-cell></td><td><se-tooltip *ngIf=\"item.icon\" [triggers]=\"['mouseenter', 'mouseleave']\" [placement]=\"'bottom'\" [title]=\"'se.icon.tooltip.visibility' | translate: { numberOfRestrictions: item.icon.numberOfRestrictions }\" [isChevronVisible]=\"true\"><img [src]=\"item.icon.src\" se-tooltip-trigger/></se-tooltip></td><ng-container *ngIf=\"dropdownItems\"><td *seHasOperationPermission=\"'se.edit.page'\" class=\"paged-list-table__body__td paged-list-table__body__td-menu\"><se-dropdown-menu [dropdownItems]=\"dropdownItems\" [selectedItem]=\"item\" class=\"pull-right\"></se-dropdown-menu></td></ng-container></tr></tbody></table><div class=\"pagination-container\"><se-pagination [totalItems]=\"totalItems < itemsPerPage ? itemsPerPage : totalItems\" [itemsPerPage]=\"itemsPerPage\" (onChange)=\"onCurrentPageChange($event)\" [currentPage]=\"currentPage\" class=\"pagination-lg\"></se-pagination></div></div>"
    );
     
    $templateCache.put(
        "CollapsibleContainerComponent.html", 
        "<div role=\"tab\" class=\"collapsible-container__header\" [ngClass]=\"{        'collapsible-container__header--icon-right': isIconRight(),        'collapsible-container__header--icon-left': isIconLeft()    }\" [attr.id]=\"headingId\" [attr.aria-selected]=\"isOpen\" (keypress)=\"handleKeypress($event)\"><button type=\"button\" tabindex=\"0\" class=\"collapsible-container__header__title\" (click)=\"toggle()\" [attr.aria-expanded]=\"isOpen\" [attr.aria-controls]=\"panelId\"><ng-content select=\"se-collapsible-container-header\"></ng-content></button> <a class=\"collapsible-container__header__button btn btn-link\" *ngIf=\"configuration.iconVisible\" [ngClass]=\"{            'collapsible-container__header__button--expanded': isOpen        }\" [title]=\"isOpen            ? 'se.ycollapsible.action.collapse'            : ('se.ycollapsible.action.expand' | translate)        \" [attr.aria-expanded]=\"isOpen\" (click)=\"toggle()\"><span class=\"sap-icon--navigation-down-arrow collapsible-container__header__icon\"></span></a></div><div #container class=\"collapsible-container__content panel\" [ngStyle]=\"{ 'max-height.px': isOpen ? containerHeight : 0 }\" [attr.id]=\"panelId\" [attr.aria-labelledby]=\"headingId\" [attr.aria-hidden]=\"!isOpen\" role=\"tabpanel\"><ng-content select=\"se-collapsible-container-content\"></ng-content></div>"
    );
     
    $templateCache.put(
        "DataTableComponent.html", 
        "<table class=\"se-paged-list-table fd-table\"><thead><tr><th *ngFor=\"let column of columns\" (click)=\"sortColumn(column)\" [ngStyle]=\"{'width.': columnWidth + '%'}\" [ngClass]=\"'se-paged-list__header-'+column.property\" class=\"se-paged-list__header\">{{ column.i18n | translate }} <span class=\"se-data-table__arrow\" *ngIf=\"visibleSortingHeader === column.property\" [ngClass]=\"{                         'se-data-table__arrow--expanded sap-icon--navigation-down-arrow': headersSortingState[column.property],                        'se-data-table__arrow--not-expanded sap-icon--navigation-up-arrow': !headersSortingState[column.property] }\"></span></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of items; let i = index\" class=\"se-paged-list-item\"><td *ngFor=\"let column of columns\" [ngClass]=\"'se-paged-list-item-'+column.property\"><se-data-table-renderer [column]=\"column\" [item]=\"item\" [config]=\"config\" [index]=\"i\"></se-data-table-renderer></td></tr></tbody></table>"
    );
     
    $templateCache.put(
        "yDropdownDefaultItemTemplate.html", 
        "<a class=\"se-dropdown-item fd-menu__item\" data-ng-class=\"dropdownItem.customCss\" data-ng-click=\"dropdownItem.callback($ctrl.selectedItem) \">{{dropdownItem.key | translate}}</a>"
    );
     
    $templateCache.put(
        "DynamicPagedListComponent.html", 
        "<div *ngIf=\"ready\" class=\"se-dynamic-paged-list\"><div class=\"fd-panel__body fd-panel__body--bleed\"><se-data-table [columns]=\"columns\" [config]=\"config\" [items]=\"items\" [sortStatus]=\"sortStatus\" (onSortColumn)=\"orderByColumn($event)\"></se-data-table></div><div class=\"fd-panel__footer\"><se-pagination *ngIf=\"!!items.length\" class=\"se-dynamic-list__pagination\" [totalItems]=\"totalItems\" [itemsPerPage]=\"config.itemsPerPage\" [currentPage]=\"currentPage\" (onChange)=\"onCurrentPageChange($event)\"></se-pagination><span class=\"se-paged-list__page-count-wrapper se-paged-list__page-count-wrapper--footer\"><span class=\"span-page-list__page-count-text\">{{'se.pagelist.countsearchresult' | translate}} </span><span class=\"se-page-list__page-count\">({{ totalItems }})</span></span></div></div><se-spinner [isSpinning]=\"!ready\"></se-spinner>"
    );
     
    $templateCache.put(
        "legacyDynamicPagedListTemplate.html", 
        "<se-dynamic-paged-list [config]=\"$ctrl.config\" [mask]=\"$ctrl.mask\" (get-api)=\"$ctrl.internalGetApi($event)\" (on-items-update)=\"$ctrl.onItemsUpdate($event)\"></se-dynamic-paged-list>"
    );
     
    $templateCache.put(
        "GenericEditorComponent.html", 
        "<ng-template let-state [formBuilder]=\"{schema$: editor.schema$, data$: editor.data$}\" (stateCreated)=\"setFormState($event)\"><div class=\"se-generic-editor\"><se-generic-editor-breadcrumb></se-generic-editor-breadcrumb><ng-container *ngIf=\"state; else noSupport\"><form novalidate #nativeForm class=\"no-enter-submit se-generic-editor__form\" [contentManager]=\"{onSave: editor.submit$}\" (onSuccess)=\"editor.onSuccess($event)\" (onError)=\"editor.onFailure($event)\"><div class=\"modal-header se-generic-editor__header\" *ngIf=\"modalHeaderTitle\"><h4 class=\"modal-title\">{{modalHeaderTitle| translate}}</h4></div><div class=\"se-generic-editor__body\"><ng-template [formRenderer]=\"state.group\"></ng-template></div><div class=\"se-generic-editor__footer modal-footer\" *ngIf=\"editor && showCommands()\"><button fd-button id=\"cancel\" type=\"button\" options=\"light\" *ngIf=\"showCancel()\" (click)=\"_reset()\">{{editor.cancelButtonText | translate}}</button> <button fd-button id=\"submit\" name=\"submit\" options=\"emphasized\" *ngIf=\"showSubmit()\" [seSubmitBtn]=\"editor.isSubmitDisabled\">{{editor.submitButtonText | translate}}</button></div></form></ng-container><ng-template #noSupport><div class=\"se-generic-editor__body\"><se-message type=\"info\" id=\"GenericEditor.NoEditingSupportDisclaimer\"><ng-container se-message-description>{{ 'se.editor.notification.editing.not.supported' | translate }}</ng-container></se-message></div></ng-template></div></ng-template>"
    );
     
    $templateCache.put(
        "yHelpTemplate.html", 
        "<se-help class=\"se-y-help-wrapper\" [template]=\"$ctrl.template\" [template-url]=\"$ctrl.templateUrl\" [title]=\"$ctrl.title\"></se-help>"
    );
     
    $templateCache.put(
        "InfiniteScrollingComponent.html", 
        "<div #container class=\"se-infinite-scrolling__container\" [ngClass]=\"dropDownContainerClass\" fdInfiniteScroll (onScrollAction)=\"nextPage()\" [scrollPercent]=\"distance\" *ngIf=\"initiated\"><div class=\"se-infinite-scrolling__holder\" [ngClass]=\"dropDownClass\"><div #content><ng-content></ng-content></div><div class=\"spinner-container\"><se-spinner [isSpinning]=\"isLoading\" [isFluid]=\"false\"></se-spinner></div></div></div>"
    );
     
    $templateCache.put(
        "LegacyInfiniteScrollingTemplate.html", 
        "<div class=\"ySEInfiniteScrolling-container {{$ctrl.dropDownContainerClass}}\"><div class=\"ySEInfiniteScrolling {{$ctrl.dropDownClass}}\" data-ng-if=\"!!$ctrl.initiated\" data-infinite-scroll=\"$ctrl.nextPage()\" data-infinite-scroll-disabled=\"$ctrl.pagingDisabled\" data-infinite-scroll-distance=\"$ctrl.distance\" data-infinite-scroll-immediate-check=\"true\" data-infinite-scroll-container=\"$ctrl.container\"><div data-ng-transclude></div></div><div data-ng-if=\"!$ctrl.pagingDisabled\" class=\"panel panel-default panel__ySEInfiniteScrolling\"><div class=\"panel-body panel-body__ySEInfiniteScrolling\"><div class=\"spinner\"><div class=\"spinner-container spinner-container1\"><div class=\"spinner-circle1\"></div><div class=\"spinner-circle2\"></div><div class=\"spinner-circle3\"></div><div class=\"circle4\"></div></div><div class=\"spinner-container spinner-container2\"><div class=\"spinner-circle1\"></div><div class=\"spinner-circle2\"></div><div class=\"spinner-circle3\"></div><div class=\"circle4\"></div></div><div class=\"spinner-container spinner-container3\"><div class=\"spinner-circle1\"></div><div class=\"spinner-circle2\"></div><div class=\"spinner-circle3\"></div><div class=\"circle4\"></div></div></div></div></div></div>"
    );
     
    $templateCache.put(
        "genericEditorComponentTemplate.html", 
        "<se-generic-editor [id]=\"$ctrl.id\" [smartedit-component-id]=\"$ctrl.smarteditComponentId\" [smartedit-component-type]=\"$ctrl.smarteditComponentType\" [structure]=\"$ctrl.structure\" [structure-api]=\"$ctrl.structureApi\" [content]=\"$ctrl.content\" [content-api]=\"$ctrl.contentApi\" [(submit)]=\"$ctrl.submit\" [(reset)]=\"$ctrl.reset\" [(is-dirty)]=\"$ctrl.isDirty\" [(is-valid)]=\"$ctrl.isValid\" [editor-stack-id]=\"$ctrl.editorStackId\" [update-callback]=\"$ctrl.updateCallback\" [custom-on-submit]=\"$ctrl.customOnSubmit\" [uri-context]=\"$ctrl.uriContext\" (get-api)=\"$ctrl.getApi($event)\"></se-generic-editor>"
    );
     
    $templateCache.put(
        "EditableListComponent.html", 
        "<div [ngClass]=\"{ 'y-editable-list-disabled': !editable, 'se-editable-list-disabled': !editable }\"><se-tree (onTreeUpdated)=\"handleTreeUpdated($event)\" [removeDefaultTemplate]=\"true\" [rootNodeUid]=\"rootId\" [nodeTemplateUrl]=\"itemTemplateUrl\" [nodeComponent]=\"itemComponent\" [nodeActions]=\"actions\" [dragOptions]=\"dragOptions\" [showAsList]=\"true\"></se-tree></div>"
    );
     
    $templateCache.put(
        "PaginationComponent.html", 
        "<fd-pagination class=\"se-pagination\" [displayTotalItems]=\"displayTotalItems\" [totalItems]=\"totalItems\" [itemsPerPage]=\"totalItems === 1 ? 1 : itemsPerPage\" [currentPage]=\"currentPage\" (pageChangeStart)=\"onPageChanged($event)\" nextLabel=\"&rsaquo; \" previousLabel=\"&lsaquo; \"></fd-pagination>"
    );
     
    $templateCache.put(
        "yPaginationTemplate.html", 
        "<div class=\"fd-pagination\"><ul data-uib-pagination boundary-links=\"true \" total-items=\"$ctrl.totalItems \" items-per-page=\"$ctrl.itemsPerPage \" ng-model=\"$ctrl.currentPage \" ng-change=\"$ctrl.pageChanged()\" class=\"fd-pagination__nav\" previous-text=\"&lsaquo; \" next-text=\"&rsaquo; \" first-text=\"&laquo; \" last-text=\"&raquo; \"></ul></div>"
    );
     
    $templateCache.put(
        "yPopoverPopupTemplate.html", 
        "<div class=\"popover se-popover\" data-ng-class=\"$ctrl.placement\"><div class=\"arrow\" x-arrow></div><div class=\"popover-inner\"><h3 class=\"se-popover__title\" data-ng-if=\"$ctrl.title\">{{ $ctrl.title | translate }}</h3><div class=\"se-popover__content\" data-compile-html=\"$ctrl.template\"></div></div></div>"
    );
     
    $templateCache.put(
        "SelectComponent.html", 
        "<fd-select [style.display]=\"'none'\"></fd-select><div [attr.id]=\"id + '-selector'\" class=\"select-container\" [ngClass]=\"{        'has-warning': hasWarning(),        'has-error': hasError()    }\"><ng-container *ngIf=\"multiSelect; then multi; else singleSelect\"></ng-container><ng-template #singleSelect><fd-popover [triggers]=\"['click']\" [(isOpen)]=\"isOpen\" [placement]=\"'bottom'\" (isOpenChange)=\"onSingleSelectIsOpenChange($event)\"><fd-popover-control><div class=\"selected-container fd-select-custom\" [attr.has-selected-option]=\"!!selected || null\"><button fd-button class=\"fd-select-button-custom toggle-button\" [disabled]=\"isReadOnly\"><span *ngIf=\"!selected; else selectedItem\" class=\"selected-placeholder\">{{ placeholder | translate }}</span><ng-template #selectedItem><div class=\"selected-item\"><span *ngIf=\"controls\" class=\"glyphicon glyphicon-search\"></span><se-item-printer *ngIf=\"selected\" [attr.id]=\"id + '-selected'\" [item]=\"selected\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span *ngIf=\"controls || showRemoveButton\" class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, selected)\"></span></div></ng-template></button></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngIf=\"searchEnabled && isOpen\"><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></ng-container><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #multi><fd-popover class=\"se-multi-select\" [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"'bottom'\"><fd-popover-control><div class=\"selected-container\"><ng-container *ngIf=\"selected && selected.length > 0\"><ol class=\"selected-list\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\"><li *ngFor=\"let item of selected; trackBy: itemTrackBy\" cdkDrag class=\"selected-list__item selected-item\"><se-item-printer [item]=\"item\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, item)\"></span></li></ol></ng-container><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #resultsHeader><se-select-results-header [search]=\"search\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [resultsHeaderLabel]=\"resultsHeaderLabel\" [displayResultsHeaderLabel]=\"showResultsHeaderLabel()\" [actionableSearchItem]=\"actionableSearchItem\" (actionButtonClick)=\"closeAndReset()\"></se-select-results-header></ng-template><ng-template #searchInputTemplate><se-select-search-input [isDisabled]=\"isReadOnly\" [isReadOnly]=\"multiSelect && !searchEnabled\" [isTypeAheadEnabled]=\"!multiSelect\" [placeholder]=\"showPlaceholder() ? (placeholder | translate) : ''\" [search]=\"search\" (searchKeyup)=\"onSearchInputKeyup($event.event, $event.value)\" (searchChange)=\"onSearchInputChange($event)\"></se-select-search-input></ng-template><ng-template #selectListTemplate><se-select-list [id]=\"id\" [isPagedDropdown]=\"isPagedDropdown()\" [fetchPage]=\"fetchStrategy.fetchPage\" [search]=\"search\" [items]=\"items\" [selected]=\"selected\" [excludeSelected]=\"multiSelect\" [disableChoiceFn]=\"disableChoiceFn\" [itemComponent]=\"itemComponent\" [selectComponentCtx]=\"this\" (optionClick)=\"onOptionClick($event)\" (infiniteScrollItemsChange)=\"onInfiniteScrollItemsChange()\"></se-select-list></ng-template></div>"
    );
     
    $templateCache.put(
        "SliderPanelComponent.html", 
        "<div class=\"se-slider-panel-wrapper\" *ngIf=\"isShown\"><div class=\"se-slider-panel-container slide-in\"><div class=\"se-slider-panel__header\" *ngIf=\"sliderPanelConfiguration.modal\"><span class=\"se-slider-panel__title\" *ngIf=\"sliderPanelConfiguration.modal.title\">{{ sliderPanelConfiguration.modal.title | translate }}</span> <button type=\"button\" class=\"se-slider-panel__close-btn fd-button--light fd-modal__close\" aria-label=\"close\" *ngIf=\"sliderPanelConfiguration.modal.showDismissButton\" (click)=\"sliderPanelDismissAction()\"></button></div><div class=\"se-slider-panel__body\"><div *ngIf=\"sliderPanelConfiguration.template\" [seCompileHtml]=\"sliderPanelConfiguration.template\" [scope]=\"sliderPanelConfiguration.scope\"></div><div *ngIf=\"sliderPanelConfiguration.templateUrl\" [ngInclude]=\"sliderPanelConfiguration.templateUrl\" [scope]=\"sliderPanelConfiguration.scope\"></div><ng-content></ng-content></div><div class=\"se-slider-panel__footer\" *ngIf=\"sliderPanelConfiguration.modal && (sliderPanelConfiguration.modal.cancel || sliderPanelConfiguration.modal.save)\"><button type=\"button\" class=\"fd-button--light se-slider-panel__footer-btn se-slider-panel__footer-btn--cancel\" *ngIf=\"sliderPanelConfiguration.modal.cancel\" (click)=\"sliderPanelConfiguration.modal.cancel.onClick()\">{{ sliderPanelConfiguration.modal.cancel.label | translate }}</button> <button type=\"button\" class=\"fd-button--emphasized se-slider-panel__footer-btn se-slider-panel__footer-btn--save\" *ngIf=\"sliderPanelConfiguration.modal.save\" (click)=\"sliderPanelConfiguration.modal.save.onClick()\" [disabled]=\"isSaveDisabled()\">{{ sliderPanelConfiguration.modal.save.label | translate }}</button></div></div></div>"
    );
     
    $templateCache.put(
        "TabComponent.html", 
        "<ng-container *ngIf=\"!isLegacyTab; else legacyAngularJSTab\"><ng-container *ngComponentOutlet=\"tab.component; injector: tabInjector\"></ng-container></ng-container><ng-template #legacyAngularJSTab><div [ngInclude]=\"tab.templateUrl\" [scope]=\"scopeStream | async\"></div></ng-template>"
    );
     
    $templateCache.put(
        "TabsComponent.html", 
        "<div class=\"se-tabset-wrapper\"><ul class=\"nav nav-tabs se-tabset\" role=\"tablist\" *ngIf=\"isInitialized\"><ng-container *ngIf=\"tabsList.length !== numTabsDisplayed\"><li *ngFor=\"let tab of (getVisibleTabs() | async); trackBy: trackTabById\" [ngClass]=\"{ 'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" (click)=\"selectTab(tab)\" class=\"se-tabset__link\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><ng-container *ngIf=\"tabsList && tabsList.length == numTabsDisplayed\"><li *ngFor=\"let tab of tabsList; trackBy: trackTabById\" [ngClass]=\"{'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><su-select class=\"se-tabset__select\" *ngIf=\"tabsList.length > numTabsDisplayed && (getDropdownTabs() | async)\" [items]=\"dropdownTabs\" [isKeyboardControlEnabled]=\"false\" [hasCustomTrigger]=\"true\" (onItemSelected)=\"selectTab($event.value)\"><li [ngClass]=\"{'active': isActiveInMoreTab()}\" su-select-custom-trigger><a [ngClass]=\"{'sm-tab-error': dropDownHasErrors()}\" class=\"dropdown-toggle\"><span *ngIf=\"!isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{ 'se.ytabset.tabs.more' | translate }} </span><span *ngIf=\"isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{selectedTab.title | translate}} </span><span class=\"caret\"></span></a></li></su-select></ul><div class=\"se-tab-set__content-wrapper\" *ngIf=\"selectedTab\"><ng-container *ngFor=\"let tab of tabsList; trackBy: trackTabById\"><se-tab [hidden]=\"tab.id !== selectedTab.id\" [attr.tab-id]=\"tab.id\" [tab]=\"tab\" [model]=\"model\"></se-tab></ng-container></div></div>"
    );
     
    $templateCache.put(
        "yTabsetTemplate.html", 
        "<se-tabs [tabs-list]=\"yTabset.tabsList\" [model]=\"yTabset.model\" [num-tabs-displayed]=\"yTabset.numTabsDisplayed\"></se-tabs>"
    );
     
    $templateCache.put(
        "treeNodeRendererTemplate.html", 
        "<div ui-tree-handle class=\"tree-node tree-node-content se-tree-node clearfix\" data-ng-class=\"{ hovered: node.mouseHovered }\" data-ng-mouseenter=\"$ctrl.onNodeMouseEnter(node)\" data-ng-mouseleave=\"$ctrl.onNodeMouseLeave(node)\"><div data-ng-show=\"!$ctrl.showAsList\" class=\"se-tree-node__expander--wrapper col-xs-1 text-center\"><a class=\"se-tree-node__expander btn btn-link btn-sm\" data-ng-if=\"$ctrl.hasChildren(this)\" data-ng-disabled=\"$ctrl.isDisabled\" data-ng-click=\"$ctrl.toggleAndfetch(this)\"><span data-ng-class=\"{'sap-icon--slim-arrow-right': collapsed,'sap-icon--slim-arrow-down': !collapsed}\"></span></a></div><div data-ng-show=\"$ctrl.displayDefaultTemplate()\" class=\"se-tree-node__name col-xs-5\" title=\"{{ node.name | l10n }}\"><span>{{node.name | l10n}}</span><h6 data-ng-show=\"node.title\">{{node.title | l10n}}</h6></div><div data-ng-include=\"$ctrl.nodeTemplateUrl\" data-ng-if=\"$ctrl.nodeTemplateUrl\" data-include-replace></div></div><ol data-ui-tree-nodes=\"\" data-ng-model=\"node.nodes\" data-ng-class=\"{hidden: collapsed}\" class=\"se-tree-node__ol\"><li data-ng-repeat=\"node in node.nodes\" data-ui-tree-node data-ng-include=\"'treeNodeRendererTemplate.html'\"></li></ol>"
    );
     
    $templateCache.put(
        "yTreeComponentTemplate.html", 
        "<div data-ui-tree=\"$ctrl.treeOptions.callbacks\" data-drag-enabled=\"$ctrl.treeOptions.dragEnabled\" data-drag-delay=\"$ctrl.treeOptions.dragDelay\" class=\"categoryTable se-tree\"><div class=\"se-tree__body\"><div class=\"desktopLayout clearfix\"><ol data-ui-tree-nodes=\"\" data-ng-model=\"$ctrl.root.nodes\" class=\"se-tree__nodes\"><li data-ng-if=\"$ctrl.root.nodes.length === 0\" class=\"se-tree__nodes--nodata\" data-translate=\"se.ytree.no.nodes.to.display\"></li><li class=\"se-tree__nodes--item\" data-ng-repeat=\"node in $ctrl.root.nodes\" data-ui-tree-node data-ng-include=\"'treeNodeRendererTemplate.html'\"></li></ol></div></div></div>"
    );
     
    $templateCache.put(
        "TreeComponent.html", 
        "<div class=\"categoryTable se-tree\"><div class=\"se-tree__body\"><div class=\"desktopLayout\"><ol class=\"se-tree__nodes\"><li *ngIf=\"(this.treeService.dataSource.get() | async).length === 0\" class=\"se-tree__nodes--nodata\">{{ 'se.ytree.no.nodes.to.display' | translate }}</li><li class=\"se-tree__nodes--item\"><se-tree-node [source]=\"this.treeService.dataSource.get() | async\"></se-tree-node></li></ol></div></div></div>"
    );
     
    $templateCache.put(
        "TreeNodeComponent.html", 
        "<ol class=\"se-tree-node__ol angular-ui-tree-nodes\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\" [cdkDropListData]=\"source\" [cdkDropListDisabled]=\"isDisabled\"><li *ngFor=\"let node of source\" cdkDrag [cdkDragData]=\"node\" class=\"angular-ui-tree-node se-tree-node__li\"><se-tree-node-renderer [node]=\"node\"></se-tree-node-renderer></li></ol>"
    );
     
    $templateCache.put(
        "TreeNodeRendererComponent.html", 
        "<div class=\"tree-node tree-node-content se-tree-node angular-ui-tree-handle\" [ngClass]=\"{        'hovered': node.mouseHovered,        'se-tree-node--first-level': isRootNodeDescendant,        'se-tree-node--selected': !collapsed    }\" [ngStyle]=\"{        'padding-left': getPaddingLeft(node.level)    }\" [attr.level]=\"node.level\" (mouseover)=\"onMouseOver()\" (mouseout)=\"onMouseOut()\"><div *ngIf=\"!showAsList\" class=\"se-tree-node__expander--wrapper col-xs-1 text-center\"><a class=\"se-tree-node__expander btn btn-link btn-sm\" *ngIf=\"node.hasChildren\" [attr.disabled]=\"isDisabled || null\" (click)=\"toggle($event)\"><span [ngClass]=\"{                    'sap-icon--slim-arrow-right': collapsed,                    'sap-icon--slim-arrow-down': !collapsed                }\"></span></a></div><div *ngIf=\"displayDefaultTemplate\" class=\"se-tree-node__name col-xs-5\" [attr.title]=\"node.title | seL10n | async \"><span>{{node.name}}</span><h6 *ngIf=\"node.title\">{{node.title | seL10n | async }}</h6></div><div [ngStyle]=\"{'width': '100%'}\" *ngIf=\"tree.nodeTemplateUrl\" [ngInclude]=\"tree.nodeTemplateUrl\" [scope]=\"{node: node}\" [compileHtmlNgController]=\"legacyController\"></div><ng-container *ngIf=\"tree.nodeComponent\"><ng-container *ngComponentOutlet=\"tree.nodeComponent; injector: nodeComponentInjector\"></ng-container></ng-container></div><se-tree-node [source]=\"node.nodes\" *ngIf=\"node.nodes.length && node.isExpanded\"></se-tree-node>"
    );
     
    $templateCache.put(
        "accordion-group.html", 
        "<div role=\"tab\" id=\"{{::headingId}}\" aria-selected=\"{{isOpen}}\" class=\"yCollapsibleContainer__header\" ng-keypress=\"toggleOpen($event)\"><a role=\"button\" data-toggle=\"collapse\" href aria-expanded=\"{{isOpen}}\" aria-controls=\"{{::panelId}}\" tabindex=\"0\" class=\"accordion-toggle yCollapsibleContainer__title\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\" ng-disabled=\"isDisabled\" uib-tabindex-toggle><span uib-accordion-header ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span> </a><a class=\"yCollapsibleContainer__icon btn btn-link\" data-toggle-id=\"toggle-1\" title=\"{{isOpen ? 'se.ycollapsible.action.collapse' : 'se.ycollapsible.action.expand' | translate}}\" aria-expanded=\"{{isOpen}}\" ng-click=\"toggleOpen()\"><span class=\"sap-icon--navigation-right-arrow y-collapsible-icon\" data-ng-class=\"{            'y-collapsible-icon--collapse':isOpen, 'y-collapsible-icon--expand':!isOpen}\"></span></a></div><div id=\"{{::panelId}}\" aria-labelledby=\"{{::headingId}}\" aria-hidden=\"{{!isOpen}}\" role=\"tabpanel\" class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\"><div ng-transclude></div></div>"
    );
     
    $templateCache.put(
        "yCollapsibleContainer.html", 
        "<uib-accordion class=\"y-collapsible\"><div uib-accordion-group class=\"yCollapsibleContainer__group y-collapsible__group\" data-template-url=\"accordion-group.html\" data-is-open=\"$ctrl.isExpanded\" data-ng-class=\"$ctrl.getIconRelatedClassname()\"><uib-accordion-heading class=\"y-collapsible__heading\"><div class=\"yCollapsibleContainer__title y-collapsible__title\" data-ng-transclude=\"collapsible-container-title\"></div></uib-accordion-heading><div class=\"y-collapsible__content\" data-ng-transclude=\"collapsible-container-content\"></div></div></uib-accordion>"
    );
     
    $templateCache.put(
        "yDataTableTemplate.html", 
        "<se-data-table [items]=\"$ctrl.items\" [config]=\"$ctrl.config\" [columns]=\"$ctrl.columns\" (on-sort-column)=\"$ctrl.onSortColumn($event.$columnKey, $event.$columnSortMode)\"></se-data-table>"
    );
     
    $templateCache.put(
        "yMessage.html", 
        "<se-message [message-id]=\"$ctrl.messageId\" [type]=\"$ctrl.type\"><div se-message-title id=\"y-message-title\"></div><div se-message-description id=\"y-message-description\"></div></se-message><div ng-hide=\"true\"><div ng-transclude=\"messageTitle\" id=\"y-message-title-source\"></div><div ng-transclude=\"messageDescription\" id=\"y-message-description-source\"></div></div>"
    );
     
    $templateCache.put(
        "moreTextTemplate.html", 
        "<se-more-text [text]=\"$ctrl.text\" [limit]=\"$ctrl.limit\" [more-label-i18n-key]=\"$ctrl.moreLabelI18nKey\" [less-label-i18n-key]=\"$ctrl.lessLabelI18nKey\" [ellipsis]=\"$ctrl.ellipsis\"></se-more-text>"
    );
     
    $templateCache.put(
        "defaultItemTemplate.html", 
        "<span class=\"y-select-default-item\" data-ng-bind-html=\"item.label | l10n | translate\"></span>"
    );
     
    $templateCache.put(
        "uiSelectChoicesTemplate.html", 
        "<ul tabindex=\"-1\" class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{'select2-result-with-children': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{'select2-result-sub': $select.choiceGrouped($group), 'select2-result-single': !$select.choiceGrouped($group) }\"><div data-ng-if=\"$ctrl.resultsHeaderTemplate || $ctrl.resultsHeaderTemplateUrl\"><div data-ng-if=\"$ctrl.resultsHeaderTemplate\" data-compile-html=\"$ctrl.resultsHeaderTemplate\"></div><div data-ng-if=\"$ctrl.resultsHeaderTemplateUrl\" data-ng-include=\"$ctrl.resultsHeaderTemplateUrl\"></div></div><li class=\"y-infinite-scrolling__listbox-header\" data-ng-show=\"$ctrl.showResultHeader()\">{{ $ctrl.resultsHeaderLabel | translate }}</li><li role=\"option\" ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{'select2-highlighted': $select.isActive(this), 'select2-disabled': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>"
    );
     
    $templateCache.put(
        "uiSelectPagedChoicesTemplate.html", 
        "<ul tabindex=\"-1\" class=\"ui-select-choices ui-select-choices-content select2-results ui-select-choices__infinite-scrolling\"><li class=\"ui-select-choices-group\" data-ng-class=\"{'select2-result-with-children': $select.choiceGrouped($group) }\"><div data-ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" data-ng-bind=\"$group.name\"></div><y-infinite-scrolling data-ng-if=\"$select.open\" data-drop-down-class=\"\" data-page-size=\"10\" data-mask=\"$select.search\" data-fetch-page=\"$ctrl.fetchStrategy.fetchPage\" data-context=\"$ctrl\"><ul role=\"listbox\" id=\"ui-select-choices-{{ $select.generatedId }}\" data-ng-class=\"{'select2-result-sub': $select.choiceGrouped($group), 'select2-result-single': !$select.choiceGrouped($group) }\"><div data-ng-if=\"$ctrl.resultsHeaderTemplate\" data-compile-html=\"$ctrl.resultsHeaderTemplate\"></div><div data-ng-if=\"$ctrl.resultsHeaderTemplateUrl\" data-ng-include=\"$ctrl.resultsHeaderTemplateUrl\"></div><li class=\"y-infinite-scrolling__listbox-header\" data-ng-show=\"$ctrl.showResultHeader()\">{{ $ctrl.resultsHeaderLabel | translate }}</li><li role=\"option\" data-ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" data-ng-class=\"{'select2-highlighted': $select.isActive(this), 'select2-disabled': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></y-infinite-scrolling></li></ul>"
    );
     
    $templateCache.put(
        "yMultiSelectTemplate.html", 
        "<ui-select id=\"{{$ctrl.id}}-selector\" multiple=\"multiple\" sortable=\"true\" theme=\"<%= theme %>\" data-ng-model=\"$ctrl.model\" data-ng-model-options=\"{ debounce: 500 }\" style=\"width: 100%\" data-ng-change=\"$ctrl.internalOnChange()\" ng-disabled=\"$ctrl.isReadOnly\" reset-search-input=\"$ctrl.resetSearchInput\" on-remove=\"$ctrl.internalOnRemove($item, $model)\" on-select=\"$ctrl.internalOnSelect($item, $model)\" data-ng-init=\"$ctrl.internalInit($select)\" data-ng-keyup=\"$ctrl.internalKeyup($event, $select.search)\" class=\"se-generic-editor-dropdown\" data-ng-class=\"{'se-generic-editor-dropdown__paged':$ctrl.requiresPaginatedStyling(), 'has-error': $ctrl.hasError(), 'has-warning': $ctrl.hasWarning()}\"><ui-select-match class=\"se-generic-editor-dropdown__match se-generic-editor-multiple-dropdown__match\" placeholder=\"{{$ctrl.placeholder || 'se.genericeditor.sedropdown.placeholder' | translate}}\"><item-printer id=\"{{$ctrl.id}}-selected\" data-model=\"$item\" data-template-url=\"$ctrl.itemTemplate\" class=\"\" data-ng-class=\"{'se-generic-editor-dropdown__item-printer':$ctrl.hasControls()}\"></item-printer></ui-select-match><ui-select-choices id=\"{{$ctrl.id}}-list\" {% filtering %} position=\"down\"><div data-ng-include=\"$ctrl.itemTemplate\"></div></ui-select-choices></ui-select>"
    );
     
    $templateCache.put(
        "ySelectTemplate.html", 
        "<ui-select id=\"{{$ctrl.id}}-selector\" data-ng-model=\"$ctrl.model\" data-ng-model-options=\"{ debounce: 500 }\" style=\"width: 100%\" theme=\"<%= theme %>\" search-enabled=\"$ctrl.searchEnabled\" data-ng-change=\"$ctrl.internalOnChange()\" reset-search-input=\"$ctrl.resetSearchInput\" on-remove=\"$ctrl.internalOnRemove($item, $model)\" on-select=\"$ctrl.internalOnSelect($item, $model)\" data-ng-init=\"$ctrl.internalInit($select)\" data-ng-keyup=\"$ctrl.internalKeyup($event, $select.search)\" data-ng-class=\"{'se-generic-editor-dropdown__paged':$ctrl.requiresPaginatedStyling(), 'has-error': $ctrl.hasError(), 'has-warning': $ctrl.hasWarning() }\" class=\"se-generic-editor-dropdown\" ng-disabled=\"$ctrl.isReadOnly\"><ui-select-match placeholder=\"{{$ctrl.placeholder || 'se.genericeditor.sedropdown.placeholder' | translate}}\" class=\"se-generic-editor-dropdown__match2\"><span data-ng-if=\"$ctrl.hasControls()\" class=\"input-group-addon glyphicon glyphicon-search ySESearchIcon__navigation\"></span><item-printer id=\"{{$ctrl.id}}-selected\" data-model=\"$select.selected\" data-template-url=\"$ctrl.itemTemplate\" class=\"y-select-item-printer\" data-ng-class=\"{'se-generic-editor-dropdown__item-printer':$ctrl.hasControls()}\"></item-printer><span data-ng-if=\"$ctrl.hasControls() || $ctrl.showRemoveButton\" class=\"sap-icon--sys-cancel ySESearchIcon__navigation se-generic-editor-dropdown__remove-button\" data-ng-click=\"$ctrl.clear($select, $event)\"></span></ui-select-match><ui-select-choices id=\"{{$ctrl.id}}-list\" {% filtering %} position=\"down\" ui-disable-choice=\"$ctrl.disableChoice(item)\" data-ng-click=\"$event.stopPropagation()\"><div data-ng-include=\"$ctrl.itemTemplate\"></div></ui-select-choices><ui-select-no-choice data-ng-if=\"$ctrl.noResultLabel\" class=\"y-select-no-result-label\">{{$ctrl.noResultLabel | translate}}</ui-select-no-choice></ui-select>"
    );
     
    $templateCache.put(
        "modalTemplate.html", 
        "<div id=\"y-modal-dialog\" class=\"fd-modal\"><div class=\"fd-modal__content\" data-ng-class=\"modalController._getModalType()\"><div class=\"se-modal__header fd-modal__header\" data-ng-class=\"{'se-modal__header--no-title': !modalController._modalManager.title}\" data-ng-if=\"modalController._modalManager.title\"><div class=\"se-nowrap-ellipsis se-modal__header-title fd-modal__title\" id=\"smartedit-modal-title-{{ modalController._modalManager.title }}\">{{ modalController._modalManager.title | translate }}&nbsp;{{ modalController._modalManager.titleSuffix | translate }}</div><button type=\"button\" aria-label=\"close\" class=\"se-modal-close fd-button--light fd-modal__close\" data-ng-if=\"modalController._modalManager._showDismissButton()\" data-ng-click=\"modalController._modalManager._handleDismissButton()\"></button></div><div class=\"se-modal__body fd-modal__body\" id=\"modalBody\"><div data-ng-include=\"modalController.templateUrl\"></div></div><div class=\"se-modal__footer fd-modal__footer\" data-ng-if=\"modalController._modalManager._hasButtons()\"><span data-ng-repeat=\"button in modalController._modalManager.getButtons()\"><button id=\"{{ button.id }}\" type=\"button\" class=\"se-modal-button--footer fd-button\" data-ng-disabled=\"button.disabled\" data-ng-class=\"{                        'fd-button--light': button.style=='default',                         'fd-button--emphasized': button.style=='primary'}\" data-ng-click=\"modalController._modalManager._buttonPressed(button)\">{{ button.label | translate }}</button></span></div></div></div>"
    );
     
    $templateCache.put(
        "DropdownMenuComponent.html", 
        "<fd-popover [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"placement || 'bottom-end'\" class=\"se-dropdown-more-menu\"><fd-popover-control><div #toggleMenu><div *ngIf=\"!useProjectedAnchor; else projectedAnchor;\" class=\"sap-icon--overflow se-dropdown-more-menu__toggle\"></div><ng-template #projectedAnchor><ng-content></ng-content></ng-template></div></fd-popover-control><fd-popover-body><fd-menu><ul fd-menu-list class=\"se-dropdown-menu__list\" [ngClass]=\"additionalClasses\"><se-dropdown-menu-item *ngFor=\"let dropdownItem of clonedDropdownItems\" [dropdownItem]=\"dropdownItem\" [selectedItem]=\"selectedItem\"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>"
    );
     
    $templateCache.put(
        "DropdownMenuItemComponent.html", 
        "<li *ngIf=\"dropdownItem.condition(selectedItem)\" class=\"se-dropdown-menu__item-wrapper\" [ngClass]=\"dropdownItem.customCss\"><ng-container *ngIf=\"dropdownItem.component\"><ng-container *ngComponentOutlet=\"dropdownItem.component; injector: dropdownItemInjector\"></ng-container></ng-container><span *ngIf=\"dropdownItem.templateUrl\" [ngInclude]=\"dropdownItem.templateUrl\" [compileHtmlNgController]=\"compileHtmlNgController\"></span></li>"
    );
     
    $templateCache.put(
        "DropdownMenuItemDefaultComponent.html", 
        "<a class=\"se-dropdown-item fd-menu__item\" [ngClass]=\"data.dropdownItem.customCss\" (click)=\"data.dropdownItem.callback(data.selectedItem, data.dropdownItem)\"><span *ngIf=\"data.dropdownItem.icon\" [ngClass]=\"data.dropdownItem.icon\"></span> <span>{{ data.dropdownItem.key | translate }}</span></a>"
    );
     
    $templateCache.put(
        "yDropDownMenuTemplate.html", 
        "<div class=\"y-dropdown-more-menu\" data-uib-dropdown><div class=\"sap-icon--overflow y-dropdown-more-menu__toggle\" data-uib-dropdown-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\"></div><ul class=\"se-y-dropdown-menu__list fd-menu__list\" data-uib-dropdown-menu><li data-ng-repeat=\"dropdownItem in $ctrl.clonedDropdownItems\" data-ng-if=\"dropdownItem.condition($ctrl.selectedItem)\" data-ng-class=\"dropdownItem.customCss\" class=\"se-dropdown-menu__item-wrapper\"><span data-ng-include=\"dropdownItem.templateUrl\"></span></li></ul></div>"
    );
     
    $templateCache.put(
        "GenericEditorFIeldMessagesComponent.html", 
        "<div *ngIf=\"errors.length > 0\"><span *ngFor=\"let error of errors\" class=\"se-help-block--has-error help-block fd-form__message fd-form__message--error\">{{ error | translate}}</span></div><div *ngIf=\"warnings.length > 0\"><span *ngFor=\"let warning of warnings\" class=\"se-help-block--has-warning help-block fd-form__message fd-form__message--warning\">{{ warning | translate }}</span></div>"
    );
     
    $templateCache.put(
        "GenericEditorFieldComponent.html", 
        "<div [attr.validation-id]=\"field.qualifier\" class=\"ySEField\"><div *ngIf=\"field.template\"><div #widget></div></div><ng-container *ngIf=\"field.component\"><ng-container *ngComponentOutlet=\"field.component; injector: widgetInjector\"></ng-container></ng-container><se-generic-editor-field-messages [field]=\"field\" [qualifier]=\"qualifier\"></se-generic-editor-field-messages><div *ngIf=\"field.postfix\" class=\"ySEText ySEFieldPostfix\">{{ field.postfix | translate }}</div></div>"
    );
     
    $templateCache.put(
        "GenericEditorTabComponent.html", 
        "<div class=\"se-generic-editor__row ySErow\" *ngFor=\"let field of fields\" [ngClass]=\"'se-generic-editor__row--' + field.qualifier\"><label [id]=\"field.qualifier + '-label'\" class=\"se-control-label\" *ngIf=\"!field.hidePrefixLabel && field.i18nKey\" [ngClass]=\"{ required: field.required }\">{{ field.i18nKey | lowercase | translate }}</label><div class=\"ySEGenericEditorFieldStructure\" [id]=\"field.qualifier\" [attr.data-cms-field-qualifier]=\"field.qualifier\" [attr.data-cms-structure-type]=\"field.cmsStructureType\"><ng-template [formRenderer]=\"getForm(field.qualifier)\"></ng-template></div></div>"
    );
     
    $templateCache.put(
        "LocalizedElementComponent.html", 
        "<se-tabs *ngIf=\"tabs\" class=\"multi-tabs-editor\" [model]=\"form\" [tabsList]=\"tabs\" [numTabsDisplayed]=\"6\"></se-tabs>"
    );
     
    $templateCache.put(
        "errorMessageTemplate.html", 
        "<span data-ng-if=\"field.errors\" data-ng-repeat=\"error in field.errors | filter:{language:qualifier}\" id=\"validation-error-{{field.qualifier}}-{{qualifier}}-{{$index}}\" class=\"se-help-block--has-error help-block fd-form__message fd-form__message--error\">{{ error.message | translate }}</span>"
    );
     
    $templateCache.put(
        "yEditableListDefaultItemTemplate.html", 
        "<div><span>{{ node.uid }}</span><se-dropdown-menu data-ng-if=\"$ctrl.editable\" [dropdown-items]=\"$ctrl.getDropdownItems()\" [selected-item]=\"this\" class=\"pull-right se-tree-node__actions--more-menu\"></se-dropdown-menu></div>"
    );
     
    $templateCache.put(
        "yEditableListTemplate.html", 
        "<div data-ng-class=\"{ 'y-editable-list-disabled': !$ctrl.editable }\"><ytree remove-default-template=\"true\" data-root-node-uid=\"$ctrl.rootId\" data-node-template-url=\"$ctrl.itemTemplateUrl\" data-node-actions=\"$ctrl.actions\" data-drag-options=\"$ctrl.dragOptions\" data-show-as-list=\"true\"/></div>"
    );
     
    $templateCache.put(
        "ActionableSearchItemComponent.html", 
        "<div *ngIf=\"search\" class=\"se-actionable-search-item\"><div class=\"se-actionable-search-item__name\">{{ search }}</div><button type=\"button\" class=\"fd-button--light se-actionable-search-item__action-btn\" (click)=\"onButtonClick()\">{{ getActionText() | translate }}</button></div>"
    );
     
    $templateCache.put(
        "DefaultItemPrinterComponent.html", 
        "<span [attr.title]=\"((data.item.label || data.item.name) | seL10n | async) | translate\" class=\"se-item-printer-text se-nowrap-ellipsis\">{{ ((data.item.label || data.item.name) | seL10n | async) | translate }}</span>"
    );
     
    $templateCache.put(
        "ItemPrinterComponent.html", 
        "<ng-container *ngComponentOutlet=\"component; injector: componentInjector\"></ng-container>"
    );
     
    $templateCache.put(
        "ResultsHeaderComponent.html", 
        "<div *ngIf=\"showResultsHeaderItem() || resultsHeaderLabel || actionableSearchItem\" class=\"results-header\"><div *ngIf=\"showResultsHeaderItem()\"><ng-container *ngComponentOutlet=\"resultsHeaderComponent\"></ng-container></div><se-actionable-search-item *ngIf=\"actionableSearchItem\" [search]=\"search\" [eventId]=\"actionableSearchItem.eventId\" [actionText]=\"actionableSearchItem.actionText\" (actionButtonClick)=\"onActionButtonClick()\"></se-actionable-search-item><li class=\"fd-menu__list-header\" *ngIf=\"displayResultsHeaderLabel\">{{ resultsHeaderLabel | translate }}</li></div>"
    );
     
    $templateCache.put(
        "SearchInputComponent.html", 
        "<div class=\"search\"><input #searchInput type=\"search\" class=\"search__input\" [disabled]=\"isDisabled\" [readOnly]=\"isReadOnly\" [placeholder]=\"placeholder\" [ngModel]=\"search\" (ngModelChange)=\"onChange($event)\" (keyup)=\"onKeyup($event)\"/></div>"
    );
     
    $templateCache.put(
        "SelectListComponent.html", 
        "<se-infinite-scrolling *ngIf=\"isPagedDropdown; else selectList\" [pageSize]=\"infiniteScrollingPageSize\" [mask]=\"search\" [fetchPage]=\"fetchPage\" [context]=\"selectComponentCtx\" (itemsChange)=\"onInfiniteScrollItemsChange()\"><ng-container *ngTemplateOutlet=\"selectList\"></ng-container></se-infinite-scrolling><ng-template #selectList><ol [attr.id]=\"id +'-list'\" fd-menu-list suListKeyboardControl [suListKeyboardControlDisabledPredicate]=\"keyboardControlDisabledPredicate\" (suListKeyboardControlEnterKeydown)=\"onEnterKeydown($event)\" [ngClass]=\"{ 'fd-menu__list--basic': !isPagedDropdown }\"><ng-container *ngFor=\"let item of items; trackBy: itemTrackBy\"><li *ngIf=\"(excludeSelected && !isItemSelected(item)) || !excludeSelected\" suListItemKeyboardControl class=\"se-select-list__item\" [ngClass]=\"{'is-selected': (!excludeSelected && isItemSelected(item)), 'is-disabled': isItemDisabled(item)}\"><fd-option (click)=\"onOptionClick($event, item)\" class=\"menu-option\"><se-item-printer [item]=\"item\" [isSelected]=\"false\" [component]=\"itemComponent\" [selectComponentCtx]=\"selectComponentCtx\"></se-item-printer></fd-option></li></ng-container></ol></ng-template>"
    );
     
    $templateCache.put(
        "sliderPanelTemplate.html", 
        "<div class=\"se-slider-panel-wrapper\" data-ng-if=\"$ctrl.isShown\"><div class=\"se-slider-panel-container slide-in\"><div class=\"se-slider-panel__header\" data-ng-show=\"$ctrl.sliderPanelConfiguration.modal\"><span class=\"se-slider-panel__title\" data-ng-if=\"$ctrl.sliderPanelConfiguration.modal.title\">{{ $ctrl.sliderPanelConfiguration.modal.title | translate }}</span> <button type=\"button\" class=\"se-slider-panel__close-btn fd-button--light fd-modal__close\" aria-label=\"close\" data-ng-if=\"$ctrl.sliderPanelConfiguration.modal.showDismissButton\" data-ng-click=\"$ctrl.sliderPanelDismissAction()\"></button></div><div class=\"se-slider-panel__body\" data-ng-transclude></div><div class=\"se-slider-panel__footer\" data-ng-if=\"($ctrl.sliderPanelConfiguration.modal.cancel || $ctrl.sliderPanelConfiguration.modal.save)\"><button type=\"button\" class=\"fd-button--light se-slider-panel__footer-btn se-slider-panel__footer-btn--cancel\" data-ng-if=\"$ctrl.sliderPanelConfiguration.modal.cancel\" data-ng-click=\"$ctrl.sliderPanelConfiguration.modal.cancel.onClick()\">{{ $ctrl.sliderPanelConfiguration.modal.cancel.label | translate }}</button> <button type=\"button\" class=\"fd-button--emphasized se-slider-panel__footer-btn se-slider-panel__footer-btn--save\" data-ng-if=\"$ctrl.sliderPanelConfiguration.modal.save\" data-ng-click=\"$ctrl.sliderPanelConfiguration.modal.save.onClick()\" data-ng-disabled=\"$ctrl.isSaveDisabled()\">{{ $ctrl.sliderPanelConfiguration.modal.save.label | translate }}</button></div></div></div>"
    );
     
    $templateCache.put(
        "yActionableSearchItemTemplate.html", 
        "<div class=\"se-actionable-search-item\" data-ng-if=\"$ctrl.getInputText()\"><div class=\"se-actionable-search-item__name\">{{ $ctrl.getInputText() }}</div><button type=\"button\" class=\"fd-button--light se-actionable-search-item__create-btn\" data-ng-show=\"$ctrl.showForm()\" data-ng-click=\"$ctrl.buttonPressed()\">{{ $ctrl.getActionText() | translate }}</button></div>"
    );
     
    $templateCache.put(
        "GenericEditorDropdownComponent.html", 
        "<se-select *ngIf=\"dropdown.initialized\" [id]=\"dropdown.qualifier\" (click)=\"dropdown.onClick()\" [placeholder]=\"field.placeholder\" [(model)]=\"model[qualifier]\" [onChange]=\"dropdown.triggerAction\" [fetchStrategy]=\"dropdown.fetchStrategy\" [(reset)]=\"dropdown.reset\" [multiSelect]=\"dropdown.isMultiDropdown\" [controls]=\"dropdown.isMultiDropdown\" [showRemoveButton]=\"showRemoveButton\" [isReadOnly]=\"!field.editable\" [itemComponent]=\"itemComponent\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [actionableSearchItem]=\"actionableSearchItem\" (getApi)=\"dropdown.setSelectAPI($event)\" (resetChange)=\"onResetChange($event)\"></se-select>"
    );
     
    $templateCache.put(
        "BooleanComponent.html", 
        "<div class=\"se-boolean fd-form__item fd-form__item--check\"><span class=\"fd-toggle fd-toggle--xs fd-form__control\"><label class=\"fd-form__label\" for=\"{{qualifierId}}-checkbox\"><input type=\"checkbox\" id=\"{{qualifierId}}-checkbox\" class=\"se-boolean__input\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"!widget.field.editable\" [(ngModel)]=\"widget.model[widget.qualifier]\"/> <span class=\"fd-toggle__switch\" role=\"presentation\"></span></label></span><p *ngIf=\"widget.field.labelText && !widget.model[widget.qualifier]\" class=\"se-boolean__text\">{{widget.field.labelText| translate}}</p></div>"
    );
     
    $templateCache.put(
        "DateTimePickerComponent.html", 
        "<div #dateTimePicker *ngIf=\"isEditable\" class=\"input-group se-date-field\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{            'is-invalid': widget.field.hasErrors,            'is-warning': widget.field.hasWarnings,            'se-input--is-disabled': !isEditable        }\" [placeholder]=\"placeholderText | translate\" [attr.name]=\"widget.field.qualifier\"/> <span class=\"input-group-addon se-date-field--button\" [ngClass]=\"{ 'se-date-field--button-has-error': widget.field.hasErrors, 'se-date-field--button-has-warning': widget.field.hasWarnings }\"><span class=\"sap-icon--calendar se-date-field--button-icon\"></span></span></div><div class=\"input-group date se-date-field\" *ngIf=\"!isEditable\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{'se-input--is-disabled': !isEditable}\" [(ngModel)]=\"widget.model[this.widget.qualifier]\" dateFormatter formatType=\"short\" [disabled]=\"true\"/></div>"
    );
     
    $templateCache.put(
        "EditableDropdownComponent.html", 
        "<se-generic-editor-dropdown [id]=\"data.id\" [field]=\"data.field\" [qualifier]=\"data.qualifier\" [model]=\"data.model\"></se-generic-editor-dropdown>"
    );
     
    $templateCache.put(
        "EmailComponent.html", 
        "<input [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [max]=\"255\" type=\"email\" id=\"{{widget.field.qualifier}}-shortstring\" class=\"fd-form-control\"/>"
    );
     
    $templateCache.put(
        "FloatComponent.html", 
        "<input pattern=\"^[-]?([0-9]*)(\.[0-9]{1,5})?$\" type=\"number\" id=\"{{widget.field.qualifier}}-float\" class=\"fd-form-control\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [step]=\"precision\"/>"
    );
     
    $templateCache.put(
        "NumberComponent.html", 
        "<input [min]=\"1\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" id=\"{{widget.field.qualifier}}-number\" class=\"fd-form-control\" type=\"number\"/>"
    );
     
    $templateCache.put(
        "RichTextFieldComponent.html", 
        "<textarea #textarea class=\"fd-form__control\" [ngClass]=\"{'has-error': widget.field.hasErrors}\" name=\"{{widget.field.qualifier}}-{{widget.qualifier}}\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" (change)=\"reassignUserCheck()\"></textarea><div *ngIf=\"requiresUserCheck()\"><div id=\"richTextWarningMessage\" [hidden]=\"widget.field.isUserChecked\"><span fd-status-label [status]=\"'warning'\" [icon]=\"'message-warning'\">{{'se.editor.richtext.message.warning' | translate}}</span></div><input id=\"richTextWarningCheckBox\" type=\"checkbox\" [(ngModel)]=\"widget.field.isUserChecked\" (click)=\"checkboxOnClick($event.target)\"/> <span [ngClass]=\"{'warning-check-msg': true, 'not-checked': widget.editor.hasFrontEndValidationErrors && !widget.field.isUserChecked}\">{{'se.editor.richtext.check' | translate}}</span></div>"
    );
     
    $templateCache.put(
        "seDropdownTemplate.html", 
        "<y-select data-ng-if=\"$ctrl.dropdown.initialized\" data-id=\"{{$ctrl.dropdown.qualifier}}\" data-ng-click=\"$ctrl.dropdown.onClick()\" data-placeholder=\"$ctrl.field.placeholder\" data-ng-model=\"$ctrl.model[$ctrl.qualifier]\" data-on-change=\"$ctrl.dropdown.triggerAction\" data-fetch-strategy=\"$ctrl.dropdown.fetchStrategy\" data-reset=\"$ctrl.dropdown.reset\" data-multi-select=\"$ctrl.dropdown.isMultiDropdown\" data-controls=\"$ctrl.dropdown.isMultiDropdown\" data-show-remove-button=\"$ctrl.showRemoveButton\" data-is-read-only=\"!$ctrl.field.editable\" data-item-template=\"$ctrl.itemTemplateUrl\" data-results-header-template-url=\"$ctrl.dropdown.resultsHeaderTemplateUrl\" data-results-header-template=\"$ctrl.dropdown.resultsHeaderTemplate\" data-get-api=\"$ctrl.dropdown.setYSelectAPI($api)\"/>"
    );
    
      }]);
    })();

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit module as entry point.
 * @param id The module identifier used when loading it into Smartedit.
 */
var SeEntryModule = function (id) {
    return function (moduleConstructor) {
        window.__smartedit__.modules[id] = moduleConstructor;
        return moduleConstructor;
    };
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/** @internal */
var DINameUtils = /** @class */ (function () {
    function DINameUtils() {
    }
    DINameUtils.prototype.buildComponentName = function (componentConstructor) {
        return this.buildName(componentConstructor)
            .replace(/Component$/, '')
            .replace(/Directive$/, '');
    };
    DINameUtils.prototype.buildFilterName = function (filterConstructor) {
        return this.buildName(filterConstructor).replace(/Filter$/, '');
    };
    DINameUtils.prototype.buildServiceName = function (serviceConstructor) {
        return this.buildName(serviceConstructor);
    };
    DINameUtils.prototype.buildModuleName = function (moduleConstructor) {
        return this.buildName(moduleConstructor).replace(/Module$/, '');
    };
    // builds the DI recipe name for a given construtor
    DINameUtils.prototype.buildName = function (constructor) {
        var originalConstructor = utils.annotationService.getOriginalConstructor(constructor);
        var originalName = utils.functionsUtils.getConstructorName(originalConstructor);
        return this.convertNameCasing(originalName);
    };
    // converts the first character to lower case
    DINameUtils.prototype.convertNameCasing = function (originalName) {
        var builtName = originalName.substring(0, 1).toLowerCase() + originalName.substring(1);
        return builtName;
    };
    /*
     * This method will generate a SeValueProvider from a shortHand map built off a variable:
     * if a variable x (or DEFAULT_x) equals 5, then the method will return
     * { provide : 'x', useValue: 5} when it is passed {x}
     */
    /* forbiddenNameSpaces useValue:false */
    DINameUtils.prototype.makeValueProvider = function (variableShortHand) {
        var fullKey = Object.keys(variableShortHand)[0];
        var key = fullKey.replace(/^DEFAULT_/, '');
        return {
            provide: key,
            useValue: variableShortHand[fullKey]
        };
    };
    return DINameUtils;
}());
var diNameUtils = new DINameUtils();

var MultiProviderMap = {};
/**
 * **Deprecated since 1905.**
 *
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit module from a Dependency injection standpoint.
 *
 * To create a configurable module, create a static method returning an SeModuleWithProvider object. The module
 * can then be imported by a parent module returning the SeModuleWithProvider object from the static method.
 * @deprecated
 */
var SeModule = function (definition) {
    return function (moduleConstructor) {
        definition = definition;
        var seModuleName = diNameUtils.buildName(moduleConstructor);
        var angularInstance = getAngular();
        var allImports = [];
        if (definition.imports) {
            definition.imports.forEach(function (importStatement, index) {
                var throwUnAnnotatedModuleError = function (seModule) {
                    var importedModule = diNameUtils.buildName(seModule);
                    throw new Error(importedModule + " module was imported into " + seModuleName + " module but doesn't seem to have been @SeModule annotated");
                };
                var moduleName;
                if (typeof importStatement === 'string') {
                    moduleName = importStatement;
                }
                else if (typeof importStatement === 'function') {
                    moduleName = importStatement.moduleName;
                    if (!moduleName) {
                        throwUnAnnotatedModuleError(importStatement);
                    }
                }
                else if (importStatement && importStatement.seModule) {
                    if (!importStatement.seModule.moduleName) {
                        throwUnAnnotatedModuleError(importStatement.seModule);
                    }
                    var moduleWithProvidersName = diNameUtils.buildName(importStatement.seModule);
                    var moduleWithProviders = angularInstance.module(moduleWithProvidersName);
                    moduleName = moduleWithProviders.name;
                    if (importStatement.providers) {
                        addArrayOfProvidersToModule(moduleWithProviders, importStatement.providers);
                    }
                }
                else {
                    throw new Error("the import statement " + importStatement + " at index " + index + " added to " + seModuleName + " is neither a legacy string nor an SeModuleConstructor");
                }
                if (allImports.indexOf(moduleName) > -1) {
                    throw new Error("module " + moduleName + " is imported more than once into " + seModuleName);
                }
                allImports.push(moduleName);
            });
        }
        var module = angularInstance.module(seModuleName, allImports);
        if (definition.providers) {
            addArrayOfProvidersToModule(module, definition.providers);
        }
        if (definition.declarations) {
            definition.declarations.forEach(function (declaration) {
                if (declaration.filterName) {
                    addFilterToModule(module, declaration);
                }
                else {
                    addFullComponentGraphToModule(module, declaration);
                }
            });
        }
        if (definition.config) {
            module.config(definition.config);
        }
        if (definition.initialize) {
            module.run(definition.initialize);
        }
        moduleConstructor.moduleName = module.name;
        return moduleConstructor;
    };
};
function addArrayOfProvidersToModule(module, providers) {
    providers.forEach(function (provider, index) {
        var moduleName = module.name;
        if (!provider) {
            throw new Error("At the time a provider at index " + index + " was added to module " + moduleName + ",\n\t\t\t\tit was undefined, this is probably due to the path in your typescript import statement\n\t\t\t\treferencing a barrel file of an alias defined in a higher layer, consider using a relative path instead.");
        }
        if (provider.provide &&
            !provider.useValue &&
            !provider.useClass &&
            !provider.useFactory) {
            throw new Error("At the time a provider named " + provider.provide + " was added to module " + moduleName + "\n\t\t        did not provide an instance of SeValueProvider, SeClassProvider, or FactoryProvider.");
        }
        if (provider.multi) {
            provider = provider;
            addMultiProviderToModule(module, provider);
        }
        else {
            addProviderToModule(module, provider);
        }
    });
}
function addProviderToModule(module, provider) {
    if (provider.useValue) {
        provider = provider;
        module.constant(provider.provide, provider.useValue);
    }
    else if (provider.useClass) {
        provider = provider;
        module.service(provider.provide, provider.useClass);
    }
    else if (provider.useFactory) {
        provider = provider;
        var isNgAnnotated = Array.isArray(provider.useFactory) || provider.useFactory.$inject;
        if (isNgAnnotated && provider.deps) {
            throw Error("At the time a provider " + provider.provide + " uses ngInject annotations and \n\t\t\tSeFactoryProvider.deps at the same time. Please use one or the other.");
        }
        var dependencies = provider.deps
            ? provider.deps.map(function (dependency) {
                return typeof dependency === 'string'
                    ? dependency
                    : diNameUtils.buildServiceName(dependency);
            })
            : [];
        // In current framework, this is only needed for case of multi and for uglify ready di
        module.factory(provider.provide, isNgAnnotated ? provider.useFactory : __spreadArrays(dependencies, [provider.useFactory]));
    }
    else {
        provider = provider;
        var serviceName = diNameUtils.buildServiceName(provider);
        module.service(serviceName, provider);
    }
}
function addMultiProviderToModule(module, provider) {
    var multiProviderMapName = module.name + provider.provide;
    var dependencies = MultiProviderMap[multiProviderMapName];
    if (!dependencies) {
        dependencies = [];
    }
    var multiProviderInstance = multiProviderMapName + lodash.uniqueId();
    dependencies.push(multiProviderInstance);
    MultiProviderMap[multiProviderMapName] = dependencies;
    var useFactory = function () {
        return [].slice.call(arguments);
    };
    addProviderToModule(module, __assign(__assign({}, provider), { provide: multiProviderInstance }));
    addProviderToModule(module, {
        provide: provider.provide,
        useFactory: useFactory,
        deps: dependencies
    });
}
function addFilterToModule(module, filterConstructor) {
    module.filter(filterConstructor.filterName, filterConstructor.transform);
}
function addFullComponentGraphToModule(module, component) {
    var definition = component.definition;
    if (!definition) {
        var componentConstructorName = utils.functionsUtils.getConstructorName(component);
        throw new Error(componentConstructorName + " component was imported into " + module.name + " module but doesn't seem to have been @SeComponent or @SeDirective annotated");
    }
    if (component.providers) {
        addArrayOfProvidersToModule(module, component.providers);
    }
    var componentName = component.componentName;
    var directivename = component.directiveName;
    if (componentName) {
        module.component(componentName, definition);
        delete component.definition;
        var entryComponents = component.entryComponents;
        if (entryComponents) {
            entryComponents.forEach(function (entryComponent) {
                addFullComponentGraphToModule(module, entryComponent);
            });
        }
        delete component.entryComponents;
    }
    else if (directivename) {
        module.directive(directivename, function () { return definition; });
    }
}
// For testing purposes.
SeModule.getAngular = function () {
    return angular$1;
};
function getAngular() {
    return SeModule.getAngular();
}

var /* @ngInject */ DIBridgeModule = /** @class */ (function () {
    function /* @ngInject */ DIBridgeModule() {
    }
    /* @ngInject */ DIBridgeModule = __decorate([
        SeModule({})
    ], /* @ngInject */ DIBridgeModule);
    return /* @ngInject */ DIBridgeModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/** @internal */
var parseDirectiveBindings = function (inputs) {
    var bindings;
    if (inputs && inputs.length) {
        bindings = inputs.reduce(function (seed, element) {
            var values = element.replace(/\s/g, '').split(':');
            var bindingProperty = values[values.length - 1];
            if (!bindingProperty.startsWith('@') &&
                !bindingProperty.startsWith('&') &&
                !bindingProperty.startsWith('=')) {
                bindingProperty = '<' + bindingProperty;
            }
            seed[values[0]] = bindingProperty;
            return seed;
        }, {});
    }
    return bindings;
};
/*
 * Used to determine directive name and restrict value in AngularJS given an Angular directive
 */
/** @internal */
var parseDirectiveName = function (selector, seContructor) {
    var attributeDirectiveNamePattern = /^\[([-\w]+)\]$/;
    var elementDirectiveNamePattern = /^([-\w]+)$/;
    if (!selector) {
        return { name: diNameUtils.buildComponentName(seContructor), restrict: 'E' };
    }
    else if (selector.startsWith('.')) {
        return { name: lodash.camelCase(selector.substring(1)), restrict: 'C' };
    }
    else if (attributeDirectiveNamePattern.test(selector)) {
        return {
            name: lodash.camelCase(attributeDirectiveNamePattern.exec(selector)[1]),
            restrict: 'A'
        };
    }
    else if (elementDirectiveNamePattern.test(selector)) {
        return { name: lodash.camelCase(elementDirectiveNamePattern.exec(selector)[1]), restrict: 'E' };
    }
    else {
        var directiveClassName = utils.functionsUtils.getConstructorName(seContructor);
        throw new Error("SeDirective " + directiveClassName + " declared an unexpected selector (" + selector + "). \n\t\tMake sure to use an element name or class (.class) or attribute ([attribute])");
    }
};
/**
 * ** Deprecated since 1905.**
 *
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit web directive from a Depencency injection standpoint.
 * This directive will have an isolated scope and will bind its properties to its controller
 * @deprecated
 */
var SeDirective = function (definition) {
    return function (directiveConstructor) {
        definition = definition;
        var directive = {
            controller: directiveConstructor,
            scope: typeof definition.scope === 'undefined' ? {} : definition.scope,
            replace: definition.replace,
            transclude: definition.transclude,
            template: definition.template,
            templateUrl: definition.templateUrl,
            controllerAs: definition.controllerAs,
            bindToController: parseDirectiveBindings(definition.inputs) || true,
            require: definition.require
        };
        var nameSet = parseDirectiveName(definition.selector, directiveConstructor);
        directive.restrict = nameSet.restrict;
        directiveConstructor.directiveName = nameSet.name;
        directiveConstructor.definition = directive;
        // will be browsed by owning @SeModule
        directiveConstructor.providers = definition.providers;
        return directiveConstructor;
    };
};

/** @internal */
var DIBridgeUtils = /** @class */ (function () {
    function DIBridgeUtils() {
    }
    DIBridgeUtils.prototype.downgradeComponent = function (definition, componentConstructor) {
        if (!utils.functionsUtils.isUnitTestMode()) {
            var nameSet = parseDirectiveName(definition.selector, componentConstructor);
            this._getBridgeModule().directive(nameSet.name, _static.downgradeComponent({
                component: componentConstructor
            }));
        }
    };
    DIBridgeUtils.prototype.downgradeService = function (name, serviceConstructor, token) {
        if (!utils.functionsUtils.isUnitTestMode()) {
            window.__smartedit__.downgradedService[name] = serviceConstructor;
            if (serviceConstructor) {
                var definition = window.__smartedit__.getDecoratorPayload('Injectable', serviceConstructor);
                if (definition && definition.providedIn !== 'root') {
                    throw new Error("service " + name + " is meant to be downgraded but is not provided in root: make sure to mark it with @Injectable({providedIn: 'root'})");
                }
            }
            this._getBridgeModule().factory(name, _static.downgradeInjectable(token ? token : serviceConstructor));
        }
    };
    /* forbiddenNameSpaces useFactory:false */
    DIBridgeUtils.prototype.upgradeProvider = function (angularJSInjectionKey, angularInjectionToken) {
        return {
            provide: angularInjectionToken ? angularInjectionToken : angularJSInjectionKey,
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            useFactory: function ($injector) {
                return $injector.get(angularJSInjectionKey);
            },
            deps: ['$injector'] // $injector is provided by UpgradeModule
        };
    };
    DIBridgeUtils.prototype._getBridgeModule = function () {
        /* forbiddenNameSpaces angular.module:false */
        return angular$1.module(DIBridgeModule.moduleName);
    };
    return DIBridgeUtils;
}());
var diBridgeUtils = new DIBridgeUtils();

var servicesToBeDowngraded = {};
/**
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to require an Angular service to be downgraded
 * This decorator must always be at the top/furthest from the class unless a token is provided
 * @param token `InjectionToken` that identifies a service provided from Angular.
 * Will default to using the constructor itself.
 */
var SeDowngradeService = function (token) {
    return function (serviceConstructor) {
        diBridgeUtils.downgradeService(diNameUtils.buildServiceName(serviceConstructor), serviceConstructor, token);
        return serviceConstructor;
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to require an Angular component to be downgraded
 */
var SeDowngradeComponent = function () {
    return function (componentConstructor) {
        /* forbiddenNameSpaces window._:false */
        if (!utils.functionsUtils.isUnitTestMode()) {
            var definition = window.__smartedit__.getDecoratorPayload('Component', componentConstructor);
            if (!definition) {
                var componentName = utils.functionsUtils.getConstructorName(componentConstructor);
                throw new Error("@SeDowngradeComponent " + componentName + " should only be used on a @Component decorated class");
            }
            diBridgeUtils.downgradeComponent(definition, componentConstructor);
        }
        return componentConstructor;
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * A collection of utility methods for Nodes.
 */
var NodeUtils = /** @class */ (function () {
    function NodeUtils() {
    }
    /**
     * Retrieves all the attributes of an overlay Node (identified by its data-smartedit-element-uuid attribute) containing with data-smartedit- or smartedit-
     * and package them as a map of key values.
     * Keys are stripped of data- and are turned to camelcase
     * @returns Map of key values.
     */
    NodeUtils.prototype.collectSmarteditAttributesByElementUuid = function (elementUuid) {
        var element = document.querySelector(".smartEditComponent[data-smartedit-element-uuid='" + elementUuid + "']");
        if (!element) {
            throw new Error("could not find element with uuid " + elementUuid);
        }
        return Array.from(element.attributes).reduce(function (attributes, node) {
            var attrName = node.name;
            if (attrName.indexOf('smartedit-') > -1) {
                attrName = lodash.camelCase(attrName.replace('data-', ''));
                attributes[attrName] = node.value;
            }
            return attributes;
        }, {});
    };
    NodeUtils.prototype.hasLegacyAngularJSBootsrap = function () {
        return !!document.querySelector('[ng-app], [data-ng-app], [custom-app]');
    };
    /**
     * A function to sort an array containing DOM elements according to their position in the DOM
     *
     * @param key Optional key value to get the
     *
     * @returns The compare function to use with array.sort(compareFunction) to order DOM elements as they would appear in the DOM
     */
    NodeUtils.prototype.compareHTMLElementsPosition = function (key) {
        return function (a, b) {
            if (key) {
                a = a[key];
                b = b[key];
            }
            if (a === b) {
                return 0;
            }
            if (!a.compareDocumentPosition) {
                // support for IE8 and below
                return a.sourceIndex - b.sourceIndex;
            }
            if (a.compareDocumentPosition(b) & 2) {
                // Note: CompareDocumentPosition returns the compared value as a bitmask that can take several values.
                // 2 represents DOCUMENT_POSITION_PRECEDING, which means that b comes before a.
                return 1;
            }
            return -1;
        };
    };
    /**
     * Method will check if the given point is over the htmlElement.
     *
     * @returns True if the given point is over the htmlElement.
     */
    NodeUtils.prototype.isPointOverElement = function (point, htmlElement) {
        var domRect = htmlElement.getBoundingClientRect();
        return (point.x >= domRect.left &&
            point.x <= domRect.right &&
            point.y >= domRect.top &&
            point.y <= domRect.bottom);
    };
    /**
     * Determines whether 2 BoundingClientRect are intersecting even partially.
     *
     * @param boundingClientRect1 size of an element and its position relative to the viewport as per {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect API}
     * @param boundingClientRect2 size of an element and its position relative to the viewport as per {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect API}
     * @returns True if there is a partial or total intersection
     */
    NodeUtils.prototype.areIntersecting = function (boundingClientRect1, boundingClientRect2) {
        return !(boundingClientRect2.left > boundingClientRect1.left + boundingClientRect1.width ||
            boundingClientRect2.left + boundingClientRect2.width < boundingClientRect1.left ||
            boundingClientRect2.top > boundingClientRect1.top + boundingClientRect1.height ||
            boundingClientRect2.top + boundingClientRect2.height < boundingClientRect1.top);
    };
    NodeUtils.prototype.injectJS = function () {
        function getInjector() {
            return $script;
        }
        return {
            getInjector: getInjector,
            execute: function (conf) {
                var _this = this;
                var srcs = conf.srcs;
                var index = conf.index;
                var callback = conf.callback;
                if (!srcs.length) {
                    callback();
                    return;
                }
                if (index === undefined) {
                    index = 0;
                }
                if (srcs[index] !== undefined) {
                    this.getInjector()(srcs[index], function () {
                        if (index + 1 < srcs.length) {
                            _this.execute({
                                srcs: srcs,
                                index: index + 1,
                                callback: callback
                            });
                        }
                        else if (typeof callback === 'function') {
                            callback();
                        }
                    });
                }
            }
        };
    };
    return NodeUtils;
}());
var nodeUtils = new NodeUtils();

var scopes = [];
var AbstractDecorator = /** @class */ (function () {
    function AbstractDecorator() {
        var _this = this;
        scopes.push(this.smarteditElementuuid);
        // only way to ensure inheritence
        var f = this.ngOnDestroy.bind(this);
        this.ngOnDestroy = function () {
            f();
            scopes.splice(scopes.indexOf(_this.smarteditElementuuid), 1);
        };
    }
    // for e2e purposes
    AbstractDecorator.getScopes = function () {
        return scopes;
    };
    Object.defineProperty(AbstractDecorator.prototype, "componentAttributes", {
        get: function () {
            if (!this._cachedCcomponentAttributes) {
                try {
                    this._cachedCcomponentAttributes = nodeUtils.collectSmarteditAttributesByElementUuid(this.smarteditElementuuid);
                }
                catch (e) {
                    // the original element may have been removed
                    console.log("AbstratcDecorator failed to find original element with uuid " + this.smarteditElementuuid);
                }
            }
            return this._cachedCcomponentAttributes;
        },
        enumerable: false,
        configurable: true
    });
    AbstractDecorator.prototype.ngOnDestroy = function () {
        // no-op
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], AbstractDecorator.prototype, "active", void 0);
    __decorate([
        core.Input('data-smartedit-element-uuid'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditElementuuid", void 0);
    __decorate([
        core.Input('data-smartedit-component-id'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditComponentId", void 0);
    __decorate([
        core.Input('data-smartedit-component-uuid'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditComponentUuid", void 0);
    __decorate([
        core.Input('data-smartedit-component-type'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditComponentType", void 0);
    __decorate([
        core.Input('data-smartedit-catalog-version-uuid'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditCatalogVersionUuid", void 0);
    __decorate([
        core.Input('data-smartedit-container-id'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditContainerId", void 0);
    __decorate([
        core.Input('data-smartedit-container-uuid'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditContainerUuid", void 0);
    __decorate([
        core.Input('data-smartedit-container-type'),
        __metadata("design:type", String)
    ], AbstractDecorator.prototype, "smarteditContainerType", void 0);
    return AbstractDecorator;
}());

/**
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit custom component from a Depencency injection standpoint.
 */
var SeCustomComponent = function () {
    return function (componentConstructor) {
        var componentName = utils.functionsUtils.getConstructorName(componentConstructor);
        /* forbiddenNameSpaces window._:false */
        var definition = window.__smartedit__.getDecoratorPayload('Component', componentConstructor);
        if (!definition) {
            throw new Error("@SeCustomComponent " + componentName + " should only be used on a @Component decorated class");
        }
        var selector = parseComponentSelector(definition.selector, componentConstructor);
        componentConstructor.selector = selector;
        seCustomComponents.unshift(componentConstructor);
        return componentConstructor;
    };
};
var parseComponentSelector = function (selector, seContructor) {
    if (!selector) {
        return window.smarteditLodash.kebabCase(diNameUtils.buildComponentName(seContructor));
    }
    else {
        return selector;
    }
};
var seCustomComponents = [];
function registerCustomComponents(injector) {
    // create a custom element for every @SeComponent flagged with custom:true
    seCustomComponents.forEach(function (constructor) {
        if (!customElements.get(constructor.selector)) {
            // Convert to a custom element.
            var customComponent = elements.createCustomElement(constructor, { injector: injector });
            // Register the custom element with the browser.
            customElements.define(constructor.selector, customComponent);
        }
    });
}

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var SeDecorator = function () {
    return function (componentConstructor) {
        var componentName = utils.functionsUtils.getConstructorName(componentConstructor);
        /* forbiddenNameSpaces window._:false */
        var definition = window.__smartedit__.getDecoratorPayload('Component', componentConstructor);
        if (!definition) {
            throw new Error("@SeDecorator " + componentName + " should only be used on a @Component decorated class");
        }
        if (definition.template && definition.template.indexOf('<ng-content') === -1) {
            throw new Error("@SeDecorator " + componentName + " should contain <ng-content> node in its template");
        }
        if (!(componentConstructor.prototype instanceof AbstractDecorator)) {
            throw new Error("@SeDecorator " + componentName + " should extend AbstractDecorator");
        }
        return SeCustomComponent()(componentConstructor);
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * **Deprecated since 2005.**
 *
 * Decorator used to compose alter original filter constuctor that will later be added to angularJS module filters.
 * @deprecated
 */
var SeFilter = function () {
    return function (filterConstructor) {
        filterConstructor.filterName = diNameUtils.buildFilterName(filterConstructor);
        return filterConstructor;
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * **Deprecated since 1905.**
 *
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit injectable service from a Dependency injection standpoint.
 * When multiple class annotations are used, [\@SeInjectable\(\)]{@link SeInjectable} must be closest to the class declaration.
 *
 * @deprecated
 */
var SeInjectable = function () {
    return function (providerConstructor) {
        return providerConstructor;
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * **Deprecated since 1905.**
 *
 * Class level typescript {@link http://www.typescriptlang.org/docs/handbook/decorators.html decorator factory}
 * used to declare a Smartedit web component from a Depencency injection standpoint.
 * The controller alias will be $ctrl.
 * Inherits properties from {@link SeDirective}.
 *
 * @deprecated
 */
var SeComponent = function (definition) {
    return function (componentConstructor) {
        definition = definition;
        var nameSet = parseDirectiveName(definition.selector, componentConstructor);
        var component = {
            controller: componentConstructor,
            controllerAs: '$ctrl',
            transclude: definition.transclude || true,
            bindings: parseDirectiveBindings(definition.inputs),
            require: definition.require
        };
        if (definition.templateUrl) {
            component.templateUrl = definition.templateUrl;
        }
        else if (definition.template) {
            component.template = definition.template;
        }
        if (nameSet.restrict !== 'E') {
            var componentName = utils.functionsUtils.getConstructorName(componentConstructor);
            throw new Error("component " + componentName + " declared a selector on class or attribute. version 1808 of Smartedit DI limits SeComponents to element selectors");
        }
        componentConstructor.componentName = nameSet.name;
        componentConstructor.definition = component;
        // will be browsed by owning @SeModule
        componentConstructor.entryComponents = definition.entryComponents;
        componentConstructor.providers = definition.providers;
        return componentConstructor;
    };
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * @ignore
 * Model containing truncated text properties.
 */
var TruncatedText = /** @class */ (function () {
    function TruncatedText(text, truncatedText, truncated, ellipsis) {
        if (text === void 0) { text = ''; }
        if (truncatedText === void 0) { truncatedText = ''; }
        if (ellipsis === void 0) { ellipsis = ''; }
        this.text = text;
        this.truncatedText = truncatedText;
        this.truncated = truncated;
        this.ellipsis = ellipsis;
        // if text/truncatedText is null, then set its value to ""
        this.text = this.text || '';
        this.truncatedText = this.truncatedText || '';
    }
    TruncatedText.prototype.getUntruncatedText = function () {
        return this.text;
    };
    TruncatedText.prototype.getTruncatedText = function () {
        return this.truncatedText + this.ellipsis;
    };
    TruncatedText.prototype.isTruncated = function () {
        return this.truncated;
    };
    return TruncatedText;
}());

/* forbiddenNameSpaces window._:false */
window.__smartedit__ = window.__smartedit__ || {};
function getDecoratorKey(className, decoratorName) {
    return className + "-" + decoratorName + ":definition";
}
lodash.merge(window.__smartedit__, {
    modules: {},
    pushedModules: [],
    smarteditDecoratorPayloads: {},
    addDecoratorPayload: function (decorator, className, payload) {
        var key = getDecoratorKey(decorator, className);
        if (window.__smartedit__.smarteditDecoratorPayloads[key]) {
            throw new Error('Duplicate class/decorator pair');
        }
        window.__smartedit__.smarteditDecoratorPayloads[key] = payload;
    },
    getDecoratorPayload: function (decorator, constructor) {
        var className = utils.functionsUtils.getConstructorName(utils.annotationService.getOriginalConstructor(constructor));
        return window.__smartedit__.smarteditDecoratorPayloads[getDecoratorKey(decorator, className)];
    },
    getComponentDecoratorPayload: function (className) {
        return window.__smartedit__.smarteditDecoratorPayloads[getDecoratorKey('Component', className)];
    },
    downgradedService: {}
});
/**
 * Add here a spread of modules containing invocations of HttpBackendService to mocks some calls to the backend
 */
window.pushModules = function () {
    var modules = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        modules[_i] = arguments[_i];
    }
    window.__smartedit__.pushedModules = window.__smartedit__.pushedModules.concat(modules);
};
/**
 * A collection of utility methods for windows.
 */
var /* @ngInject */ WindowUtils = /** @class */ (function (_super) {
    __extends(/* @ngInject */ WindowUtils, _super);
    WindowUtils.$inject = ["ngZone"];
    function /* @ngInject */ WindowUtils(ngZone) {
        var _this = _super.call(this, ngZone) || this;
        /**
         * Given the current frame, retrieves the target frame for gateway purposes
         *
         * @returns The content window or null if it does not exists.
         */
        _this.getGatewayTargetFrame = function () {
            if (_this.isIframe()) {
                return _this.getWindow().parent;
            }
            else if (_this.getWindow().document.getElementById(/* @ngInject */ WindowUtils_1.SMARTEDIT_IFRAME_ID)) {
                return _this.getWindow().document.getElementById(/* @ngInject */ WindowUtils_1.SMARTEDIT_IFRAME_ID).contentWindow;
            }
            return null;
        };
        return _this;
    }
    /* @ngInject */ WindowUtils_1 = /* @ngInject */ WindowUtils;
    /* @ngInject */ WindowUtils.prototype.getSmarteditIframe = function () {
        return document.querySelector('iframe#' + /* @ngInject */ WindowUtils_1.SMARTEDIT_IFRAME_ID);
    };
    /* @ngInject */ WindowUtils.prototype.getIframe = function () {
        return document.querySelector('iframe');
    };
    /* @ngInject */ WindowUtils.prototype.setTrustedIframeDomain = function (trustedIframeSource) {
        this.trustedIframeDomain = utils.urlUtils.getOrigin(trustedIframeSource);
    };
    WindowUtils.prototype.setTrustedIframeDomain.$inject = ["trustedIframeSource"];
    /* @ngInject */ WindowUtils.prototype.getTrustedIframeDomain = function () {
        return this.trustedIframeDomain;
    };
    /* @ngInject */ WindowUtils.prototype.isCrossOrigin = function (location) {
        return utils.urlUtils.getOrigin() !== utils.urlUtils.getOrigin(location);
    };
    WindowUtils.prototype.isCrossOrigin.$inject = ["location"];
    var /* @ngInject */ WindowUtils_1;
    /* @ngInject */ WindowUtils.SMARTEDIT_IFRAME_ID = 'ySmartEditFrame';
    /* @ngInject */ WindowUtils = /* @ngInject */ WindowUtils_1 = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [core.NgZone])
    ], /* @ngInject */ WindowUtils);
    return /* @ngInject */ WindowUtils;
}(utils.WindowUtils));
var windowUtils = new WindowUtils();

window.__smartedit__.addDecoratorPayload("Injectable", "ModuleUtils", { providedIn: 'root' });
/**
 * Internal utility service to handle ES6 modules
 *
 * @internal
 * @ignore
 */
var /* @ngInject */ ModuleUtils = /** @class */ (function (_super) {
    __extends(/* @ngInject */ ModuleUtils, _super);
    ModuleUtils.$inject = ["logService"];
    function /* @ngInject */ ModuleUtils(logService) {
        var _this = _super.call(this) || this;
        _this.logService = logService;
        return _this;
    }
    /* @ngInject */ ModuleUtils.prototype.getNgModule = function (appName) {
        if (window.__smartedit__.modules) {
            var moduleKey = Object.keys(window.__smartedit__.modules).find(function (key) {
                return key.toLowerCase().endsWith(appName.toLowerCase()) ||
                    key.toLowerCase().endsWith(appName.toLowerCase() + 'module');
            });
            if (!moduleKey) {
                return null;
            }
            return window.__smartedit__.modules[moduleKey];
        }
        return null;
    };
    ModuleUtils.prototype.getNgModule.$inject = ["appName"];
    /* @ngInject */ ModuleUtils.prototype.addModuleToAngularJSApp = function (legacyAngularModuleName, app) {
        try {
            angular$1.module(app);
            angular$1.module(legacyAngularModuleName).requires.push(app);
        }
        catch (ex) {
            this.logService.warn("Failed to load legacy AngularJS module " + app + " into " + legacyAngularModuleName + "; SmartEdit functionality may be compromised.");
        }
    };
    ModuleUtils.prototype.addModuleToAngularJSApp.$inject = ["legacyAngularModuleName", "app"];
    /* @ngInject */ ModuleUtils = __decorate([
        core.Injectable({ providedIn: 'root' }),
        __metadata("design:paramtypes", [utils.LogService])
    ], /* @ngInject */ ModuleUtils);
    return /* @ngInject */ ModuleUtils;
}(utils.ModuleUtils));
var moduleUtils = new ModuleUtils(new utils.LogService());

/**
 * A collection of utility methods for windows.
 */
var StringUtils = /** @class */ (function (_super) {
    __extends(StringUtils, _super);
    function StringUtils() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Remove breaks and space.
     */
    StringUtils.prototype.sanitizeHTML = function (text) {
        if (stringUtils.isBlank(text)) {
            return text;
        }
        return text
            .replace(/(\r\n|\n|\r)/gm, '')
            .replace(/>\s+</g, '><')
            .replace(/<\/br\>/g, '');
    };
    /**
     * Generates a unique string based on system time and a random generator.
     */
    StringUtils.prototype.generateIdentifier = function () {
        var d = new Date().getTime();
        if (window.performance && typeof window.performance.now === 'function') {
            d += window.performance.now(); // use high-precision timer if available
        }
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
        });
        return uuid;
    };
    /**
     * Creates a base-64 encoded ASCII string from the object or string.
     */
    StringUtils.prototype.getEncodedString = function (input) {
        return this.encode(input);
    };
    /**
     * **Deprecated since 2005, use {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim API}.**
     *
     * Removes spaces at the beginning and end of a given string.
     *
     * @returns Modified string without spaces at the beginning and the end
     *
     * @deprecated
     */
    StringUtils.prototype.trim = function (aString) {
        return aString.trim();
    };
    /**
     * Escapes &, <, >, " and ' characters.
     */
    StringUtils.prototype.escapeHtml = function (str) {
        if (typeof str === 'string') {
            return str
                .replace(/&/g, '&amp;')
                .replace(/>/g, '&gt;')
                .replace(/</g, '&lt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
        return str;
    };
    StringUtils.prototype.resourceLocationToRegex = function (str) {
        return new RegExp(str.replace(/\/:[^\/]*/g, '/.*'));
    };
    return StringUtils;
}(utils.StringUtils));
var stringUtils = new StringUtils();

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Collection of utility methods for handling responses from backend calls
 */
var ApiUtils = /** @class */ (function () {
    function ApiUtils() {
    }
    /**
     * When provided with a response returned from a backend call, will filter the response
     * to retrieve the data of interest.
     *
     * @returns {Array} Returns the array from the response.
     */
    ApiUtils.prototype.getDataFromResponse = function (response) {
        var dataKey = Object.keys(response).filter(function (key) {
            return response[key] instanceof Array;
        })[0];
        return response[dataKey];
    };
    /**
     * When provided with a response returned from a backend call, will filter the response
     * to retrieve the key holding the data of interest.
     *
     * @returns Returns the name of the key holding the array from the response.
     */
    ApiUtils.prototype.getKeyHoldingDataFromResponse = function (response) {
        var dataKey = Object.keys(response).filter(function (key) {
            return response[key] instanceof Array;
        })[0];
        return dataKey;
    };
    return ApiUtils;
}());
var apiUtils = new ApiUtils();

var DOMAIN_TOKEN = 'domain';
var SMARTEDITLOADER_COMPONENT_NAME = 'smarteditloader-component';
var SMARTEDITCONTAINER_COMPONENT_NAME = 'smarteditcontainer-component';
var SMARTEDIT_COMPONENT_NAME = 'smartedit-component';
var ELEMENT_UUID_ATTRIBUTE = 'data-smartedit-element-uuid';
var ID_ATTRIBUTE = 'data-smartedit-component-id';
var TYPE_ATTRIBUTE = 'data-smartedit-component-type';
var NG_ROUTE_PREFIX = 'ng';
var NG_ROUTE_WILDCARD = '**';
var EXTENDED_VIEW_PORT_MARGIN = 1000;
var CONTEXT_CATALOG = 'CURRENT_CONTEXT_CATALOG';
var CONTEXT_CATALOG_VERSION = 'CURRENT_CONTEXT_CATALOG_VERSION';
var CONTEXT_SITE_ID = 'CURRENT_CONTEXT_SITE_ID';
var PAGE_CONTEXT_CATALOG = 'CURRENT_PAGE_CONTEXT_CATALOG';
var PAGE_CONTEXT_CATALOG_VERSION = 'CURRENT_PAGE_CONTEXT_CATALOG_VERSION';
/**
 * Constant containing the name of the current page site uid placeholder in URLs
 */
var PAGE_CONTEXT_SITE_ID = 'CURRENT_PAGE_CONTEXT_SITE_ID';
var SHOW_SLOT_MENU = '_SHOW_SLOT_MENU';
var HIDE_SLOT_MENU = 'HIDE_SLOT_MENU';
var OVERLAY_DISABLED_EVENT = 'OVERLAY_DISABLED';
var DEFAULT_LANGUAGE = 'en_US';
var CLOSE_CTX_MENU = 'CLOSE_CTX_MENU';
var CTX_MENU_DROPDOWN_IS_OPEN = 'CTX_MENU_DROPDOWN_IS_OPEN';
(function (MUTATION_CHILD_TYPES) {
    MUTATION_CHILD_TYPES["ADD_OPERATION"] = "addedNodes";
    MUTATION_CHILD_TYPES["REMOVE_OPERATION"] = "removedNodes";
})(exports.MUTATION_CHILD_TYPES || (exports.MUTATION_CHILD_TYPES = {}));
/*
 * Mutation object (return in a list of mutations in mutation event) can be of different types.
 * We are here only interested in type attributes (used for onPageChanged and onComponentChanged events) and childList (used for onComponentAdded events)
 */
var MUTATION_TYPES = {
    CHILD_LIST: {
        NAME: 'childList',
        ADD_OPERATION: exports.MUTATION_CHILD_TYPES.ADD_OPERATION,
        REMOVE_OPERATION: exports.MUTATION_CHILD_TYPES.REMOVE_OPERATION
    },
    ATTRIBUTES: {
        NAME: 'attributes'
    }
};
/**
 * **Deprecated since 2105.**
 *
 * Path to fetch permissions of a given catalog version.
 *
 * @deprecated
 */
var CATALOG_VERSION_PERMISSIONS_RESOURCE_URI_CONSTANT = '/permissionswebservices/v1/permissions/catalogs/search';
var OPERATION_CONTEXT = {
    BACKGROUND_TASKS: 'Background Tasks',
    INTERACTIVE: 'Interactive',
    NON_INTERACTIVE: 'Non-Interactive',
    BATCH_OPERATIONS: 'Batch Operations',
    TOOLING: 'Tooling',
    CMS: 'CMS'
};
var I18N_RESOURCE_URI = '/smarteditwebservices/v1/i18n/translations';
/**
 * Resource URI of the WhoAmI REST service used to retrieve information on the
 * current logged-in user.
 */
var WHO_AM_I_RESOURCE_URI = '/authorizationserver/oauth/whoami';
/**
 * The default OAuth 2 client id to use during authentication.
 */
var DEFAULT_AUTHENTICATION_CLIENT_ID = 'smartedit';
var SSO_AUTHENTICATION_ENTRY_POINT = '/samlsinglesignon/saml';
var SSO_OAUTH2_AUTHENTICATION_ENTRY_POINT = '/smartedit/authenticate';
var SSO_LOGOUT_ENTRY_POINT = '/samlsinglesignon/saml/logout';
/**
 * Path of the preview ticket API
 */
var PREVIEW_RESOURCE_URI = '/previewwebservices/v1/preview';
/**
 * Regular expression identifying CMS related URIs
 */
var CMSWEBSERVICES_PATH = /\/cmssmarteditwebservices|\/cmswebservices/;
/**
 * To calculate platform domain URI, this regular expression will be used
 */
var SMARTEDIT_RESOURCE_URI_REGEXP = /^(.*)\/smartedit/;
/**
 * The name of the webapp root context
 */
var SMARTEDIT_ROOT = 'smartedit';
/**
 * The SmartEdit configuration API root
 */
var CONFIGURATION_URI = '/smartedit/configuration';
var SETTINGS_URI = '/smartedit/settings';
var EVENT_NOTIFICATION_CHANGED = 'EVENT_NOTIFICATION_CHANGED';
(function (SortDirections) {
    SortDirections["Ascending"] = "asc";
    SortDirections["Descending"] = "desc";
})(exports.SortDirections || (exports.SortDirections = {}));
var REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT = 'REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT';
var PREVIOUS_USERNAME_HASH = 'previousUsername';
var SMARTEDIT_LOGIN_DIALOG_RESOURCES = {
    topLogoURL: 'static-resources/images/SAP_R_grad.svg',
    bottomLogoURL: 'static-resources/images/best-run-sap-logo.svg'
};
var EVENT_PERSPECTIVE_CHANGED = 'EVENT_PERSPECTIVE_CHANGED';
var EVENT_PERSPECTIVE_UNLOADING = 'EVENT_PERSPECTIVE_UNLOADING';
var EVENT_PERSPECTIVE_REFRESHED = 'EVENT_PERSPECTIVE_REFRESHED';
var EVENT_PERSPECTIVE_ADDED = 'EVENT_PERSPECTIVE_ADDED';
var EVENT_PERSPECTIVE_UPDATED = 'EVENT_PERSPECTIVE_UPDATED';
var EVENT_STRICT_PREVIEW_MODE_REQUESTED = 'EVENT_STRICT_PREVIEW_MODE_REQUESTED';
var PERSPECTIVE_SELECTOR_WIDGET_KEY = 'perspectiveToolbar.perspectiveSelectorTemplate';
var EVENT_SMARTEDIT_COMPONENT_UPDATED = 'EVENT_SMARTEDIT_COMPONENT_UPDATED';
var OVERLAY_ID = 'smarteditoverlay';
var EVENT_OUTER_FRAME_CLICKED = 'EVENT_OUTER_FRAME_CLICKED';
var CATALOG_VERSION_UUID_ATTRIBUTE = 'data-smartedit-catalog-version-uuid';
var COMPONENT_CLASS = 'smartEditComponent';
var CONTAINER_ID_ATTRIBUTE = 'data-smartedit-container-id';
var CONTRACT_CHANGE_LISTENER_COMPONENT_PROCESS_STATUS = {
    PROCESS: 'processComponent',
    REMOVE: 'removeComponent',
    KEEP_VISIBLE: 'keepComponentVisible'
};
var CONTRACT_CHANGE_LISTENER_PROCESS_EVENTS = {
    PROCESS_COMPONENTS: 'contractChangeListenerProcessComponents',
    RESTART_PROCESS: 'contractChangeListenerRestartProcess'
};
var OVERLAY_RERENDERED_EVENT = 'overlayRerendered';
var SMARTEDIT_ATTRIBUTE_PREFIX = 'data-smartedit-';
var SMARTEDIT_COMPONENT_PROCESS_STATUS = 'smartEditComponentProcessStatus';
var UUID_ATTRIBUTE = 'data-smartedit-component-uuid';
var OVERLAY_COMPONENT_CLASS = 'smartEditComponentX';
var CONTENT_SLOT_TYPE = 'ContentSlot';
var CONTAINER_TYPE_ATTRIBUTE = 'data-smartedit-container-type';
var LANGUAGE_RESOURCE_URI = '/cmswebservices/v1/sites/:siteUID/languages';
var I18N_LANGUAGES_RESOURCE_URI = '/smarteditwebservices/v1/i18n/languages';
// Generic Editor
var GENERIC_EDITOR_LOADED_EVENT = 'genericEditorLoadedEvent';
var GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT = 'UnrelatedValidationMessagesEvent';
var VALIDATION_MESSAGE_TYPES = {
    VALIDATION_ERROR: 'ValidationError',
    WARNING: 'Warning'
};
var ENUM_RESOURCE_URI = '/cmswebservices/v1/enums';
// Dropdown
var DROPDOWN_IMPLEMENTATION_SUFFIX = 'DROPDOWN_IMPLEMENTATION_SUFFIX';
var LINKED_DROPDOWN = 'LinkedDropdown';
var CLICK_DROPDOWN = 'ClickDropdown';
var SITES_RESOURCE_URI = '/cmswebservices/v1/sites';
var DATE_CONSTANTS = {
    ANGULAR_FORMAT: 'short',
    MOMENT_FORMAT: 'M/D/YY h:mm A',
    MOMENT_ISO: 'YYYY-MM-DDTHH:mm:00ZZ',
    ISO: 'yyyy-MM-ddTHH:mm:00Z',
    ANGULAR_SHORT: 'M/d/yy h:mm a'
};
var CATALOG_DETAILS_COLUMNS = {
    LEFT: 'left',
    RIGHT: 'right'
};
var TYPES_RESOURCE_URI = '/cmswebservices/v1/types';
var STORE_FRONT_CONTEXT = '/storefront';
var PRODUCT_RESOURCE_API = '/cmssmarteditwebservices/v1/sites/:siteUID/products/:productUID';
var PRODUCT_LIST_RESOURCE_API = '/cmssmarteditwebservices/v1/productcatalogs/:catalogId/versions/:catalogVersion/products';
var HIDE_TOOLBAR_ITEM_CONTEXT = 'HIDE_TOOLBAR_ITEM_CONTEXT';
var SHOW_TOOLBAR_ITEM_CONTEXT = 'SHOW_TOOLBAR_ITEM_CONTEXT';
var SMARTEDIT_DRAG_AND_DROP_EVENTS = {
    DRAG_DROP_CROSS_ORIGIN_START: 'DRAG_DROP_CROSS_ORIGIN_START',
    DRAG_DROP_START: 'EVENT_DRAG_DROP_START',
    DRAG_DROP_END: 'EVENT_DRAG_DROP_END',
    TRACK_MOUSE_POSITION: 'EVENT_TRACK_MOUSE_POSITION',
    DROP_ELEMENT: 'EVENT_DROP_ELEMENT'
};
var NONE_PERSPECTIVE = 'se.none';
var ALL_PERSPECTIVE = 'se.all';
var SEND_MOUSE_POSITION_THROTTLE = 100;
var THROTTLE_SCROLLING_DELAY = 70;
var SMARTEDIT_ELEMENT_HOVERED = 'smartedit-element-hovered';
var SCROLL_AREA_CLASS = 'ySECmsScrollArea';
var SMARTEDIT_IFRAME_DRAG_AREA = 'ySmartEditFrameDragArea';
var DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME = {
    START: 'START',
    END: 'END'
};
var SMARTEDIT_IFRAME_WRAPPER_ID = '#js_iFrameWrapper';
var HEART_BEAT_TIMEOUT_THRESHOLD_MS = 10000;
var EVENT_CONTENT_CATALOG_UPDATE = 'EVENT_CONTENT_CATALOG_UPDATE';
// These two constants are only used to load new files in E2E tests. In production code they
// are completely ignored.
var SMARTEDIT_INNER_FILES = [];
var SMARTEDIT_INNER_FILES_POST = [];
var MEDIA_RESOURCE_URI = "/cmswebservices/v1/catalogs/" + CONTEXT_CATALOG + "/versions/" + CONTEXT_CATALOG_VERSION + "/media";
var MEDIA_PATH = "/cmswebservices/v1/media";
var EXPERIENCE_STORAGE_KEY = 'experience';

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Provides a list of useful methods used for date manipulation.
 */
var DateUtils = /** @class */ (function () {
    function DateUtils() {
    }
    /**
     * Formats provided dateTime as utc.
     *
     * @param dateTime Date Time to format in UTC.
     * @returns Formatted string.
     */
    DateUtils.prototype.formatDateAsUtc = function (dateTime) {
        return moment(dateTime).utc().format(DATE_CONSTANTS.MOMENT_ISO);
    };
    return DateUtils;
}());
var dateUtils = new DateUtils();

/**
 * Helper to handle competing promises
 */
var /* @ngInject */ DiscardablePromiseUtils = /** @class */ (function () {
    DiscardablePromiseUtils.$inject = ["logService"];
    function /* @ngInject */ DiscardablePromiseUtils(logService) {
        this.logService = logService;
        this._map = {};
    }
    /**
     * Selects a new promise as candidate for invoking a given callback
     * each invocation of this method for a given key discards the previously selected promise
     * @param key The string key identifying the discardable promise
     * @param promise The discardable promise instance once a new candidate is called with this method
     * @param successCallback The success callback to ultimately apply on the last promise not discarded
     * @param failureCallback The failure callback to ultimately apply on the last promise not discarded. Optional.
     */
    /* @ngInject */ DiscardablePromiseUtils.prototype.apply = function (key, promise, successCallback, failureCallback) {
        if (!this._map[key]) {
            this._map[key] = {
                promise: promise,
                successCallback: successCallback,
                failureCallback: failureCallback
            };
        }
        else {
            this.logService.debug("competing promise for key " + key);
            delete this._map[key].discardableHolder.successCallback;
            delete this._map[key].discardableHolder.failureCallback;
            this._map[key].promise = promise;
        }
        this._map[key].discardableHolder = {
            successCallback: this._map[key].successCallback,
            failureCallback: this._map[key].failureCallback
        };
        var self = this;
        var p = this._map[key].promise;
        p.then(function (response) {
            if (this.successCallback) {
                delete self._map[key];
                this.successCallback.apply(undefined, arguments);
            }
            else {
                self.logService.debug("aborted successCallback for promise identified by " + key);
            }
        }.bind(this._map[key].discardableHolder), function (error) {
            if (this.failureCallback) {
                delete self._map[key];
                this.failureCallback.apply(undefined, arguments);
            }
            else {
                self.logService.debug("aborted failureCallback for promise identified by " + key);
            }
        }.bind(this._map[key].discardableHolder));
    };
    DiscardablePromiseUtils.prototype.apply.$inject = ["key", "promise", "successCallback", "failureCallback"];
    /**
     * Removes callbacks of promise if exists.
     *
     * Used to remove any pending callbacks when a component is destroyed to prevent memory leaks.
     */
    /* @ngInject */ DiscardablePromiseUtils.prototype.clear = function (key) {
        if (this.exists(key)) {
            delete this._map[key].discardableHolder.successCallback;
            delete this._map[key].discardableHolder.failureCallback;
        }
    };
    DiscardablePromiseUtils.prototype.clear.$inject = ["key"];
    /* @ngInject */ DiscardablePromiseUtils.prototype.exists = function (key) {
        return this._map[key] ? true : false;
    };
    DiscardablePromiseUtils.prototype.exists.$inject = ["key"];
    /* @ngInject */ DiscardablePromiseUtils = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService])
    ], /* @ngInject */ DiscardablePromiseUtils);
    return /* @ngInject */ DiscardablePromiseUtils;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
(function (Errors) {
    var ParseError = /** @class */ (function () {
        function ParseError(value) {
            this.value = value;
        }
        return ParseError;
    }());
    Errors.ParseError = ParseError;
})(exports.Errors || (exports.Errors = {}));

/**
 * Provides a list of useful methods used for object manipulation
 */
var ObjectUtils = /** @class */ (function () {
    function ObjectUtils() {
        var _this = this;
        /**
         * Will check if the object is empty and will return true if each and every property of the object is empty.
         *
         * @param value the value to evaluate
         */
        this.isObjectEmptyDeep = function (value) {
            if (lodash.isObject(value)) {
                for (var key in value) {
                    if (value.hasOwnProperty(key)) {
                        if (!lodash.isEmpty(value[key])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            return lodash.isString(value) ? lodash.isEmpty(value) : lodash.isNil(value);
        };
        /**
         * Resets a given object's properties' values
         *
         * @param targetObject, the object to reset
         * @param modelObject, an object that contains the structure that targetObject should have after a reset
         * @returns The object that has been reset
         */
        this.resetObject = function (targetObject, modelObject) {
            if (!targetObject) {
                targetObject = _this.copy(modelObject);
            }
            else {
                for (var i in targetObject) {
                    if (targetObject.hasOwnProperty(i)) {
                        delete targetObject[i];
                    }
                }
                lodash.extend(targetObject, _this.copy(modelObject));
            }
            return targetObject;
        };
        /**
         * Iterates over object and allows to modify a value using callback function.
         * @param callback Callback function to apply to each object value.
         * @returns The object with modified values.
         */
        this.deepIterateOverObjectWith = function (obj, callback) {
            return lodash.reduce(obj, function (result, value, key) {
                if (lodash.isPlainObject(value)) {
                    result[key] = _this.deepIterateOverObjectWith(value, callback);
                }
                else {
                    result[key] = callback(value);
                }
                return result;
            }, {});
        };
        /**
         * Returns an object that contains list of fields and for each field it has a boolean value
         * which is true when the property was modified, added or removed, false otherwise.
         * @returns The diff object.
         */
        this.deepObjectPropertyDiff = function (firstObject, secondObject) {
            function CHANGED_PROPERTY() { }
            function NON_CHANGED_PROPERTY() { }
            var mergedObj = lodash.mergeWith(lodash.cloneDeep(firstObject), secondObject, function (prValue, cpValue) {
                if (!lodash.isPlainObject(prValue)) {
                    return !lodash.isEqual(prValue, cpValue) ? CHANGED_PROPERTY : NON_CHANGED_PROPERTY;
                }
                // Note: Previous versions of lodash could work with null, but the latest version of lodash requires
                // undefined to be returned.
                return undefined;
            });
            // If the field is not CHANGED_PROPERTY/NON_CHANGED_PROPERTY then it was removed or added.
            var sanitizedObj = _this.deepIterateOverObjectWith(mergedObj, function (value) {
                if (value !== CHANGED_PROPERTY && value !== NON_CHANGED_PROPERTY) {
                    return CHANGED_PROPERTY;
                }
                else {
                    return value;
                }
            });
            // If it's CHANGED_PROPERTY return true otherwise false.
            return _this.deepIterateOverObjectWith(sanitizedObj, function (value) {
                return value === CHANGED_PROPERTY ? true : false;
            });
        };
        this.readObjectStructure = function (json, recursiveCount) {
            if (recursiveCount === void 0) { recursiveCount = 0; }
            if (recursiveCount > 25) {
                return _this.getClassName(json);
            }
            if (json === undefined || json === null || json.then) {
                return json;
            }
            if (typeof json === 'function') {
                return 'FUNCTION';
            }
            else if (typeof json === 'number') {
                return 'NUMBER';
            }
            else if (typeof json === 'string') {
                return 'STRING';
            }
            else if (typeof json === 'boolean') {
                return 'BOOLEAN';
            }
            else if (lodash.isElement(json)) {
                return 'ELEMENT';
            }
            else if (json.hasOwnProperty && json.hasOwnProperty('length')) {
                // jquery or Array
                if (json.forEach) {
                    var arr_1 = [];
                    json.forEach(function (arrayElement) {
                        recursiveCount++;
                        arr_1.push(_this.readObjectStructure(arrayElement, recursiveCount));
                    });
                    return arr_1;
                }
                else {
                    return 'JQUERY';
                }
            }
            else if (json.constructor &&
                json.constructor.name &&
                json.constructor.name !== 'Object') {
                return json.constructor.name;
            }
            else {
                // JSON
                var clone_1 = {};
                Object.keys(json).forEach(function (directKey) {
                    if (!directKey.startsWith('$')) {
                        recursiveCount++;
                        clone_1[directKey] = _this.readObjectStructure(json[directKey], recursiveCount);
                    }
                });
                return clone_1;
            }
        };
    }
    /**
     * Creates a deep copy of the given input object.
     * If an object being stringified has a property named toJSON whose value is a function, then the toJSON() method customizes JSON stringification behavior: instead of the object being serialized, the value returned by the toJSON() method when called will be serialized.
     *
     * @param candidate the javaScript value that needs to be deep copied.
     *
     * @returns A deep copy of the input
     */
    ObjectUtils.prototype.copy = function (candidate) {
        return JSON.parse(JSON.stringify(candidate));
    };
    /**
     * Merges the contents of two objects together into the first object.
     *
     * **Note:** This method mutates `object`.
     *
     * @returns A new object as a result of merge
     */
    ObjectUtils.prototype.merge = function (target, source) {
        return Object.assign(target, source);
    };
    /**
     * Converts the given object to array.
     * The output array elements are an object that has a key and value,
     * where key is the original key and value is the original object.
     */
    ObjectUtils.prototype.convertToArray = function (object) {
        var configuration = [];
        for (var key in object) {
            if (!key.startsWith('$') && !key.startsWith('toJSON')) {
                configuration.push({
                    key: key,
                    value: object[key]
                });
            }
        }
        return configuration;
    };
    /**
     * Returns the first Array argument supplemented with new entries from the second Array argument.
     *
     * **Note:** This method mutates `array1`.
     */
    ObjectUtils.prototype.uniqueArray = function (array1, array2) {
        var set = new Set(array1);
        array2.forEach(function (instance) {
            if (!set.has(instance)) {
                array1.push(instance);
            }
        });
        return array1;
    };
    /**
     * Checks if `value` is a function.
     */
    ObjectUtils.prototype.isFunction = function (value) {
        return typeof value === 'function';
    };
    /**
     * Checks if the value is the ECMAScript language type of Object
     */
    ObjectUtils.prototype.isObject = function (value) {
        var objectTypes = {
            boolean: false,
            function: true,
            object: true,
            number: false,
            string: false,
            undefined: false
        };
        return !!(value && objectTypes[typeof value]);
    };
    ObjectUtils.prototype.isTypedMap = function (value) {
        return value && this.isObject(value) && value.constructor === Object;
    };
    /**
     * Sorts an array of strings or objects in specified order.
     * String of numbers are treated the same way as numbers.
     * For an array of objects, `prop` argument is required.
     *
     * @param array Array to sort
     * @param prop Property on which comparision is based. Required for an array of objects.
     * @param reverse Specify ascending or descending order
     *
     * @returns The new sorted array
     */
    ObjectUtils.prototype.sortBy = function (array, prop, reverse) {
        var _this = this;
        if (reverse === void 0) { reverse = false; }
        var targetArray = __spreadArrays(array);
        var descending = reverse ? -1 : 1;
        targetArray.sort(function (a, b) {
            var aVal = _this.isTypedMap(a) ? a[prop] : a;
            var bVal = _this.isTypedMap(b) ? b[prop] : b;
            var result = String(aVal).localeCompare(String(bVal), undefined, {
                numeric: true,
                sensitivity: 'base'
            });
            return result * descending;
        });
        return targetArray;
    };
    /** @internal */
    ObjectUtils.prototype.getClassName = function (instance) {
        return instance &&
            instance.constructor &&
            instance.constructor.name &&
            instance.constructor.name !== 'Object'
            ? instance.constructor.name
            : null;
    };
    return ObjectUtils;
}());
var objectUtils = new ObjectUtils();

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ScriptUtils = /** @class */ (function () {
    function ScriptUtils() {
    }
    ScriptUtils.prototype.injectJS = function () {
        function getInjector() {
            return $script;
        }
        return {
            getInjector: getInjector,
            execute: function (conf) {
                var _this = this;
                var srcs = conf.srcs;
                var index = conf.index;
                var callback = conf.callback;
                if (!srcs.length) {
                    callback();
                    return;
                }
                if (index === undefined) {
                    index = 0;
                }
                if (srcs[index] !== undefined) {
                    this.getInjector()(srcs[index], function () {
                        if (index + 1 < srcs.length) {
                            _this.execute({
                                srcs: srcs,
                                index: index + 1,
                                callback: callback
                            });
                        }
                        else if (typeof callback === 'function') {
                            callback();
                        }
                    });
                }
            }
        };
    };
    return ScriptUtils;
}());
var scriptUtils = new ScriptUtils();

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Provides a list of useful functions that can be used as part of the SmartEdit framework.
 */
var /* @ngInject */ FunctionsModule = /** @class */ (function () {
    function /* @ngInject */ FunctionsModule() {
    }
    /* @ngInject */ FunctionsModule = __decorate([
        SeModule({
            providers: [
                utils.BooleanUtils,
                utils.CloneableUtils,
                utils.UrlUtils,
                utils.CryptographicUtils,
                utils.FunctionsUtils,
                utils.LogService,
                ModuleUtils,
                NodeUtils,
                utils.PromiseUtils,
                StringUtils,
                DiscardablePromiseUtils,
                {
                    provide: 'ParseError',
                    useFactory: function () { return exports.Errors.ParseError; }
                },
                /**
                 * **Deprecated since 2005, use `import { urlUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getAbsoluteURL',
                    useFactory: function () { return utils.urlUtils.getAbsoluteURL; }
                },
                /**
                 * **Deprecated since 2005, use `import { urlUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getOrigin',
                    useFactory: function () { return utils.urlUtils.getOrigin; }
                },
                /**
                 * **Deprecated since 1905, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isBlank',
                    useFactory: function () { return stringUtils.isBlank; }
                },
                /**
                 * Pprovides a convenience to either default a new child or "extend" an existing child with the prototype of the parent
                 *
                 * @param ParentClass which has a prototype you wish to extend.
                 * @param ChildClass will have its prototype set.
                 *
                 * @returns ChildClass which has been extended
                 */
                {
                    provide: 'extend',
                    useFactory: function () { return function (ParentClass, ChildClass) {
                        if (!ChildClass) {
                            ChildClass = function () {
                                return;
                            };
                        }
                        ChildClass.prototype = Object.create(ParentClass.prototype);
                        return ChildClass;
                    }; }
                },
                /**
                 * Will call the javascrit's native setTimeout method to execute a given function after a specified period of time.
                 * This method is better than using $timeout since it is difficult to assert on $timeout during end-to-end testing.
                 *
                 * @param func function that needs to be executed after the specified duration.
                 * @param duration time in milliseconds.
                 */
                {
                    provide: 'customTimeout',
                    useFactory: function () { return function (func, duration) {
                        setTimeout(function () {
                            func();
                        }, duration);
                    }; }
                },
                /**
                 * **Deprecated since 1905, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'copy',
                    useFactory: function () { return objectUtils.copy; }
                },
                /**
                 * **Deprecated since 1905, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'merge',
                    useFactory: function () { return objectUtils.merge; }
                },
                /**
                 * **Deprecated since 1905, use `import { urlUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getQueryString',
                    useFactory: function () { return utils.urlUtils.getQueryString; }
                },
                /**
                 * **Deprecated since 1905, use `import { urlUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getURI',
                    useFactory: function () { return utils.urlUtils.getURI; }
                },
                /**
                 * **Deprecated since 1905, use `import { urlUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'parseQuery',
                    useFactory: function () { return utils.urlUtils.parseQuery; }
                },
                /**
                 * **Deprecated since 2005, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'trim',
                    useFactory: function () { return stringUtils.trim; }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'convertToArray',
                    useFactory: function () { return objectUtils.convertToArray; }
                },
                /**
                 * **Deprecated since 2005, use `import { scriptUtils } from 'smarteditcommons'`.**
                 *
                 * Inject script tags into html for a given set of sources.
                 *
                 * @deprecated
                 */
                {
                    provide: 'injectJS',
                    useFactory: function () { return scriptUtils.injectJS(); }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * Returns the first Array argument supplemented with new entries from the second Array argument.
                 *
                 * @deprecated
                 */
                {
                    provide: 'uniqueArray',
                    useFactory: function () { return objectUtils.uniqueArray; }
                },
                /**
                 * **Deprecated since 1811, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * Converts a given pattern into a regular expression.
                 * This method will prepend and append a string with ^ and $ respectively replaces
                 * and wildcards (*) by proper regex wildcards.
                 *
                 * @param pattern Any string that needs to be converted to a regular expression.
                 *
                 * @returns A regular expression generated from the given string.
                 *
                 * @deprecated
                 */
                {
                    provide: 'regExpFactory',
                    useFactory: function () { return stringUtils.regExpFactory; }
                },
                /**
                 * **Deprecated since 2005, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * <b>generateIdentifier</b> will generate a unique string based on system time and a random generator.
                 * @returns a unique identifier.
                 *
                 * @deprecated
                 */
                {
                    provide: 'generateIdentifier',
                    useFactory: function () { return stringUtils.generateIdentifier; }
                },
                /**
                 * **Deprecated since 2005, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * <b>escapeHtml</b> will escape &, <, >, " and ' characters .
                 *
                 * @param str A string that needs to be escaped.
                 * @returns The escaped string.
                 *
                 * @deprecated
                 *
                 */
                {
                    provide: 'escapeHtml',
                    useFactory: function () { return stringUtils.escapeHtml; }
                },
                /**
                 * **Deprecated since 1905, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * <b>escapes any harmful scripting from a string, leaves innocuous HTML untouched/b>
                 * @param str A string that needs to be sanitized.
                 * @returns the sanitized string.
                 *
                 * @deprecated
                 */
                {
                    provide: 'sanitize',
                    useFactory: function () { return stringUtils.sanitize; }
                },
                /**
                 * **Deprecated since 1905, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * <b>sanitizeHTML</b> will remove breaks and space .
                 *
                 * @param text A string that needs to be escaped.
                 * @returns the sanitized HTML.
                 *
                 * @deprecated
                 */
                {
                    provide: 'sanitizeHTML',
                    useFactory: function () { return stringUtils.sanitizeHTML; }
                },
                /**
                 * <b>toPromise</> transforms a function into a function that is guaranteed to return a Promise that resolves to the
                 * original return value of the function, rejects with the rejected return value and rejects with an exception object when the invocation fails
                 */
                {
                    provide: 'toPromise',
                    useFactory: function ($q, $log) { return function (method, context) {
                        return function () {
                            try {
                                return $q.when(method.apply(context, arguments));
                            }
                            catch (e) {
                                $log.error('execution of a method that was turned into a promise failed');
                                $log.error(e);
                                return $q.reject(e);
                            }
                        };
                    }; },
                    deps: ['$q', '$log']
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * Returns `true` if the `value` is a function, else `false`.
                 *
                 * @deprecated
                 */
                {
                    provide: 'isFunction',
                    useFactory: function () { return objectUtils.isFunction; }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * Checks if the value is the ECMAScript language type of Object.
                 *
                 * @deprecated
                 */
                {
                    provide: 'isObject',
                    useFactory: function () { return objectUtils.isObject; }
                },
                {
                    provide: 'debounce',
                    useFactory: function (isFunction, isObject) {
                        var TypeError = /** @class */ (function () {
                            function TypeError() {
                            }
                            return TypeError;
                        }());
                        return function (func, wait, options) {
                            var args;
                            var maxTimeoutId;
                            var result;
                            var stamp;
                            var thisArg;
                            var timeoutId;
                            var trailingCall;
                            var leading;
                            var lastCalled = 0;
                            var maxWait = false;
                            var trailing = true;
                            var isCalled;
                            if (!isFunction(func)) {
                                throw new TypeError();
                            }
                            wait = Math.max(0, wait) || 0;
                            if (options === true) {
                                leading = true;
                                trailing = false;
                            }
                            else if (isObject(options)) {
                                leading = options.leading;
                                maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
                                trailing = 'trailing' in options ? options.trailing : trailing;
                            }
                            var delayed = function () {
                                var remaining = wait - (Date.now() - stamp);
                                if (remaining <= 0) {
                                    if (maxTimeoutId) {
                                        clearTimeout(maxTimeoutId);
                                    }
                                    isCalled = trailingCall;
                                    maxTimeoutId = timeoutId = trailingCall = undefined;
                                    if (isCalled) {
                                        lastCalled = Date.now();
                                        result = func.apply(thisArg, args);
                                        if (!timeoutId && !maxTimeoutId) {
                                            args = thisArg = null;
                                        }
                                    }
                                }
                                else {
                                    timeoutId = setTimeout(delayed, remaining);
                                }
                            };
                            var maxDelayed = function () {
                                if (timeoutId) {
                                    clearTimeout(timeoutId);
                                }
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (trailing || maxWait !== wait) {
                                    lastCalled = Date.now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            };
                            return function () {
                                args = arguments;
                                stamp = Date.now();
                                thisArg = this;
                                trailingCall = trailing && (timeoutId || !leading);
                                var leadingCall;
                                if (maxWait === false) {
                                    leadingCall = leading && !timeoutId;
                                }
                                else {
                                    if (!maxTimeoutId && !leading) {
                                        lastCalled = stamp;
                                    }
                                    var remaining = maxWait - (stamp - lastCalled);
                                    isCalled = remaining <= 0;
                                    if (isCalled) {
                                        if (maxTimeoutId) {
                                            maxTimeoutId = clearTimeout(maxTimeoutId);
                                        }
                                        lastCalled = stamp;
                                        result = func.apply(thisArg, args);
                                    }
                                    else if (!maxTimeoutId) {
                                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                                    }
                                }
                                if (isCalled && timeoutId) {
                                    timeoutId = clearTimeout(timeoutId);
                                }
                                else if (!timeoutId && wait !== maxWait) {
                                    timeoutId = setTimeout(delayed, wait);
                                }
                                if (leadingCall) {
                                    isCalled = true;
                                    result = func.apply(thisArg, args);
                                }
                                if (isCalled && !timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                                return result;
                            };
                        };
                    },
                    deps: ['isFunction', 'isObject']
                },
                {
                    provide: 'throttle',
                    useFactory: function (debounce, isFunction, isObject) {
                        return function (func, wait, options) {
                            var leading = true;
                            var trailing = true;
                            if (!isFunction(func)) {
                                throw new TypeError();
                            }
                            if (options === false) {
                                leading = false;
                            }
                            else if (isObject(options)) {
                                leading = 'leading' in options ? options.leading : leading;
                                trailing = 'trailing' in options ? options.trailing : trailing;
                            }
                            options = {};
                            options.leading = leading;
                            options.maxWait = wait;
                            options.trailing = trailing;
                            return debounce(func, wait, options);
                        };
                    },
                    deps: ['debounce', 'isFunction', 'isObject']
                },
                /**
                 * **Deprecated since 2005, use `@Inject(YJQUERY_TOKEN) private yjQuery: JQueryStatic`.**
                 *
                 * Parses a string HTML into a queriable DOM object, stripping any JavaScript from the HTML.
                 *
                 * @param stringHTML The string representation of the HTML to parse
                 *
                 * @deprecated
                 */
                {
                    provide: 'parseHTML',
                    useFactory: function (yjQuery) {
                        return function (stringHTML) {
                            return yjQuery.parseHTML(stringHTML);
                        };
                    },
                    deps: ['yjQuery']
                },
                /**
                 * **Deprecated since 2005, use [unsafeParseHTML]{@link JQueryUtilsService#unsafeParseHTML}.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'unsafeParseHTML',
                    useFactory: function (jQueryUtilsService) {
                        return jQueryUtilsService.unsafeParseHTML;
                    },
                    deps: ['jQueryUtilsService']
                },
                /**
                 * **Deprecated since 2005, use [extractFromElement]{@link JQueryUtilsService#extractFromElement}.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'extractFromElement',
                    useFactory: function (jQueryUtilsService) {
                        return jQueryUtilsService.extractFromElement;
                    },
                    deps: ['jQueryUtilsService']
                },
                /**
                 * **Deprecated since 2005.**
                 *
                 * Close any open modal window when a user clicks browser back button
                 *
                 * @param $uibModalStack The $modalStack service of angular-ui.
                 *
                 * @deprecated
                 */
                {
                    provide: 'closeOpenModalsOnBrowserBack',
                    useFactory: function ($uibModalStack) {
                        return function () {
                            if ($uibModalStack.getTop()) {
                                $uibModalStack.dismissAll();
                            }
                        };
                    },
                    deps: ['$uibModalStack']
                },
                /**
                 * **Deprecated since 1905, use `import { URIBuilder } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'URIBuilder',
                    useFactory: function () { return utils.URIBuilder; }
                },
                /**
                 * **Deprecated since 2005, use `import { apiUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getDataFromResponse',
                    useFactory: function () { return apiUtils.getDataFromResponse; }
                },
                /**
                 * **Deprecated since 2005, use `import { apiUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getKeyHoldingDataFromResponse',
                    useFactory: function () { return apiUtils.getKeyHoldingDataFromResponse; }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'resetObject',
                    useFactory: function () { return objectUtils.resetObject; }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isObjectEmptyDeep',
                    useFactory: function () { return objectUtils.isObjectEmptyDeep; }
                },
                /**
                 * **Deprecated since 1905, use `import { booleanUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'areAllTruthy',
                    useFactory: function () { return utils.booleanUtils.areAllTruthy; }
                },
                /**
                 * **Deprecated since 1905, use `import { booleanUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isAnyTruthy',
                    useFactory: function () { return utils.booleanUtils.isAnyTruthy; }
                },
                /**
                 * **Deprecated since 2005, use `import { dateUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'formatDateAsUtc',
                    useFactory: function () { return dateUtils.formatDateAsUtc; }
                },
                /**
                 * **Deprecated since 2005, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'getEncodedString',
                    useFactory: function () { return stringUtils.encode; }
                },
                /**
                 * **Deprecated since 1905, use `import { stringUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'encode',
                    useFactory: function () { return stringUtils.encode; }
                },
                /**
                 * **Deprecated since 2005, use `import { nodeUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'compareHTMLElementsPosition',
                    useFactory: function () { return nodeUtils.compareHTMLElementsPosition; }
                },
                /**
                 * **Deprecated since 1905, use `import { windowUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isIframe',
                    useFactory: function () { return windowUtils.isIframe; }
                },
                /**
                 * **Deprecated since 2005, use `import { nodeUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isPointOverElement',
                    useFactory: function () { return nodeUtils.isPointOverElement; }
                },
                /**
                 * **Deprecated since 2005, use `import { nodeUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'areIntersecting',
                    useFactory: function () { return nodeUtils.areIntersecting; }
                },
                {
                    provide: 'EXTENDED_VIEW_PORT_MARGIN',
                    useValue: EXTENDED_VIEW_PORT_MARGIN
                },
                /**
                 * **Deprecated since 2005, use [isInExtendedViewPort]{@link JQueryUtilsService#isInExtendedViewPort}.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isInExtendedViewPort',
                    useFactory: function (jQueryUtilsService) {
                        return jQueryUtilsService.isInExtendedViewPort;
                    },
                    deps: ['jQueryUtilsService']
                },
                {
                    provide: 'deepIterateOverObjectWith',
                    useFactory: function () { return objectUtils.deepIterateOverObjectWith; }
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'deepObjectPropertyDiff',
                    useFactory: function () { return objectUtils.deepObjectPropertyDiff; }
                },
                /**
                 * **Deprecated since 2005.**
                 *
                 * @deprecated
                 */
                {
                    provide: 'isInDOM',
                    useFactory: function ($document, yjQuery) {
                        return function (component) {
                            return yjQuery.contains($document[0], component);
                        };
                    },
                    deps: ['$document', 'yjQuery']
                },
                /**
                 * **Deprecated since 2005, use `import { objectUtils } from 'smarteditcommons'`.**
                 * `objectUtils.readObjectStructure`
                 *
                 * @deprecated
                 */
                {
                    provide: 'readObjectStructureFactory',
                    useValue: function () { return objectUtils.readObjectStructure; }
                }
            ]
        })
    ], /* @ngInject */ FunctionsModule);
    return /* @ngInject */ FunctionsModule;
}());

var SmarteditErrorHandler = /** @class */ (function (_super) {
    __extends(SmarteditErrorHandler, _super);
    function SmarteditErrorHandler() {
        var _this = _super.call(this) || this;
        _this.ignorePatterns = [
            /Uncaught[\s]*\(in[\s]*promise\)/,
            /Unhandled[\s]*Promise[\s]*rejection/
        ];
        return _this;
    }
    SmarteditErrorHandler.prototype.handleError = function (error) {
        if (process.env.NODE_ENV !== 'production') {
            _super.prototype.handleError.call(this, error);
            return;
        }
        /*
         * original exception occuring in a promise based API won't show here
         * the catch set in ES6 promise decoration is necessary to log them
         */
        var message = error && error.message ? error.message : error;
        if (message && this.ignorePatterns.some(function (pattern) { return pattern.test(message.toString()); })) {
            return;
        }
        if (error instanceof http.HttpErrorResponse && error.status === 401) {
            return;
        }
        _super.prototype.handleError.call(this, error);
    };
    return SmarteditErrorHandler;
}(core.ErrorHandler));

function objectToArray(obj) {
    return Object.keys(obj).reduce(function (acc, key) { return __spreadArrays((acc || []), [{ key: key, value: obj[key] }]); }, []);
}

/*
 * Abstract Class to create Custom Web Elements aimed at triggering some legacy AngularJS compilation
 * this class takes care of the following boilerplate:
 * - preventing enless recompilation due to AngularJS compilation modifying DOM hence retriggering custom web element processing.
 * - destroying the scope upon disconnection
 * - checking necessary conditions before triggering native custom element callbacks
 */
var AbstractAngularJSBasedCustomElement = /** @class */ (function (_super) {
    __extends(AbstractAngularJSBasedCustomElement, _super);
    function AbstractAngularJSBasedCustomElement(upgrade) {
        var _this = _super.call(this) || this;
        _this.upgrade = upgrade;
        _this.PROCESSED_ATTRIBUTE_NAME = 'processed';
        return _this;
    }
    // we need to protect against a stack overflow: custom elements -> $compile -> custom elements
    AbstractAngularJSBasedCustomElement.prototype.markAsProcessed = function () {
        this.setAttribute(this.PROCESSED_ATTRIBUTE_NAME, 'true');
    };
    AbstractAngularJSBasedCustomElement.prototype.connectedCallback = function () {
        if (!this.isConnected || this.getAttribute(this.PROCESSED_ATTRIBUTE_NAME)) {
            return;
        }
        this.internalConnectedCallback();
    };
    AbstractAngularJSBasedCustomElement.prototype.disconnectedCallback = function () {
        if (!this.scope || this.isConnected) {
            return;
        }
        this.scope.$destroy();
        this.internalDisconnectedCallback && this.internalDisconnectedCallback();
    };
    AbstractAngularJSBasedCustomElement.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
        /*
         * attributes don't change in the case of decorators:
         * - they come from the shallow clone itself
         * - only active flag changes but because of the full rewrapping it goes through constructor
         */
        if (!this.shouldReactOnAttributeChange()) {
            return;
        }
        this.internalAttributeChangedCallback(name, oldValue, newValue);
    };
    AbstractAngularJSBasedCustomElement.prototype.shouldReactOnAttributeChange = function () {
        return (this.internalAttributeChangedCallback &&
            this.scope &&
            this.isConnected &&
            !!this.getAttribute(this.PROCESSED_ATTRIBUTE_NAME));
    };
    Object.defineProperty(AbstractAngularJSBasedCustomElement.prototype, "$rootScope", {
        get: function () {
            return this.upgrade.injector.get('$rootScope');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractAngularJSBasedCustomElement.prototype, "$compile", {
        get: function () {
            return this.upgrade.injector.get('$compile');
        },
        enumerable: false,
        configurable: true
    });
    return AbstractAngularJSBasedCustomElement;
}(HTMLElement));

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var EXTENDED_VIEW_PORT_MARGIN_TOKEN = new core.InjectionToken('EXTENDED_VIEW_PORT_MARGIN');
var HEART_BEAT_TIMEOUT_THRESHOLD_MS_TOKEN = new core.InjectionToken('HEART_BEAT_TIMEOUT_THRESHOLD_MS');

/**
 * Used to transmit events synchronously or asynchronously. It is supported by the SmartEdit [gatewayFactory]{@link GatewayFactory} to propagate events between SmartEditContainer and SmartEdit.
 * It also contains options to publish events, as well as subscribe the event handlers.
 */
var /* @ngInject */ SystemEventService = /** @class */ (function () {
    SystemEventService.$inject = ["logService", "promiseUtils"];
    function /* @ngInject */ SystemEventService(logService, promiseUtils) {
        this.logService = logService;
        this.promiseUtils = promiseUtils;
        this._eventHandlers = {};
    }
    /**
     * Send the event with data synchronously.
     *
     * @returns A promise with resolved data of last subscriber or with the rejected error reason
     */
    /* @ngInject */ SystemEventService.prototype.publish = function (eventId, data) {
        if (!eventId) {
            this.logService.error('Failed to send event. No event ID provided for data: ' + data);
        }
        else {
            if (this._eventHandlers[eventId] && this._eventHandlers[eventId].length > 0) {
                return this._invokeEventHandlers(eventId, data);
            }
        }
        return Promise.resolve();
    };
    SystemEventService.prototype.publish.$inject = ["eventId", "data"];
    /**
     * Send the event with data asynchronously.
     */
    /* @ngInject */ SystemEventService.prototype.publishAsync = function (eventId, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                _this.publish(eventId, data).then(function (resolvedData) { return resolve(resolvedData); }, function (reason) { return reject(reason); });
            }, 0);
        });
    };
    SystemEventService.prototype.publishAsync.$inject = ["eventId", "data"];
    /**
     * Method to subscribe the event handler given the eventId and handler
     *
     * @param handler The event handler, a callback function which can either return a promise or directly a value.
     *
     * @returns Function to unsubscribe the event handler
     */
    /* @ngInject */ SystemEventService.prototype.subscribe = function (eventId, handler) {
        var _this = this;
        var unsubscribeFn;
        if (!eventId || !handler) {
            this.logService.error('Failed to subscribe event handler for event: ' + eventId);
        }
        else {
            // create handlers array for this event if not already created
            if (this._eventHandlers[eventId] === undefined) {
                this._eventHandlers[eventId] = [];
            }
            this._eventHandlers[eventId].push(handler);
            unsubscribeFn = function () {
                _this._unsubscribe(eventId, handler);
            };
        }
        return unsubscribeFn;
    };
    SystemEventService.prototype.subscribe.$inject = ["eventId", "handler"];
    /**
     * @internal
     */
    /* @ngInject */ SystemEventService.prototype._unsubscribe = function (eventId, handler) {
        var handlersArray = this._eventHandlers[eventId];
        var index = handlersArray ? this._eventHandlers[eventId].indexOf(handler) : -1;
        if (index >= 0) {
            this._eventHandlers[eventId].splice(index, 1);
        }
        else {
            this.logService.warn('Attempting to remove event handler for ' + eventId + ' but handler not found.');
        }
    };
    SystemEventService.prototype._unsubscribe.$inject = ["eventId", "handler"];
    /**
     * @internal
     */
    /* @ngInject */ SystemEventService.prototype._invokeEventHandlers = function (eventId, data) {
        var _this = this;
        return Promise.all(this._eventHandlers[eventId].map(function (eventHandler) {
            var promiseClosure = _this.promiseUtils.toPromise(eventHandler);
            return promiseClosure(eventId, data);
        })).then(function (results) { return Promise.resolve(results.pop()); }, function (reason) { return Promise.reject(reason); });
    };
    SystemEventService.prototype._invokeEventHandlers.$inject = ["eventId", "data"];
    /* @ngInject */ SystemEventService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService, utils.PromiseUtils])
    ], /* @ngInject */ SystemEventService);
    return /* @ngInject */ SystemEventService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * The Message Gateway is a private channel that is used to publish and subscribe to events across iFrame
 * boundaries. The gateway uses the W3C-compliant postMessage as its underlying technology. The benefits of
 * the postMessage are that:
 *
 *      <ul>
 *          <li>It works in cross-origin scenarios.</li>
 *          <li>The receiving end can reject messages based on their origins.</li>
 *      </ul>
 *
 * The creation of instances is controlled by the {@link GatewayFactory}.
 * Only one instance can exist for each gateway ID.
 *
 */
var MessageGateway = /** @class */ (function () {
    /**
     * @param gatewayId The channel identifier
     */
    function MessageGateway(logService, systemEventService, cloneableUtils, windowUtils, promiseUtils, TIMEOUT_TO_RETRY_PUBLISHING, gatewayId) {
        this.logService = logService;
        this.systemEventService = systemEventService;
        this.cloneableUtils = cloneableUtils;
        this.windowUtils = windowUtils;
        this.promiseUtils = promiseUtils;
        this.TIMEOUT_TO_RETRY_PUBLISHING = TIMEOUT_TO_RETRY_PUBLISHING;
        this.gatewayId = gatewayId;
        this.PROMISE_ACKNOWLEDGEMENT_EVENT_ID = 'promiseAcknowledgement';
        this.PROMISE_RETURN_EVENT_ID = 'promiseReturn';
        this.SUCCESS = 'success';
        this.FAILURE = 'failure';
        this.MAX_RETRIES = 5;
        this.promisesToResolve = {};
    }
    /**
     * Publishes a message across the gateway using the postMessage.
     *
     * The gateway's publish method implements promises, which are an AngularJS implementation. To resolve a
     * publish promise, all listener promises on the side of the channel must resolve. If a failure occurs in the
     * chain, the chain is interrupted and the publish promise is rejected.
     *
     * @param data Message payload
     * @param retries The current number of attempts to publish a message. By default it is 0.
     * @param pk An optional parameter. It is a primary key for the event, which is generated after
     * the first attempt to send a message.
     */
    MessageGateway.prototype.publish = function (eventId, _data, retries, pk) {
        var _this = this;
        if (retries === void 0) { retries = 0; }
        if (!eventId) {
            return Promise.reject("MessageGateway: Failed to send event. No event ID provided for _data: " + _data);
        }
        var data = this.cloneableUtils.makeCloneable(_data);
        if (!lodash.isEqual(data, _data)) {
            this.logService.debug("MessageGateway.publish - Non cloneable payload has been sanitized for gateway " + this.gatewayId + ", event " + eventId + ":", data);
        }
        var deferred = this.promisesToResolve[pk] ||
            this.promiseUtils.defer();
        try {
            var target = this.windowUtils.getGatewayTargetFrame();
            if (!target) {
                deferred.reject('It is standalone. There is no iframe');
                return deferred.promise;
            }
            pk = pk || this._generateIdentifier();
            try {
                target.postMessage({
                    pk: pk,
                    gatewayId: this.gatewayId,
                    eventId: eventId,
                    data: data
                }, '*');
            }
            catch (e) {
                this.logService.error(e);
                this.logService.error("MessageGateway.publish - postMessage has failed for gateway " + this.gatewayId + " event " + eventId + " and data ", data);
            }
            this.promisesToResolve[pk] = deferred;
            // in case promise does not return because, say, a non ready frame
            this._setTimeout(function () {
                if (!deferred.acknowledged &&
                    eventId !== _this.PROMISE_RETURN_EVENT_ID &&
                    eventId !== _this.PROMISE_ACKNOWLEDGEMENT_EVENT_ID) {
                    // still pending
                    if (retries < _this.MAX_RETRIES) {
                        _this.logService.debug(document.location.href + " is retrying to publish event " + eventId);
                        _this.publish(eventId, data, ++retries, pk).catch(function (reason) {
                            //
                        });
                    }
                    else {
                        var error = "MessageGateway.publish - Not able to publish event " + eventId + " after max retries for gateway " + _this.gatewayId + " and data";
                        deferred.reject({ error: error, data: data });
                    }
                }
            }, this.TIMEOUT_TO_RETRY_PUBLISHING);
        }
        catch (e) {
            deferred.reject();
        }
        return deferred.promise;
    };
    /**
     * Registers a given callback function to the given event ID.
     *
     * @param callback Callback function to be invoked
     * @returns The function to call in order to unsubscribe the event listening
     */
    MessageGateway.prototype.subscribe = function (eventId, callback) {
        var unsubscribeFn;
        if (!eventId) {
            this.logService.error('MessageGateway: Failed to subscribe event handler for event: ' + eventId);
        }
        else {
            var systemEventId = this._getSystemEventId(eventId);
            unsubscribeFn = this.systemEventService.subscribe(systemEventId, callback);
        }
        return unsubscribeFn;
    };
    MessageGateway.prototype.processEvent = function (event) {
        var _this = this;
        var eventData = event.data;
        if (event.eventId !== this.PROMISE_RETURN_EVENT_ID &&
            event.eventId !== this.PROMISE_ACKNOWLEDGEMENT_EVENT_ID) {
            this.logService.debug(document.location.href, 'sending acknowledgement for', event);
            this.publish(this.PROMISE_ACKNOWLEDGEMENT_EVENT_ID, {
                pk: event.pk
            });
            var systemEventId = this._getSystemEventId(event.eventId);
            return this.systemEventService.publishAsync(systemEventId, event.data).then(function (resolvedDataOfLastSubscriber) {
                _this.logService.debug(document.location.href, 'sending promise resolve', event);
                return _this.publish(_this.PROMISE_RETURN_EVENT_ID, {
                    pk: event.pk,
                    type: _this.SUCCESS,
                    resolvedDataOfLastSubscriber: resolvedDataOfLastSubscriber
                });
            }, function () {
                _this.logService.debug(document.location.href, 'sending promise reject', event);
                return _this.publish(_this.PROMISE_RETURN_EVENT_ID, {
                    pk: event.pk,
                    type: _this.FAILURE
                });
            });
        }
        else if (event.eventId === this.PROMISE_RETURN_EVENT_ID) {
            if (this.promisesToResolve[eventData.pk]) {
                if (eventData.type === this.SUCCESS) {
                    this.logService.debug(document.location.href, 'received promise resolve', event);
                    this.promisesToResolve[eventData.pk].resolve(eventData.resolvedDataOfLastSubscriber);
                }
                else if (eventData.type === this.FAILURE) {
                    this.logService.debug(document.location.href, 'received promise reject', event);
                    this.promisesToResolve[eventData.pk].reject();
                }
                delete this.promisesToResolve[eventData.pk];
            }
        }
        else if (event.eventId === this.PROMISE_ACKNOWLEDGEMENT_EVENT_ID) {
            if (this.promisesToResolve[eventData.pk]) {
                this.logService.debug(document.location.href, 'received acknowledgement', event);
                this.promisesToResolve[eventData.pk].acknowledged = true;
            }
        }
        return Promise.resolve();
    };
    MessageGateway.prototype._setTimeout = function (callback, timeout) {
        if (utils.functionsUtils.isUnitTestMode()) {
            setTimeout(callback, timeout);
        }
        else {
            this.windowUtils.runTimeoutOutsideAngular(callback, timeout);
        }
    };
    MessageGateway.prototype._generateIdentifier = function () {
        return new Date().getTime() + Math.random().toString();
    };
    MessageGateway.prototype._getSystemEventId = function (eventId) {
        return this.gatewayId + ':' + eventId;
    };
    return MessageGateway;
}());

/**
 * The Gateway Factory controls the creation of and access to {@link MessageGateway} instances.
 *
 * To construct and access a gateway, you must use the GatewayFactory's createGateway method and provide the channel
 * ID as an argument. If you try to create the same gateway twice, the second call will return a null.
 */
var /* @ngInject */ GatewayFactory = /** @class */ (function () {
    GatewayFactory.$inject = ["logService", "systemEventService", "cloneableUtils", "windowUtils", "promiseUtils", "functionsUtils"];
    function /* @ngInject */ GatewayFactory(logService, systemEventService, cloneableUtils, windowUtils, promiseUtils, functionsUtils) {
        this.logService = logService;
        this.systemEventService = systemEventService;
        this.cloneableUtils = cloneableUtils;
        this.windowUtils = windowUtils;
        this.promiseUtils = promiseUtils;
        this.functionsUtils = functionsUtils;
        this.messageGatewayMap = {};
    }
    /* @ngInject */ GatewayFactory_1 = /* @ngInject */ GatewayFactory;
    /**
     * Initializes a postMessage event handler that dispatches the handling of an event to the specified gateway.
     * If the corresponding gateway does not exist, an error is logged.
     */
    /* @ngInject */ GatewayFactory.prototype.initListener = function () {
        var _this = this;
        var processedPrimaryKeys = [];
        // Listen to message from child window
        this.windowUtils.getWindow().addEventListener('message', function (e) {
            if (_this._isAllowed(e.origin)) {
                // add control on e.origin
                var event_1 = e.data;
                if (processedPrimaryKeys.indexOf(event_1.pk) > -1) {
                    return;
                }
                processedPrimaryKeys.push(event_1.pk);
                _this.logService.debug('message event handler called', event_1.eventId);
                var gatewayId = event_1.gatewayId;
                var gateway = _this.messageGatewayMap[gatewayId];
                if (!gateway) {
                    _this.logService.debug('Incoming message on gateway ' +
                        gatewayId +
                        ', but no destination exists.');
                    return;
                }
                gateway.processEvent(event_1);
            }
            else {
                _this.logService.error('disallowed storefront is trying to communicate with smarteditcontainer');
            }
        }, false);
    };
    /**
     * Creates a gateway for the specified gateway identifier and caches it in order to handle postMessage events
     * later in the application lifecycle. This method will fail on subsequent calls in order to prevent two
     * clients from using the same gateway.
     *
     * @returns The newly created Message Gateway or null.
     */
    /* @ngInject */ GatewayFactory.prototype.createGateway = function (gatewayId) {
        if (this.messageGatewayMap[gatewayId] && !this.functionsUtils.isUnitTestMode()) {
            this.logService.error('Message Gateway for ' + gatewayId + ' already reserved');
            return null;
        }
        this.messageGatewayMap[gatewayId] = new MessageGateway(this.logService, this.systemEventService, this.cloneableUtils, this.windowUtils, this.promiseUtils, /* @ngInject */ GatewayFactory_1.TIMEOUT_TO_RETRY_PUBLISHING, gatewayId);
        return this.messageGatewayMap[gatewayId];
    };
    GatewayFactory.prototype.createGateway.$inject = ["gatewayId"];
    /**
     * Allowed if receiving end is frame or [container + (origin same as loaded iframe)]
     */
    /* @ngInject */ GatewayFactory.prototype._isAllowed = function (origin) {
        return (
        // communication from container to iframe already secured by webApplicationInjector
        this.windowUtils.isIframe() ||
            // communication from iframe to container strictly limiting to domain loaded in iframe
            this.windowUtils.getTrustedIframeDomain() === origin);
    };
    GatewayFactory.prototype._isAllowed.$inject = ["origin"];
    var /* @ngInject */ GatewayFactory_1;
    /*
     * Period between two retries of a MessageGateway to publish an event
     * this value must be greater than the time needed by the browser to process a postMessage back and forth across two frames.
     * Internet Explorer is now known to need more than 100ms.
     */
    /* @ngInject */ GatewayFactory.TIMEOUT_TO_RETRY_PUBLISHING = 500;
    /* @ngInject */ GatewayFactory = /* @ngInject */ GatewayFactory_1 = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService,
            SystemEventService,
            utils.CloneableUtils,
            WindowUtils,
            utils.PromiseUtils,
            utils.FunctionsUtils])
    ], /* @ngInject */ GatewayFactory);
    return /* @ngInject */ GatewayFactory;
}());

/**
 * To seamlessly integrate the gateway factory between two services on different frames, you can use a gateway
 * proxy. The gateway proxy service simplifies using the gateway module by providing an API that registers an
 * instance of a service that requires a gateway for communication.
 *
 * This registration process automatically attaches listeners to each of the service's functions (turned into promises), allowing stub
 * instances to forward calls to these functions using an instance of a gateway from {@link GatewayFactory}.
 * Any function that has an empty body declared on the service is used as a proxy function.
 * It delegates a publish call to the gateway under the same function name, and wraps the result of the call in a Promise.
 */
var /* @ngInject */ GatewayProxy = /** @class */ (function () {
    GatewayProxy.$inject = ["logService", "promiseUtils", "stringUtils", "functionsUtils", "gatewayFactory"];
    function /* @ngInject */ GatewayProxy(logService, promiseUtils, stringUtils, functionsUtils, gatewayFactory) {
        this.logService = logService;
        this.promiseUtils = promiseUtils;
        this.stringUtils = stringUtils;
        this.functionsUtils = functionsUtils;
        this.gatewayFactory = gatewayFactory;
        this.nonProxiableMethods = [
            'getMethodForVoid',
            'getMethodForSingleInstance',
            'getMethodForArray'
        ];
    }
    /**
     * Mutates the given service into a proxied service.
     * You must provide a unique string gatewayId, in one of 2 ways.
     *
     *
     * 1) Having a gatewayId property on the service provided
     *
     *
     * OR
     *
     *
     * 2) providing a gatewayId as 3rd param of this function
     *
     * @param service Service to mutate into a proxied service.
     * @param methodsSubset An explicit set of methods on which the gatewayProxy will trigger. Otherwise, by default all functions will be proxied. This is particularly useful to avoid inner methods being unnecessarily turned into promises.
     * @param gatewayId The gateway ID to use internaly for the proxy. If not provided, the service <strong>must</strong> have a gatewayId property.
     */
    /* @ngInject */ GatewayProxy.prototype.initForService = function (service, methodsSubset, gatewayId) {
        var _this = this;
        var gwId = gatewayId || service.gatewayId;
        if (!gwId) {
            this.logService.error("initForService() - service expected to have an associated gatewayId - methodsSubset: " + (methodsSubset && methodsSubset.length ? methodsSubset.join(',') : []));
            return null;
        }
        var gateway = this.gatewayFactory.createGateway(gwId);
        var loopedOver = methodsSubset;
        if (!loopedOver) {
            loopedOver = [];
            for (var key in service) {
                if (typeof service[key] === 'function' && !this._isNonProxiableMethod(key)) {
                    loopedOver.push(key);
                }
            }
        }
        loopedOver.forEach(function (fnName) {
            if (typeof service[fnName] === 'function') {
                if (_this.functionsUtils.isEmpty(service[fnName])) {
                    _this._turnToProxy(fnName, service, gateway);
                }
                else {
                    service[fnName] = _this.promiseUtils.toPromise(service[fnName], service);
                    gateway.subscribe(fnName, _this._onGatewayEvent.bind(null, fnName, service));
                }
            }
        });
    };
    GatewayProxy.prototype.initForService.$inject = ["service", "methodsSubset", "gatewayId"];
    /** @ignore */
    /* @ngInject */ GatewayProxy.prototype._isNonProxiableMethod = function (key) {
        return (this.nonProxiableMethods.indexOf(key) > -1 ||
            key.startsWith('$') ||
            key === 'lodash' ||
            key === 'jQuery');
    };
    GatewayProxy.prototype._isNonProxiableMethod.$inject = ["key"];
    /** @ignore */
    /* @ngInject */ GatewayProxy.prototype._onGatewayEvent = function (fnName, service, eventId, data) {
        return service[fnName].apply(service, data.arguments);
    };
    GatewayProxy.prototype._onGatewayEvent.$inject = ["fnName", "service", "eventId", "data"];
    /** @ignore */
    /* @ngInject */ GatewayProxy.prototype._turnToProxy = function (fnName, service, gateway) {
        var _this = this;
        delete service[fnName];
        service[fnName] = (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return gateway
                .publish(fnName, {
                arguments: args
            })
                .then(function (resolvedData) {
                if (!_this.stringUtils.isBlank(resolvedData)) {
                    delete resolvedData.$resolved;
                    delete resolvedData.$promise;
                }
                return resolvedData;
            }, function (error) {
                if (error) {
                    _this.logService.debug("gatewayProxy - publish failed for gateway " + gateway.gatewayId + " method " + fnName + " and arguments " + args);
                }
                return Promise.reject(error);
            });
        });
    };
    GatewayProxy.prototype._turnToProxy.$inject = ["fnName", "service", "gateway"];
    /* @ngInject */ GatewayProxy = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService,
            utils.PromiseUtils,
            utils.StringUtils,
            utils.FunctionsUtils,
            GatewayFactory])
    ], /* @ngInject */ GatewayProxy);
    return /* @ngInject */ GatewayProxy;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ANNOUNCEMENT_DATA = new core.InjectionToken('ANNOUNCEMENT_DATA');
/**
 * Interface for Announcement service
 */
var IAnnouncementService = /** @class */ (function () {
    function IAnnouncementService() {
    }
    /**
     * This method creates a new announcement and displays it.
     *
     * The configuration must contain either a description, template or template URL, but not multiple.
     *
     * @returns Returns a promise with announcement id.
     */
    IAnnouncementService.prototype.showAnnouncement = function (announcementConfig) {
        'proxyFunction';
        return null;
    };
    /**
     * This method is used to close the announcement by given announcement id.
     */
    IAnnouncementService.prototype.closeAnnouncement = function (announcementId) {
        'proxyFunction';
        return null;
    };
    return IAnnouncementService;
}());

/**
 * The Catalog Service fetches catalogs for a specified site or for all sites registered on the hybris platform using
 * REST calls to the cmswebservices Catalog Version Details API.
 */
var ICatalogService = /** @class */ (function () {
    function ICatalogService() {
    }
    // ------------------------------------------------------------------------------------------------------------------------
    //  Active
    // ------------------------------------------------------------------------------------------------------------------------
    /**
     * Convenience method to return a full `UriContext` to the invoker through a promise.
     *
     *
     * If uriContext is provided, it will be returned as such.
     *
     *
     * If uriContext is not provided, A uriContext will be built from the experience present in {@link /smartedit/injectables/SharedDataService.html SharedDataService}.
     * If we fail to find a uriContext in sharedDataService, an exception will be thrown.
     * @returns Wrapped uriContext in a promise
     */
    ICatalogService.prototype.retrieveUriContext = function (_uriContext) {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches a list of content catalogs for the site that corresponds to the specified site UID.
     *
     * @param siteUID The UID of the site that the catalog versions are to be fetched.
     *
     * @returns An array of catalog descriptors. Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalog version descriptors.
     */
    ICatalogService.prototype.getContentCatalogsForSite = function (siteUID) {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches a list of content catalog groupings for all sites.
     *
     * @returns An array of catalog groupings sorted by catalog ID, each of which has a name, a catalog ID, and a list of
     * catalog version descriptors.
     */
    ICatalogService.prototype.getAllContentCatalogsGroupedById = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches a list of catalogs for the given site UID and a given catalog version.
     *
     * @param siteUID The UID of the site that the catalog versions are to be fetched.
     * @param catalogVersion The version of the catalog that is to be fetched.
     *
     * @returns An array containing the catalog descriptor (if any). Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalogVersion.
     */
    // FIXME: this method does not seem to be safe for same catalogversion version name across multiple catalogs
    ICatalogService.prototype.getCatalogByVersion = function (siteUID, catalogVersionName) {
        'proxyFunction';
        return null;
    };
    /**
     * Determines whether the catalog version identified by the given uriContext is a non active one
     * if no uriContext is provided, an attempt will be made to retrieve an experience from {@link /smartedit/injectables/SharedDataService.html SharedDataService}.
     *
     * @returns True if the given catalog version is non active
     */
    ICatalogService.prototype.isContentCatalogVersionNonActive = function (_uriContext) {
        'proxyFunction';
        return null;
    };
    /**
     * Find the version that is flagged as active for the given uriContext.
     * if no uriContext is provided, an attempt will be made to retrieve an experience from {@link /smartedit/injectables/SharedDataService.html SharedDataService}.
     *
     * @returns The version name
     */
    ICatalogService.prototype.getContentCatalogActiveVersion = function (_uriContext) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the version name that is flagged as active for the given content catalog.
     *
     * @param contentCatalogId The UID of content catalog for which to retrieve its active catalog version name.
     * @returns The version name
     */
    ICatalogService.prototype.getActiveContentCatalogVersionByCatalogId = function (contentCatalogId) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the current site ID
     * @returns The ID of the current site.
     */
    ICatalogService.prototype.getCurrentSiteID = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the ID of the default site configured for the provided content catalog.
     * @param contentCatalogId The UID of content catalog for which to retrieve its default site ID.
     * @returns The ID of the default site found.
     */
    ICatalogService.prototype.getDefaultSiteForContentCatalog = function (contentCatalogId) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the catalog version given an uriContext object.
     *
     * @param uriContext An object that represents the current context, containing information about the site.
     * @returns A promise that resolves to the catalog version descriptor found.
     */
    ICatalogService.prototype.getContentCatalogVersion = function (uriContext) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the catalog version descriptor identified by the provided UUID.
     * An exception is thrown if no match is found.
     *
     * @param catalogVersionUuid The UID of the catalog version descriptor to find.
     * @param siteId the ID of the site where to perform the search.
     * If no ID is provided, the search will be performed on all permitted sites.
     * @returns A promise that resolves to the catalog version descriptor found.
     *
     */
    ICatalogService.prototype.getCatalogVersionByUuid = function (catalogVersionUuid, siteId) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the catalog version UUID given an optional urlContext object. The current catalog version UUID from the active experience selector is returned, if the URL is not present in the call.
     *
     * @param urlContext An object that represents the current context, containing information about the site.
     * @returns A promise that resolves to the catalog version uuid.
     */
    ICatalogService.prototype.getCatalogVersionUUid = function (_uriContext) {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches a list of product catalogs for the site that corresponds to the specified site UID key.
     *
     * @param siteUIDKey The UID of the site that the catalog versions are to be fetched.
     *
     * @returns An array of catalog descriptors. Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalog version descriptors.
     */
    ICatalogService.prototype.getProductCatalogsBySiteKey = function (siteUIDKey) {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches a list of product catalogs for the site that corresponds to the specified site UID value.
     *
     * @param siteUIDValue The UID value of the site that the catalog versions are to be fetched.
     *
     * @returns An array of catalog descriptors. Each descriptor provides the following catalog properties:
     * catalog (name), catalogId, and catalog version descriptors.
     */
    ICatalogService.prototype.getProductCatalogsForSite = function (siteUIDValue) {
        'proxyFunction';
        return null;
    };
    /**
     * Finds the version name that is flagged as active for the given product catalog.
     *
     * @param productCatalogId The UID of product catalog for which to retrieve its active catalog version name.
     * @returns the version name
     */
    ICatalogService.prototype.getActiveProductCatalogVersionByCatalogId = function (productCatalogId) {
        'proxyFunction';
        return null;
    };
    /**
     * Fetches all the active catalog version uuid's for a provided array of catalogs.
     *
     * @returns An array of catalog version uuid's
     */
    ICatalogService.prototype.returnActiveCatalogVersionUIDs = function (catalogs) {
        'proxyFunction';
        return null;
    };
    /**
     * Determines whether the current catalog from the page context of current experience is multicountry related or not.
     *
     * @returns True if current catalog is multicountry related; Otherwise false.
     */
    ICatalogService.prototype.isCurrentCatalogMultiCountry = function () {
        'proxyFunction';
        return null;
    };
    return ICatalogService;
}());

/**
 * ExperienceService deals with building experience objects given a context.
 */
var IExperienceService = /** @class */ (function () {
    function IExperienceService() {
    }
    IExperienceService.prototype.updateExperiencePageContext = function (pageCatalogVersionUuid, pageId) {
        'proxyFunction';
        return null;
    };
    /**
     * Retrieves the active experience.
     */
    IExperienceService.prototype.getCurrentExperience = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Stores a given experience as current experience.
     * Invoking this method ensures that a hard refresh of the application will preserve the experience.
     */
    IExperienceService.prototype.setCurrentExperience = function (experience) {
        'proxyFunction';
        return null;
    };
    /**
     * Determines whether the catalog version has changed between the previous and current experience
     */
    IExperienceService.prototype.hasCatalogVersionChanged = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Retrieves the active experience, creates a new preview ticket and returns a new preview url with an updated
     * previewTicketId query param
     *
     * @returns An URL containing the new `previewTicketId`
     */
    IExperienceService.prototype.buildRefreshedPreviewUrl = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Retrieves the active experience, merges it with a new experience, creates a new preview ticket and reloads the
     * preview within the iframeManagerService
     *
     * @param newExperience The object containing new attributes to be merged with the current experience
     *
     * @returns A promise of the updated experience
     */
    IExperienceService.prototype.updateExperience = function (newExperience) {
        'proxyFunction';
        return null;
    };
    IExperienceService.prototype.loadExperience = function (params) {
        'proxyFunction';
        return null;
    };
    /**
     * This method compares all the properties of given experience of type IDefaultExperienceParams with the current experience.
     *
     * @param experience The object containing default experience params such as pageId, catalogId, catalogVersion and siteId
     *
     * @return True if current experience matches with the gien experience. Otherwise false.
     */
    IExperienceService.prototype.compareWithCurrentExperience = function (experience) {
        'proxyFunction';
        return null;
    };
    /** @internal */
    IExperienceService.prototype._convertExperienceToPreviewData = function (experience, resourcePath) {
        var previewData = lodash.cloneDeep(experience);
        var catalogVersions = [];
        delete previewData.catalogDescriptor;
        delete previewData.siteDescriptor;
        delete previewData.languageDescriptor;
        delete previewData.pageContext;
        delete previewData.productCatalogVersions;
        if (experience.productCatalogVersions && experience.productCatalogVersions.length) {
            experience.productCatalogVersions.forEach(function (productCatalogVersion) {
                catalogVersions.push({
                    catalog: productCatalogVersion.catalog,
                    catalogVersion: productCatalogVersion.catalogVersion
                });
            });
        }
        catalogVersions.push({
            catalog: experience.catalogDescriptor.catalogId,
            catalogVersion: experience.catalogDescriptor.catalogVersion
        });
        previewData.catalogVersions = catalogVersions;
        previewData.language = experience.languageDescriptor.isocode;
        previewData.resourcePath = resourcePath;
        previewData.siteId = experience.siteDescriptor.uid;
        return previewData;
    };
    /**
     * If an experience is set in the shared data service, this method will load the preview for this experience (such as Catalog, language, date and time).
     * Otherwise, the user will be redirected to the landing page to select an experience.
     * To load a preview, we need to get a preview ticket from an API.
     * Here we set current location to null initially so that the iframe manager loads the provided url and set the location.
     *
     * @returns a promise returning the experience
     */
    IExperienceService.prototype.initializeExperience = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Given an object containing a siteId, catalogId, catalogVersion and catalogVersions (array of product catalog version uuid's), will return a reconstructed experience
     *
     */
    IExperienceService.prototype.buildAndSetExperience = function (params) {
        'proxyFunction';
        return null;
    };
    return IExperienceService;
}());

/**
 * The interface stipulates how to register features in the SmartEdit application and the SmartEdit container.
 * The SmartEdit implementation stores two instances of the interface across the {@link GatewayFactory gateway}: one for the SmartEdit application and one for the SmartEdit container.
 */
var IFeatureService = /** @class */ (function () {
    function IFeatureService(cloneableUtils) {
        this.cloneableUtils = cloneableUtils;
    }
    /**
     * This method registers a feature.
     * When an end user selects a perspective, all the features that are bound to the perspective
     * will be enabled when their respective enablingCallback functions are invoked
     * and all the features that are not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     * The SmartEdit application and the SmartEdit container hold/store an instance of the implementation because callbacks cannot cross the gateway as they are functions.
     *
     * this method is meant to register a feature (identified by a key).
     * When a perspective (registered through [register]{@link IPerspectiveService#register}) is selected, all its bound features will be enabled by invocation of their respective enablingCallback functions
     * and any feature not bound to it will be disabled by invocation of its disablingCallback function.
     * Both SmartEdit and SmartEditContainer will hold a concrete implementation since Callbacks, being functions, cannot cross the gateway.
     * The function will keep a frame bound reference on a full feature in order to be able to invoke its callbacks when needed.
     *
     * @param configuration Configuration of a `IContextualMenuButton` or `IDecorator` or `IToolbarItem`.
     */
    IFeatureService.prototype.register = function (configuration) {
        this._validate(configuration);
        this._featuresToAlias = this._featuresToAlias || {};
        this._featuresToAlias[configuration.key] = {
            enablingCallback: configuration.enablingCallback,
            disablingCallback: configuration.disablingCallback
        };
        delete configuration.enablingCallback;
        delete configuration.disablingCallback;
        return this._registerAliases(this.cloneableUtils.makeCloneable(configuration));
    };
    IFeatureService.prototype.enable = function (key) {
        if (this._featuresToAlias && this._featuresToAlias[key]) {
            this._featuresToAlias[key].enablingCallback();
        }
        else {
            this._remoteEnablingFromInner(key);
        }
    };
    IFeatureService.prototype.disable = function (key) {
        if (this._featuresToAlias && this._featuresToAlias[key]) {
            this._featuresToAlias[key].disablingCallback();
        }
        else {
            this._remoteDisablingFromInner(key);
        }
    };
    /**
     * @returns A promise of property value or null if property does not exist
     */
    IFeatureService.prototype.getFeatureProperty = function (featureKey, propertyName) {
        'proxyFunction';
        return null;
    };
    /**
     * This method registers toolbar items as features. It is a wrapper around [register]{@link IFeatureService#register}.
     *
     * @param configuration Configuration that represents the toolbar action item to be registered.
     */
    IFeatureService.prototype.addToolbarItem = function (toolbar) {
        'proxyFunction';
        return null;
    };
    /**
     * This method registers decorator and delegates to the
     *  {@link /smartedit/injectables/DecoratorService.html#enable enable}
     *  {@link /smartedit/injectables/DecoratorService.html#disable disable} methods.
     * This method is not a wrapper around {@link /smartedit/injectables/DecoratorService.html#addMappings addMappings}:
     * From a feature stand point, we deal with decorators, not their mappings to SmartEdit components.
     * We still need to have a separate invocation of {@link /smartedit/injectables/DecoratorService.html#addMappings addMappings}
     */
    IFeatureService.prototype.addDecorator = function (decorator) {
        'proxyFunction';
        return null;
    };
    /**
     * This method registers contextual menu buttons.
     * It is a wrapper around {@link /smartedit/injectables/ContextualMenuService.html#addItems addItems}.
     */
    IFeatureService.prototype.addContextualMenuButton = function (btn) {
        'proxyFunction';
        return null;
    };
    IFeatureService.prototype.getFeatureKeys = function () {
        'proxyFunction';
        return null;
    };
    IFeatureService.prototype._remoteEnablingFromInner = function (key) {
        'proxyFunction';
        return null;
    };
    IFeatureService.prototype._remoteDisablingFromInner = function (key) {
        'proxyFunction';
        return null;
    };
    /**
     * This method registers a feature, identified by a unique key, across the {@link GatewayFactory}.
     * It is a simplified version of the register method, from which callbacks have been removed.
     */
    IFeatureService.prototype._registerAliases = function (configuration) {
        'proxyFunction';
        return null;
    };
    IFeatureService.prototype._validate = function (configuration) {
        if (lodash.isEmpty(configuration.key)) {
            throw new Error('featureService.configuration.key.error.required');
        }
        if (lodash.isEmpty(configuration.nameI18nKey)) {
            throw new Error('featureService.configuration.nameI18nKey.error.required');
        }
        if (!lodash.isFunction(configuration.enablingCallback)) {
            throw new Error('featureService.configuration.enablingCallback.error.not.function');
        }
        if (!lodash.isFunction(configuration.disablingCallback)) {
            throw new Error('featureService.configuration.disablingCallback.error.not.function');
        }
    };
    return IFeatureService;
}());

/**
 * The interface defines the methods required to detect when the mouse leaves the notification panel
 * in the SmartEdit application and in the SmartEdit container.
 *
 * It is solely meant to be used with the notificationService.
 */
var INotificationMouseLeaveDetectionService = /** @class */ (function () {
    function INotificationMouseLeaveDetectionService() {
    }
    /**
     * This method starts tracking the movement of the mouse pointer in order to detect when it
     * leaves the notification panel.
     *
     * The innerBounds parameter is considered optional. If it is not provided, it will not be
     * validated and detection will only be started in the SmartEdit container.
     *
     * Here is an example of a bounds object:
     *
     * {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 50
     * }
     *
     * This method will throw an error if:
     *     - the bounds parameter is not provided
     *     - a bounds object does not contain the X coordinate
     *     - a bounds object does not contain the Y coordinate
     *     - a bounds object does not contain the width dimension
     *     - a bounds object does not contain the height dimension
     */
    INotificationMouseLeaveDetectionService.prototype.startDetection = function (outerBounds, innerBounds, callback) {
        'proxyFunction';
        return null;
    };
    /**
     * This method stops tracking the movement of the mouse pointer.
     */
    INotificationMouseLeaveDetectionService.prototype.stopDetection = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method is used to start tracking the movement of the mouse pointer within the iFrame.
     */
    INotificationMouseLeaveDetectionService.prototype._remoteStartDetection = function (bound) {
        'proxyFunction';
        return null;
    };
    /**
     * This method is used to stop tracking the movement of the mouse pointer within the iFrame.
     */
    INotificationMouseLeaveDetectionService.prototype._remoteStopDetection = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method is used to call the callback function when it is detected from within the iFrame that
     * the mouse left the notification panel
     */
    INotificationMouseLeaveDetectionService.prototype._callCallback = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method is called for each mouse movement. It evaluates whether or not the
     * mouse pointer is in the notification panel. If it isn't, it calls the onMouseLeave.
     */
    INotificationMouseLeaveDetectionService.prototype._onMouseMove = function (event) {
        var _this = this;
        this._getBounds().then(function (bounds) {
            var isOutsideX = bounds &&
                event &&
                (event.clientX < bounds.x || event.clientX > bounds.x + bounds.width);
            var isOutsideY = bounds &&
                event &&
                (event.clientY < bounds.y || event.clientY > bounds.y + bounds.height);
            if (isOutsideX || isOutsideY) {
                _this._onMouseLeave();
            }
        });
    };
    /**
     * This method gets bounds
     */
    INotificationMouseLeaveDetectionService.prototype._getBounds = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method gets callback
     */
    INotificationMouseLeaveDetectionService.prototype._getCallback = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method is triggered when the service has detected that the mouse left the
     * notification panel. It will execute the callback function and stop detection.
     */
    INotificationMouseLeaveDetectionService.prototype._onMouseLeave = function () {
        var _this = this;
        this._getCallback().then(function (callback) {
            if (callback) {
                callback();
                _this.stopDetection();
            }
            else {
                _this._callCallback().then(function () {
                    _this.stopDetection();
                });
            }
        });
    };
    return INotificationMouseLeaveDetectionService;
}());

/**
 * INotificationService provides a service to display visual cues to inform
 * the user of the state of the application in the container or the iFramed application.
 * The interface defines the methods required to manage notifications that are to be displayed to the user.
 */
var INotificationService = /** @class */ (function () {
    function INotificationService() {
    }
    /**
     * This method creates a new notification based on the given configuration and
     * adds it to the top of the list.
     *
     * The configuration must contain either one of componentName, template or templateUrl.
     *
     * ### Throws
     *
     * - Throws An error if no configuration is given.
     * - Throws An error if the configuration does not contain a unique identifier.
     * - Throws An error if the configuration's unique identifier is an empty string.
     * - Throws An error if the configuration does not contain a componenName, template or templateUrl.
     * - Throws An error if the configuration contains more than one template type.
     */
    INotificationService.prototype.pushNotification = function (configuration) {
        'proxyFunction';
        return null;
    };
    /**
     * Moves the notification with the given ID from the list.
     */
    INotificationService.prototype.removeNotification = function (notificationId) {
        'proxyFunction';
        return null;
    };
    /**
     * This method removes all notifications.
     */
    INotificationService.prototype.removeAllNotifications = function () {
        'proxyFunction';
        return null;
    };
    return INotificationService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * The IPageInfoService provides information about the storefront page currently loaded in the iFrame.
 */
var IPageInfoService = /** @class */ (function () {
    function IPageInfoService() {
    }
    /**
     * This extracts the pageUID of the storefront page loaded in the smartedit iframe.
     */
    IPageInfoService.prototype.getPageUID = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This extracts the pageUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     */
    IPageInfoService.prototype.getPageUUID = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This extracts the catalogVersionUUID of the storefront page loaded in the smartedit iframe.
     * The UUID is different from the UID in that it is an encoding of uid and catalog version combined
     */
    IPageInfoService.prototype.getCatalogVersionUUIDFromPage = function () {
        'proxyFunction';
        return null;
    };
    return IPageInfoService;
}());

/**
 * Interface for previewService.
 *
 * This service is for managing the storefront preview ticket and is proxied across the gateway.
 */
var /* @ngInject */ IPreviewService = /** @class */ (function () {
    IPreviewService.$inject = ["urlUtils"];
    function /* @ngInject */ IPreviewService(urlUtils) {
        this.urlUtils = urlUtils;
    }
    /**
     * This method will create a new previewTicket for the given experience, using the preview API
     *
     *
     * This method does *NOT* update the current experience.
     *
     * @param previewData Data representing storefront preview
     *
     * @returns An object with the ticketId
     */
    /* @ngInject */ IPreviewService.prototype.createPreview = function (previewData) {
        'proxyFunction';
        return null;
    };
    IPreviewService.prototype.createPreview.$inject = ["previewData"];
    /**
     * This method will update a previewTicket for the given the preview data, using the preview API
     *
     * @param previewData Data representing storefront preview containing the preview ticketId
     *
     * @returns An object with the ticketId
     */
    /* @ngInject */ IPreviewService.prototype.updatePreview = function (previewData) {
        'proxyFunction';
        return null;
    };
    IPreviewService.prototype.updatePreview.$inject = ["previewData"];
    /**
     * This method will preduce a resourcePath from a given preview url
     *
     *
     * This method does *NOT* update the current experience.
     */
    /* @ngInject */ IPreviewService.prototype.getResourcePathFromPreviewUrl = function (previewUrl) {
        'proxyFunction';
        return null;
    };
    IPreviewService.prototype.getResourcePathFromPreviewUrl.$inject = ["previewUrl"];
    /**
     * This method will create a new preview ticket, and return the given url with an updated previewTicketId query param
     *
     *
     * This method does *NOT* update the current experience.
     *
     * @param storefrontUrl Existing storefront url
     * @param previewData JSON representing storefront previewData (catalog, catalog vesion, etc...)
     *
     * @returns A new string with storefrontUrl having the new ticket ID inside
     */
    /* @ngInject */ IPreviewService.prototype.updateUrlWithNewPreviewTicketId = function (storefrontUrl, previewData) {
        var _this = this;
        return this.createPreview(previewData).then(function (preview) {
            return _this.urlUtils.updateUrlParameter(storefrontUrl, 'cmsTicketId', preview.ticketId);
        });
    };
    IPreviewService.prototype.updateUrlWithNewPreviewTicketId.$inject = ["storefrontUrl", "previewData"];
    /* @ngInject */ IPreviewService = __decorate([
        SeInjectable(),
        __metadata("design:paramtypes", [utils.UrlUtils])
    ], /* @ngInject */ IPreviewService);
    return /* @ngInject */ IPreviewService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var IUrlService = /** @class */ (function () {
    function IUrlService() {
    }
    /**
     * Opens a given URL in a new browser pop up without authentication.
     */
    IUrlService.prototype.openUrlInPopup = function (url) {
        'proxyFunction';
        return null;
    };
    /**
     * Navigates to the given path in the same browser tab.
     */
    IUrlService.prototype.path = function (path) {
        'proxyFunction';
        return null;
    };
    /**
     * Returns a uri context array populated with the given siteId, catalogId and catalogVersion information
     */
    IUrlService.prototype.buildUriContext = function (siteId, catalogId, catalogVersion) {
        var uriContext = {};
        uriContext[CONTEXT_SITE_ID] = siteId;
        uriContext[CONTEXT_CATALOG] = catalogId;
        uriContext[CONTEXT_CATALOG_VERSION] = catalogVersion;
        return uriContext;
    };
    /**
     * Returns a page uri context array populated with the given siteId, catalogId and catalogVersion information
     */
    IUrlService.prototype.buildPageUriContext = function (siteId, catalogId, catalogVersion) {
        var uriContext = {};
        uriContext[PAGE_CONTEXT_SITE_ID] = siteId;
        uriContext[PAGE_CONTEXT_CATALOG] = catalogId;
        uriContext[PAGE_CONTEXT_CATALOG_VERSION] = catalogVersion;
        return uriContext;
    };
    return IUrlService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * This service be used in order to display (or hide) a 'loading' overlay. The overlay should display on top of everything, preventing
 * the user from doing any action until the overlay gets hidden.
 */
var IWaitDialogService = /** @class */ (function () {
    function IWaitDialogService() {
    }
    /**
     * @param customLoadingMessageLocalizedKey The i18n key that corresponds to the message to be displayed. Default value `"se.wait.dialog.message"`.
     */
    IWaitDialogService.prototype.showWaitModal = function (customLoadingMessageLocalizedKey) {
        'proxyFunction';
        return null;
    };
    IWaitDialogService.prototype.hideWaitModal = function () {
        'proxyFunction';
        return null;
    };
    return IWaitDialogService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Provides the functionality to transmit a click event from anywhere within
 * the contents of the SmartEdit application iFrame to the SmartEdit container. Specifically, the module uses yjQuery to
 * bind mousedown events on the iFrame document to a proxy function, triggering the event on the SmartEdit container.
 */
var IIframeClickDetectionService = /** @class */ (function () {
    function IIframeClickDetectionService() {
    }
    /**
     * Callback triggered by mousedown event of SmartEdit application
     */
    IIframeClickDetectionService.prototype.onIframeClick = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Registers a callback registered given the ID and a callback function
     */
    IIframeClickDetectionService.prototype.registerCallback = function (id, callback) {
        'proxyFunction';
        return null;
    };
    /**
     * Removes a callback registered to the given ID
     */
    IIframeClickDetectionService.prototype.removeCallback = function (id) {
        'proxyFunction';
    };
    return IIframeClickDetectionService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * When you provide AlertService from '@fundamental-ngx/core' as a dependency
 * it doesn't work, seems to be constructor class name collision.
 * Provide this token in a Module and use it in constructor as follows
 * @Inject(ALERT_SERVICE_TOKEN) fundamentalAlertService: FundamentalAlertService
 */
var ALERT_SERVICE_TOKEN = new core.InjectionToken('alertServiceToken');
var IAlertService = /** @class */ (function () {
    function IAlertService() {
    }
    IAlertService.prototype.showAlert = function (alertConf) {
        'proxyFunction';
        return;
    };
    IAlertService.prototype.showInfo = function (alertConf) {
        'proxyFunction';
        return;
    };
    IAlertService.prototype.showDanger = function (alertConf) {
        'proxyFunction';
        return;
    };
    IAlertService.prototype.showWarning = function (alertConf) {
        'proxyFunction';
        return;
    };
    IAlertService.prototype.showSuccess = function (alertConf) {
        'proxyFunction';
        return;
    };
    return IAlertService;
}());

var prepareRuleConfiguration = function (ruleConfiguration) {
    this.ruleVerifyFunctions = this.ruleVerifyFunctions || {};
    this.ruleVerifyFunctions[ruleConfiguration.names.join('-')] = {
        verify: ruleConfiguration.verify
    };
    delete ruleConfiguration.verify;
    return ruleConfiguration;
};
var validateRule = function (rule) {
    if (!(rule.names instanceof Array)) {
        throw Error('Rule names must be array');
    }
    if (rule.names.length < 1) {
        throw Error('Rule requires at least one name');
    }
    if (!rule.verify) {
        throw Error('Rule requires a verify function');
    }
    if (typeof rule.verify !== 'function') {
        throw Error('Rule verify must be a function');
    }
};
/**
 * The permission service is used to check if a user has been granted certain permissions.
 *
 * It is configured with rules and permissions. A rule is used to execute some logic to determine whether or not
 * the permission should be granted. A permission references a list of rules. In order for a permission to be
 * granted, each rule must be executed successfully and return true.
 */
var IPermissionService = /** @class */ (function () {
    function IPermissionService() {
    }
    /**
     * This method clears all cached results in the rules' caches.
     */
    IPermissionService.prototype.clearCache = function () {
        'proxyFunction';
        return;
    };
    /**
     * This method returns the registered permission that contains the given name in its
     * array of names.
     *
     * @returns The permission with the given name, undefined otherwise.
     */
    IPermissionService.prototype.getPermission = function (permission) {
        'proxyFunction';
        return null;
    };
    /**
     * This method checks if a user has been granted certain permissions.
     *
     * It takes an array of permission objects structured as follows:
     *
     * ### Example
     *
     *      {
     *          names: ["permission.aliases"],
     *          context: {
     *              data: "required to check a permission"
     *          }
     *      }
     *
     *
     * @returns A promise that resolves to true if permission is granted, rejects to false if it isn't and rejects on error.
     */
    IPermissionService.prototype.isPermitted = function (permissions) {
        'proxyFunction';
        return null;
    };
    /**
     * This method registers a permission.
     *
     * A permission is defined by a set of aliases and rules. It is verified by its set of rules.
     * The set of aliases is there for convenience, as there may be different permissions
     * that use the same set of rules to be verified. The permission aliases property
     * will resolve if any one alias is in the aliases' array. Calling [isPermitted]{@link IPermissionService#isPermitted}
     * with any of these aliases will use the same permission object, therefore the same
     * combination of rules to check if the user has the appropriate clearance. This reduces the
     * number of permissions you need to register.
     *
     * ### Throws
     *
     * - Will throw an error if the permission has no aliases array
     * - Will throw an error if the permission's aliases array is empty
     * - Will throw an error if the permission has no rules array
     * - Will throw an error if the permission's rule aliases array is empty
     * - Will throw an error if a permission is already registered with a common entry in its array of aliases
     * - Will throw an error if one of the permission's aliases is not name spaced
     * - Will throw an error if no rule is registered with on of the permission's rule names
     */
    IPermissionService.prototype.registerPermission = function (permission) {
        'proxyFunction';
        return;
    };
    /**
     * This method registers a rule. These rules can be used by registering permissions that
     * use them to verify if a user has the appropriate clearance.
     *
     * To avoid accidentally overriding the default rule, an error is thrown when attempting
     * to register a rule with the {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.
     *
     * To register the default rule, see [registerDefaultRule]{@link IPermissionService#registerDefaultRule}.
     *
     * It must return a promise that responds with true, false, or an error.
     *
     * ### Throws
     *
     * - Will throw an error if the list of rule names contains the reserved {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.
     * - Will throw an error if the rule has no names array.
     * - Will throw an error if the rule's names array is empty.
     * - Will throw an error if the rule has no verify function.
     * - Will throw an error if the rule's verify parameter is not a function.
     * - Will throw an error if a rule is already registered with a common entry in its names array
     */
    IPermissionService.prototype.registerRule = function (ruleConfiguration) {
        validateRule(ruleConfiguration);
        ruleConfiguration = prepareRuleConfiguration.bind(this)(ruleConfiguration);
        this._registerRule(ruleConfiguration);
    };
    /**
     * This method registers the default rule.
     *
     * The default rule is used when no permission is found for a given permission name when
     * [isPermitted]{@link IPermissionService#isPermitted} is called.
     *
     * ### Throws
     *
     * - Will throw an error if the default rule's names does not contain {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.
     * - Will throw an error if the default rule has no names array.
     * - Will throw an error if the default rule's names array is empty.
     * - Will throw an error if the default rule has no verify function.
     * - Will throw an error if the default rule's verify parameter is not a function.
     * - Will throw an error if a rule is already registered with a common entry in its names array
     */
    IPermissionService.prototype.registerDefaultRule = function (ruleConfiguration) {
        ruleConfiguration = prepareRuleConfiguration.bind(this)(ruleConfiguration);
        this._registerDefaultRule(ruleConfiguration);
    };
    IPermissionService.prototype.unregisterDefaultRule = function () {
        'proxyFunction';
        return;
    };
    IPermissionService.prototype._registerRule = function (ruleConfiguration) {
        'proxyFunction';
        return;
    };
    IPermissionService.prototype._registerDefaultRule = function (ruleConfiguration) {
        'proxyFunction';
        return;
    };
    return IPermissionService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var IResizeListener = /** @class */ (function () {
    function IResizeListener() {
    }
    IResizeListener.prototype.unregister = function (element) {
        'proxyFunction';
    };
    IResizeListener.prototype.fix = function (element) {
        'proxyFunction';
    };
    IResizeListener.prototype.register = function (element, listener) {
        'proxyFunction';
    };
    IResizeListener.prototype.init = function () {
        'proxyFunction';
    };
    IResizeListener.prototype.dispose = function () {
        'proxyFunction';
    };
    return IResizeListener;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var IPositionRegistry = /** @class */ (function () {
    function IPositionRegistry() {
    }
    IPositionRegistry.prototype.register = function (element) {
        'proxyFunction';
    };
    IPositionRegistry.prototype.unregister = function (element) {
        'proxyFunction';
    };
    IPositionRegistry.prototype.getRepositionedComponents = function () {
        'proxyFunction';
        return null;
    };
    IPositionRegistry.prototype.dispose = function () {
        'proxyFunction';
    };
    return IPositionRegistry;
}());

var IRenderService = /** @class */ (function () {
    function IRenderService(yjQuery, systemEventService, notificationService, pageInfoService, perspectiveService, crossFrameEventService, windowUtils, modalService) {
        this.yjQuery = yjQuery;
        this.systemEventService = systemEventService;
        this.notificationService = notificationService;
        this.pageInfoService = pageInfoService;
        this.perspectiveService = perspectiveService;
        this.crossFrameEventService = crossFrameEventService;
        this.windowUtils = windowUtils;
        this.modalService = modalService;
        this.KEY_CODES = {
            ESC: 27
        };
        this.HOTKEY_NOTIFICATION_CONFIGURATION = {
            id: 'HOTKEY_NOTIFICATION_ID',
            componentName: 'PerspectiveSelectorHotkeyNotificationComponent'
        };
        this._bindEvents();
    }
    /**
     * Re-renders a slot in the page
     */
    IRenderService.prototype.renderSlots = function (_slotIds) {
        'proxyFunction';
        return null;
    };
    /**
     * Re-renders a component in the page.
     *
     * @param customContent The custom content to replace the component content with. If specified, the
     * component content will be rendered with it, instead of the accelerator's. Optional.
     *
     * @returns Promise that will resolve on render success or reject if there's an error. When rejected,
     * the promise returns an Object{message, stack}.
     */
    IRenderService.prototype.renderComponent = function (componentId, componentType) {
        'proxyFunction';
        return null;
    };
    /**
     * This method removes a component from a slot in the current page. Note that the component is only removed
     * on the frontend; the operation does not propagate to the backend.
     *
     * @param componentId The ID of the component to remove.
     *
     * @returns Object wrapping the removed component.
     */
    IRenderService.prototype.renderRemoval = function (componentId, componentType, slotId) {
        'proxyFunction';
        return null;
    };
    /**
     * Re-renders all components in the page.
     * this method first resets the HTML content all of components to the values saved by {@link /smartedit/injectables/DecoratorService.html#storePrecompiledComponent storePrecompiledComponent} at the last $compile time
     * then requires a new compilation.
     */
    IRenderService.prototype.renderPage = function (isRerender) {
        'proxyFunction';
        return null;
    };
    /**
     * Toggles on/off the visibility of the page overlay (containing the decorators).
     *
     * @param isVisible Flag that indicates if the overlay must be displayed.
     */
    IRenderService.prototype.toggleOverlay = function (isVisible) {
        'proxyFunction';
        return null;
    };
    /**
     * This method updates the position of the decorators in the overlay. Normally, this method must be executed every
     * time the original storefront content is updated to keep the decorators correctly positioned.
     */
    IRenderService.prototype.refreshOverlayDimensions = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Toggles the rendering to be blocked or not which determines whether the overlay should be rendered or not.
     *
     * @param isBlocked Flag that indicates if the rendering should be blocked or not.
     */
    IRenderService.prototype.blockRendering = function (isBlocked) {
        'proxyFunction';
        return null;
    };
    /**
     * This method returns a boolean that determines whether the rendering is blocked or not.
     *
     * @returns True if the rendering is blocked. Otherwise false.
     */
    IRenderService.prototype.isRenderingBlocked = function () {
        'proxyFunction';
        return null;
    };
    IRenderService.prototype._getDocument = function () {
        return document;
    };
    IRenderService.prototype._bindEvents = function () {
        var _this = this;
        this._getDocument().addEventListener('keyup', function (event) {
            return _this._keyUpEventHandler(event);
        });
        this._getDocument().addEventListener('click', function () { return _this._clickEvent(); });
    };
    IRenderService.prototype._keyUpEventHandler = function (event) {
        var _this = this;
        if (!this._areAllModalWindowsClosed()) {
            return Promise.resolve();
        }
        return this._shouldEnableKeyPressEvent(event).then(function (enableKeyPressEvent) {
            if (enableKeyPressEvent) {
                _this._keyPressEvent();
            }
        });
    };
    IRenderService.prototype._shouldEnableKeyPressEvent = function (event) {
        var _this = this;
        return new Promise(function (resolve) {
            try {
                return _this.pageInfoService.getPageUUID().then(function (pageUUID) {
                    if (pageUUID) {
                        return _this.perspectiveService
                            .isHotkeyEnabledForActivePerspective()
                            .then(function (isHotkeyEnabled) {
                            return resolve(event.which === _this.KEY_CODES.ESC && isHotkeyEnabled);
                        });
                    }
                    return resolve(false);
                });
            }
            catch (e) {
                return resolve(false);
            }
        });
    };
    IRenderService.prototype._keyPressEvent = function () {
        var _this = this;
        this.isRenderingBlocked().then(function (isBlocked) {
            if (!isBlocked) {
                _this.blockRendering(true);
                _this.renderPage(false);
                _this.notificationService.pushNotification(_this.HOTKEY_NOTIFICATION_CONFIGURATION);
                _this.systemEventService.publishAsync('OVERLAY_DISABLED');
            }
            else {
                _this.blockRendering(false);
                _this.renderPage(true);
                _this.notificationService.removeNotification(_this.HOTKEY_NOTIFICATION_CONFIGURATION.id);
            }
        });
    };
    IRenderService.prototype._clickEvent = function () {
        var _this = this;
        if (!this.windowUtils.isIframe()) {
            this.crossFrameEventService.publish(EVENT_OUTER_FRAME_CLICKED);
        }
        return this.isRenderingBlocked().then(function (isBlocked) {
            if (isBlocked && !_this.windowUtils.isIframe()) {
                _this.blockRendering(false);
                _this.renderPage(true);
                return _this.notificationService.removeNotification(_this.HOTKEY_NOTIFICATION_CONFIGURATION.id);
            }
            return null;
        });
    };
    IRenderService.prototype._areAllModalWindowsClosed = function () {
        return !this.modalService.hasOpenModals();
    };
    return IRenderService;
}());

/**
 * The toolbar service factory generates instances of the {@link IToolbarService ToolbarService} based on
 * the gateway ID (toolbar-name) provided. Only one ToolbarService instance exists for each gateway ID, that is, the
 * instance is a singleton with respect to the gateway ID.
 */
var IToolbarServiceFactory = /** @class */ (function () {
    function IToolbarServiceFactory() {
    }
    /**
     * Returns a single instance of the ToolbarService for the given gateway identifier. If one does not exist, an
     * instance is created and cached.
     *
     * @param gatewayId The toolbar name used for cross iframe communication (see {@link GatewayProxy}).
     * @returns Corresponding ToolbarService instance for given gateway ID.
     */
    IToolbarServiceFactory.prototype.getToolbarService = function (gatewayId) {
        'proxyFunction';
        return null;
    };
    return IToolbarServiceFactory;
}());

var IConfirmationModalService = /** @class */ (function () {
    function IConfirmationModalService() {
    }
    IConfirmationModalService.prototype.confirm = function (conf) {
        'proxyFunction';
        return Promise.resolve();
    };
    return IConfirmationModalService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Provides a logic that allows to verify read and write permissions for a particular catalog version.
 */
var ICatalogVersionPermissionService = /** @class */ (function () {
    function ICatalogVersionPermissionService() {
    }
    /**
     * Verifies whether current user has write permission for provided catalogId and catalogVersion.
     */
    ICatalogVersionPermissionService.prototype.hasWritePermission = function (catalogId, catalogVersion) {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has read permission for provided catalogId and catalogVersion.
     */
    ICatalogVersionPermissionService.prototype.hasReadPermission = function (catalogId, catalogVersion) {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has write permission for current catalog version.
     */
    ICatalogVersionPermissionService.prototype.hasWritePermissionOnCurrent = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has read permission for current catalog version.
     */
    ICatalogVersionPermissionService.prototype.hasReadPermissionOnCurrent = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has sync permission for provided catalogId, source and target catalog versions.
     */
    ICatalogVersionPermissionService.prototype.hasSyncPermission = function (catalogId, sourceCatalogVersion, targetCatalogVersion) {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has sync permission for current catalog version.
     */
    ICatalogVersionPermissionService.prototype.hasSyncPermissionFromCurrentToActiveCatalogVersion = function () {
        'proxyFunction';
        return null;
    };
    /**
     * Verifies whether current user has sync permission for provided catalogId and catalog version.
     */
    ICatalogVersionPermissionService.prototype.hasSyncPermissionToActiveCatalogVersion = function (catalogId, catalogVersion) {
        'proxyFunction';
        return null;
    };
    return ICatalogVersionPermissionService;
}());

var IDecoratorService = /** @class */ (function () {
    function IDecoratorService() {
    }
    IDecoratorService.prototype.addMappings = function (mappings) {
        'proxyFunction';
    };
    IDecoratorService.prototype.enable = function (decoratorKey, displayCondition) {
        'proxyFunction';
    };
    IDecoratorService.prototype.disable = function (decoratorKey) {
        'proxyFunction';
    };
    IDecoratorService.prototype.getDecoratorsForComponent = function (componentType, componentId) {
        'proxyFunction';
        return null;
    };
    return IDecoratorService;
}());

var IRestServiceFactory = /** @class */ (function () {
    function IRestServiceFactory() {
    }
    IRestServiceFactory.prototype.get = function (uri, identifier) {
        'proxyFunction';
        return null;
    };
    IRestServiceFactory.prototype.setDomain = function (domain) {
        'proxyFunction';
    };
    IRestServiceFactory.prototype.setBasePath = function (basePath) {
        'proxyFunction';
    };
    IRestServiceFactory.prototype.setGlobalBasePath = function (globalDomain) {
        'proxyFunction';
    };
    return IRestServiceFactory;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var IDragAndDropCrossOrigin = /** @class */ (function () {
    function IDragAndDropCrossOrigin() {
    }
    IDragAndDropCrossOrigin.prototype.initialize = function () {
        'proxyFunction';
    };
    return IDragAndDropCrossOrigin;
}());

var IContextualMenuService = /** @class */ (function () {
    function IContextualMenuService() {
    }
    IContextualMenuService.prototype.addItems = function (contextualMenuItemsMap) {
        'proxyFunction';
    };
    IContextualMenuService.prototype.removeItemByKey = function (itemKey) {
        'proxyFunction';
    };
    IContextualMenuService.prototype.containsItem = function (itemKey) {
        'proxyFunction';
        return null;
    };
    IContextualMenuService.prototype.getContextualMenuByType = function (componentType) {
        'proxyFunction';
        return null;
    };
    IContextualMenuService.prototype.refreshMenuItems = function () {
        'proxyFunction';
    };
    IContextualMenuService.prototype.getContextualMenuItems = function (configuration) {
        return null;
    };
    return IContextualMenuService;
}());

var ICatalogDetailsService = /** @class */ (function () {
    function ICatalogDetailsService() {
    }
    ICatalogDetailsService.prototype.addItems = function (items, column) {
        'proxyFunction';
    };
    ICatalogDetailsService.prototype.getItems = function () {
        'proxyFunction';
        return null;
    };
    return ICatalogDetailsService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ILegacyDecoratorToCustomElementConverter = /** @class */ (function () {
    function ILegacyDecoratorToCustomElementConverter() {
    }
    ILegacyDecoratorToCustomElementConverter.prototype.getScopes = function () {
        return null;
    };
    ILegacyDecoratorToCustomElementConverter.prototype.convert = function (_componentName) {
        return null;
    };
    ILegacyDecoratorToCustomElementConverter.prototype.convertIfNeeded = function (componentNames) {
        return null;
    };
    return ILegacyDecoratorToCustomElementConverter;
}());

var ISmartEditContractChangeListener = /** @class */ (function () {
    function ISmartEditContractChangeListener() {
    }
    ISmartEditContractChangeListener.prototype._newMutationObserver = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._newIntersectionObserver = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._addToComponentQueue = function (entry) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._componentsQueueLength = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype.isExtendedViewEnabled = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype.setEconomyMode = function (_mode) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.initListener = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype._processQueue = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype.isIntersecting = function (obj) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._rawProcessQueue = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype._addComponents = function (componentsObj) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._removeComponents = function (componentsObj, forceRemoval) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._registerSizeAndPositionListeners = function (component) {
        return null;
    };
    ISmartEditContractChangeListener.prototype._unregisterSizeAndPositionListeners = function (component) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.stopListener = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype._stopExpendableListeners = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype._startExpendableListeners = function () {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onComponentsAdded = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onComponentsRemoved = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onComponentChanged = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onComponentResized = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onComponentRepositioned = function (callback) {
        return null;
    };
    ISmartEditContractChangeListener.prototype.onPageChanged = function (callback) {
        return null;
    };
    return ISmartEditContractChangeListener;
}());

var ITemplateCacheService = /** @class */ (function () {
    function ITemplateCacheService() {
    }
    ITemplateCacheService.prototype.info = function () {
        return undefined;
    };
    ITemplateCacheService.prototype.put = function (key, value) {
        return undefined;
    };
    ITemplateCacheService.prototype.get = function (key) {
        return undefined;
    };
    ITemplateCacheService.prototype.remove = function (key) {
        return undefined;
    };
    ITemplateCacheService.prototype.removeAll = function () {
        return undefined;
    };
    ITemplateCacheService.prototype.destroy = function () {
        return undefined;
    };
    return ITemplateCacheService;
}());

var WIZARD_MANAGER = new core.InjectionToken('WIZARD_MANAGER');
var WIZARD_API = new core.InjectionToken('WIZARD_API');
/**
 * The Wizard Manager is a wizard management service that can be injected into your wizard controller.
 */
var WizardService = /** @class */ (function () {
    function WizardService(defaultWizardActionStrategy, stringUtils) {
        this.defaultWizardActionStrategy = defaultWizardActionStrategy;
        this.stringUtils = stringUtils;
        // the overridable callbacks
        this.onLoadStep = function (index, nextStep) {
            return;
        };
        this.onClose = function (result) {
            return;
        };
        this.onCancel = function () {
            return;
        };
        this.onStepsUpdated = function (steps) {
            return;
        };
    }
    /* @internal */
    WizardService.prototype.initialize = function (conf) {
        this.validateConfig(conf);
        this._actionStrategy = conf.actionStrategy || this.defaultWizardActionStrategy;
        this._actionStrategy.applyStrategy(this, conf);
        this._currentIndex = 0;
        this._conf = __assign({}, conf);
        this._steps = this._conf.steps;
        this._getResult = conf.resultFn;
        this.validateStepUids(this._steps);
        this.goToStepWithIndex(0);
    };
    /* @internal */
    WizardService.prototype.executeAction = function (action) {
        var _this = this;
        if (action.executeIfCondition) {
            var result = action.executeIfCondition();
            return (result instanceof Promise ? result : Promise.resolve(result)).then(function () {
                return action.execute(_this);
            });
        }
        return Promise.resolve(action.execute(this));
    };
    /**
     * Navigates the wizard to the given step.
     * @param index The 0-based index from the steps array returned by the wizard controllers getWizardConfig() function
     */
    WizardService.prototype.goToStepWithIndex = function (index) {
        var nextStep = this.getStepWithIndex(index);
        if (nextStep) {
            this.onLoadStep(index, nextStep);
            this._currentIndex = index;
        }
    };
    /**
     * Navigates the wizard to the given step.
     * @param id The ID of a step returned by the wizard controllers getWizardConfig() function. Note that if
     * no id was provided for a given step, then one is automatically generated.
     */
    WizardService.prototype.goToStepWithId = function (id) {
        this.goToStepWithIndex(this.getStepIndexFromId(id));
    };
    /**
     * Adds an additional step to the wizard at runtime
     * @param index (OPTIONAL) A 0-based index position in the steps array. Default is 0.
     */
    WizardService.prototype.addStep = function (newStep, index) {
        if (parseInt(newStep.id, 10) !== 0 && !newStep.id) {
            newStep.id = this.stringUtils.generateIdentifier();
        }
        if (!index) {
            index = 0;
        }
        if (this._currentIndex >= index) {
            this._currentIndex++;
        }
        this._steps.splice(index, 0, newStep);
        this.validateStepUids(this._steps);
        this._actionStrategy.applyStrategy(this, this._conf);
        this.onStepsUpdated(this._steps);
    };
    /**
     * Remove a step form the wizard at runtime. If you are removing the currently displayed step, the
     * wizard will return to the first step. Removing all the steps will result in an error.
     */
    WizardService.prototype.removeStepById = function (id) {
        this.removeStepByIndex(this.getStepIndexFromId(id));
    };
    /**
     * Remove a step form the wizard at runtime. If you are removing the currently displayed step, the
     * wizard will return to the first step. Removing all the steps will result in an error.
     * @param index The 0-based index of the step you wish to remove.
     */
    WizardService.prototype.removeStepByIndex = function (index) {
        if (index >= 0 && index < this.getStepsCount()) {
            this._steps.splice(index, 1);
            if (index === this._currentIndex) {
                this.goToStepWithIndex(0);
            }
            this._actionStrategy.applyStrategy(this, this._conf);
            this.onStepsUpdated(this._steps);
        }
    };
    /**
     * Close the wizard. This will return a resolved promise to the creator of the wizard, and if any
     * resultFn was provided in the {@link ModalWizardConfig} the returned
     * value of this function will be passed as the result.
     */
    WizardService.prototype.close = function () {
        var result;
        if (typeof this._getResult === 'function') {
            result = this._getResult();
        }
        this.onClose(result);
    };
    /**
     * Cancel the wizard. This will return a rejected promise to the creator of the wizard.
     */
    WizardService.prototype.cancel = function () {
        this.onCancel();
    };
    WizardService.prototype.getSteps = function () {
        return this._steps;
    };
    WizardService.prototype.getStepIndexFromId = function (id) {
        var index = this._steps.findIndex(function (step) { return step.id === id; });
        return index;
    };
    /**
     * @returns True if the ID exists in one of the steps
     */
    WizardService.prototype.containsStep = function (stepId) {
        return this.getStepIndexFromId(stepId) >= 0;
    };
    WizardService.prototype.getCurrentStepId = function () {
        return this.getCurrentStep().id;
    };
    WizardService.prototype.getCurrentStepIndex = function () {
        return this._currentIndex;
    };
    WizardService.prototype.getCurrentStep = function () {
        return this.getStepWithIndex(this._currentIndex);
    };
    /**
     * @returns The number of steps in the wizard. This should always be equal to the size of the array.
     * returned by [getSteps]{@link WizardManager#getSteps}.
     */
    WizardService.prototype.getStepsCount = function () {
        return this._steps.length;
    };
    WizardService.prototype.getStepWithId = function (id) {
        var index = this.getStepIndexFromId(id);
        if (index >= 0) {
            return this.getStepWithIndex(index);
        }
        return null;
    };
    WizardService.prototype.getStepWithIndex = function (index) {
        if (index >= 0 && index < this.getStepsCount()) {
            return this._steps[index];
        }
        throw new Error('wizardService.getStepForIndex - Index out of bounds: ' + index);
    };
    WizardService.prototype.validateConfig = function (config) {
        if (!config.steps || config.steps.length <= 0) {
            throw new Error('Invalid WizardService configuration - no steps provided');
        }
        config.steps.forEach(function (step) {
            if (!step.templateUrl && !step.component) {
                throw new Error("Invalid WizardService configuration - Step missing a templateUrl or component: " + step);
            }
        });
    };
    WizardService.prototype.validateStepUids = function (steps) {
        var _this = this;
        var stepIds = {};
        steps.forEach(function (step) {
            if (!step.id) {
                step.id = _this.stringUtils.generateIdentifier();
            }
            else if (stepIds[step.id]) {
                throw new Error("Invalid (Duplicate) step id: " + step.id);
            }
            else {
                stepIds[step.id] = step.id;
            }
        });
    };
    return WizardService;
}());

/**
 * @ignore
 */
var CompileHtml = /** @class */ (function () {
    function CompileHtml(elementRef, renderer, upgrade) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.upgrade = upgrade;
    }
    CompileHtml.prototype.ngOnChanges = function (changes) {
        var templateChanged = this.hasInputChanged(changes.template);
        var scopeChanged = this.hasInputChanged(changes.scope);
        this.template = templateChanged ? changes.template.currentValue : this.template;
        if (this.template && (scopeChanged || templateChanged)) {
            this.setCompiledHTML();
        }
    };
    CompileHtml.prototype.ngOnDestroy = function () {
        this.resetScope();
        this.removeCompiledHTML();
    };
    CompileHtml.prototype.resetScope = function () {
        if (this.$scope) {
            this.$scope.$destroy();
        }
    };
    CompileHtml.prototype.removeCompiledHTML = function () {
        if (this.elementRef.nativeElement.firstChild) {
            this.renderer.removeChild(this.elementRef.nativeElement, this.elementRef.nativeElement.firstChild);
        }
    };
    CompileHtml.prototype.hasInputChanged = function (change) {
        return !!change && !lodash.isEqual(change.previousValue, change.currentValue);
    };
    CompileHtml.prototype.setCompiledHTML = function () {
        this.removeCompiledHTML();
        this.resetScope();
        this.renderer.appendChild(this.elementRef.nativeElement, this.compile());
    };
    CompileHtml.prototype.compile = function () {
        var template = this.isTemplateUrl(this.template)
            ? this.$templateCache.get(this.template)
            : this.template;
        this.$scope = this.$rootScope.$new(false);
        if (!template) {
            throw new Error("did not find cached template for file " + this.template + " when building tab");
        }
        Object.assign(this.$scope, this.scope || {});
        if (this.compileHtmlNgController) {
            this.$scope[this.compileHtmlNgController.alias] = this;
            template = this.wrapTemplateIntoNgController(template, this.compileHtmlNgController.alias);
        }
        return this.$compile(template)(this.$scope)[0];
    };
    CompileHtml.prototype.wrapTemplateIntoNgController = function (template, controllerAlias) {
        return "<div ng-controller=\"" + controllerAlias + ".compileHtmlNgController.value as " + controllerAlias + "\">" + template + "</div>";
    };
    CompileHtml.prototype.isTemplateUrl = function (template) {
        return /.html$/.test(template);
    };
    Object.defineProperty(CompileHtml.prototype, "$templateCache", {
        get: function () {
            return this.upgrade.$injector.get('$templateCache');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CompileHtml.prototype, "$compile", {
        get: function () {
            return this.upgrade.$injector.get('$compile');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CompileHtml.prototype, "$rootScope", {
        get: function () {
            return this.upgrade.$injector.get('$rootScope');
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], CompileHtml.prototype, "scope", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], CompileHtml.prototype, "compileHtmlNgController", void 0);
    return CompileHtml;
}());

/**
 *  Used as support for legacy AngularJS templates in Angular components.
 *
 *  Compiles the template provided by the HTML Template string and scope.
 */
var CompileHtmlDirective = /** @class */ (function (_super) {
    __extends(CompileHtmlDirective, _super);
    function CompileHtmlDirective(elementRef, renderer, upgrade) {
        return _super.call(this, elementRef, renderer, upgrade) || this;
    }
    CompileHtmlDirective.prototype.ngOnChanges = function (changes) {
        changes.template = changes.seCompileHtml;
        _super.prototype.ngOnChanges.call(this, changes);
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], CompileHtmlDirective.prototype, "seCompileHtml", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], CompileHtmlDirective.prototype, "scope", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], CompileHtmlDirective.prototype, "compileHtmlNgController", void 0);
    CompileHtmlDirective = __decorate([
        core.Directive({ selector: '[seCompileHtml]' }),
        __metadata("design:paramtypes", [core.ElementRef, core.Renderer2, _static.UpgradeModule])
    ], CompileHtmlDirective);
    return CompileHtmlDirective;
}(CompileHtml));

/**
 *  Used as support for legacy AngularJS templates in Angular components.
 *
 *  Compiles the template provided by the templateUrl and scope.
 */
var NgIncludeDirective = /** @class */ (function (_super) {
    __extends(NgIncludeDirective, _super);
    function NgIncludeDirective(elementRef, renderer, upgrade) {
        return _super.call(this, elementRef, renderer, upgrade) || this;
    }
    NgIncludeDirective.prototype.ngOnChanges = function (changes) {
        changes.template = changes.ngInclude;
        _super.prototype.ngOnChanges.call(this, changes);
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], NgIncludeDirective.prototype, "ngInclude", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], NgIncludeDirective.prototype, "scope", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], NgIncludeDirective.prototype, "compileHtmlNgController", void 0);
    NgIncludeDirective = __decorate([
        core.Directive({ selector: '[ngInclude]' }),
        __metadata("design:paramtypes", [core.ElementRef, core.Renderer2, _static.UpgradeModule])
    ], NgIncludeDirective);
    return NgIncludeDirective;
}(CompileHtml));

var CompileHtmlModule = /** @class */ (function () {
    function CompileHtmlModule() {
    }
    CompileHtmlModule = __decorate([
        core.NgModule({
            declarations: [NgIncludeDirective, CompileHtmlDirective],
            exports: [NgIncludeDirective, CompileHtmlDirective]
        })
    ], CompileHtmlModule);
    return CompileHtmlModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "ModalWizardNavBarComponent", {
    selector: 'se-modal-wizard-nav-bar',
    template: "\n        <div class=\"se-modal-wizard__steps-container\" *ngIf=\"navActions\">\n            <div *ngFor=\"let action of navActions; let isLast = last\" class=\"se-modal-wizard__step\">\n                <button\n                    [attr.id]=\"action.id\"\n                    [ngClass]=\"{\n                        'se-modal-wizard-step__action--enabled': action.enableIfCondition(),\n                        'se-modal-wizard-step__action--disabled': !action.enableIfCondition(),\n                        'se-modal-wizard-step__action--current': action.isCurrentStep()\n                    }\"\n                    class=\"se-modal-wizard-step__action\"\n                    (click)=\"onClickAction(action)\"\n                    [disabled]=\"!action.enableIfCondition()\"\n                >\n                    {{ action.i18n | translate }}\n                </button>\n                <span\n                    *ngIf=\"!isLast\"\n                    [ngClass]=\"{\n                        'se-modal-wizard__step-icon-next--enabled': action.enableIfCondition(),\n                        'se-modal-wizard__step-icon-next--disabled': !action.enableIfCondition()\n                    }\"\n                    class=\"sap-icon--navigation-right-arrow se-modal-wizard__step-icon-next\"\n                >\n                </span>\n            </div>\n        </div>\n    "
});
var ModalWizardNavBarComponent = /** @class */ (function () {
    function ModalWizardNavBarComponent() {
        this.executeAction = new core.EventEmitter();
    }
    ModalWizardNavBarComponent.prototype.onClickAction = function (action) {
        this.executeAction.emit(action);
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], ModalWizardNavBarComponent.prototype, "navActions", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], ModalWizardNavBarComponent.prototype, "executeAction", void 0);
    ModalWizardNavBarComponent = __decorate([
        core.Component({
            selector: 'se-modal-wizard-nav-bar',
            template: "\n        <div class=\"se-modal-wizard__steps-container\" *ngIf=\"navActions\">\n            <div *ngFor=\"let action of navActions; let isLast = last\" class=\"se-modal-wizard__step\">\n                <button\n                    [attr.id]=\"action.id\"\n                    [ngClass]=\"{\n                        'se-modal-wizard-step__action--enabled': action.enableIfCondition(),\n                        'se-modal-wizard-step__action--disabled': !action.enableIfCondition(),\n                        'se-modal-wizard-step__action--current': action.isCurrentStep()\n                    }\"\n                    class=\"se-modal-wizard-step__action\"\n                    (click)=\"onClickAction(action)\"\n                    [disabled]=\"!action.enableIfCondition()\"\n                >\n                    {{ action.i18n | translate }}\n                </button>\n                <span\n                    *ngIf=\"!isLast\"\n                    [ngClass]=\"{\n                        'se-modal-wizard__step-icon-next--enabled': action.enableIfCondition(),\n                        'se-modal-wizard__step-icon-next--disabled': !action.enableIfCondition()\n                    }\"\n                    class=\"sap-icon--navigation-right-arrow se-modal-wizard__step-icon-next\"\n                >\n                </span>\n            </div>\n        </div>\n    "
        })
    ], ModalWizardNavBarComponent);
    return ModalWizardNavBarComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "ModalWizardStepOutletComponent", {
    selector: 'se-modal-wizard-step-outlet',
    template: "\n        <!-- AngularJS -->\n\n        <ng-container *ngIf=\"steps && steps.length > 0\">\n            <ng-container *ngFor=\"let step of steps\">\n                <div\n                    [ngClass]=\"{\n                        'se-modal-wizard__content--visible': isActive(step)\n                    }\"\n                    class=\"se-modal-wizard__content\"\n                >\n                    <!-- AngularJS -->\n\n                    <div\n                        *ngIf=\"!!step.templateUrl\"\n                        [ngInclude]=\"step.templateUrl\"\n                        [compileHtmlNgController]=\"compileHtmlNgController\"\n                    ></div>\n\n                    <!-- Angular -->\n\n                    <div *ngIf=\"step.component\">\n                        <ng-container\n                            *ngComponentOutlet=\"step.component; injector: wizardApiInjector\"\n                        ></ng-container>\n                    </div>\n                </div>\n            </ng-container>\n        </ng-container>\n    "
});
var ModalWizardStepOutletComponent = /** @class */ (function () {
    function ModalWizardStepOutletComponent() {
    }
    ModalWizardStepOutletComponent.prototype.isActive = function (step) {
        return this.wizardService.getCurrentStepId() === step.id;
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], ModalWizardStepOutletComponent.prototype, "steps", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ModalWizardStepOutletComponent.prototype, "compileHtmlNgController", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", WizardService)
    ], ModalWizardStepOutletComponent.prototype, "wizardService", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Injector)
    ], ModalWizardStepOutletComponent.prototype, "wizardApiInjector", void 0);
    ModalWizardStepOutletComponent = __decorate([
        core.Component({
            selector: 'se-modal-wizard-step-outlet',
            template: "\n        <!-- AngularJS -->\n\n        <ng-container *ngIf=\"steps && steps.length > 0\">\n            <ng-container *ngFor=\"let step of steps\">\n                <div\n                    [ngClass]=\"{\n                        'se-modal-wizard__content--visible': isActive(step)\n                    }\"\n                    class=\"se-modal-wizard__content\"\n                >\n                    <!-- AngularJS -->\n\n                    <div\n                        *ngIf=\"!!step.templateUrl\"\n                        [ngInclude]=\"step.templateUrl\"\n                        [compileHtmlNgController]=\"compileHtmlNgController\"\n                    ></div>\n\n                    <!-- Angular -->\n\n                    <div *ngIf=\"step.component\">\n                        <ng-container\n                            *ngComponentOutlet=\"step.component; injector: wizardApiInjector\"\n                        ></ng-container>\n                    </div>\n                </div>\n            </ng-container>\n        </ng-container>\n    "
        })
    ], ModalWizardStepOutletComponent);
    return ModalWizardStepOutletComponent;
}());

var DEFAULT_WIZARD_ACTION = {
    id: 'wizard_action_id',
    i18n: 'wizard_action_label',
    isMainAction: true,
    enableIfCondition: function () {
        return true;
    },
    executeIfCondition: function () {
        return true;
    },
    execute: function (wizardService) {
        return;
    }
};
/* @internal */
var /* @ngInject */ WizardActions = /** @class */ (function () {
    function /* @ngInject */ WizardActions() {
    }
    /* @ngInject */ WizardActions.prototype.customAction = function (configuration) {
        return this.createNewAction(configuration);
    };
    WizardActions.prototype.customAction.$inject = ["configuration"];
    /* @ngInject */ WizardActions.prototype.done = function (configuration) {
        var custom = {
            id: 'ACTION_DONE',
            i18n: 'se.action.done',
            execute: function (wizardService) {
                wizardService.close();
            }
        };
        return this.createNewAction(configuration, custom);
    };
    WizardActions.prototype.done.$inject = ["configuration"];
    /* @ngInject */ WizardActions.prototype.next = function (configuration) {
        var custom = {
            id: 'ACTION_NEXT',
            i18n: 'se.action.next',
            execute: function (wizardService) {
                wizardService.goToStepWithIndex(wizardService.getCurrentStepIndex() + 1);
            }
        };
        return this.createNewAction(configuration, custom);
    };
    WizardActions.prototype.next.$inject = ["configuration"];
    /* @ngInject */ WizardActions.prototype.navBarAction = function (configuration) {
        if (!configuration.wizardService || configuration.destinationIndex === null) {
            throw new Error('Error initializating navBarAction, must provide the wizardService and destinationIndex fields');
        }
        var custom = {
            id: 'ACTION_GOTO',
            i18n: 'action.goto',
            enableIfCondition: function () {
                return configuration.wizardService.getCurrentStepIndex() >= configuration.destinationIndex;
            },
            execute: function (wizardService) {
                wizardService.goToStepWithIndex(configuration.destinationIndex);
            }
        };
        return this.createNewAction(configuration, custom);
    };
    WizardActions.prototype.navBarAction.$inject = ["configuration"];
    /* @ngInject */ WizardActions.prototype.back = function (configuration) {
        var custom = {
            id: 'ACTION_BACK',
            i18n: 'se.action.back',
            isMainAction: false,
            execute: function (wizardService) {
                var currentIndex = wizardService.getCurrentStepIndex();
                if (currentIndex <= 0) {
                    throw new Error('Failure to execute BACK action, no previous index exists!');
                }
                wizardService.goToStepWithIndex(currentIndex - 1);
            }
        };
        return this.createNewAction(configuration, custom);
    };
    WizardActions.prototype.back.$inject = ["configuration"];
    /* @ngInject */ WizardActions.prototype.cancel = function () {
        return this.createNewAction({
            id: 'ACTION_CANCEL',
            i18n: 'se.action.cancel',
            isMainAction: false,
            execute: function (wizardService) {
                wizardService.cancel();
            }
        });
    };
    /* @ngInject */ WizardActions.prototype.createNewAction = function (configuration, customConfiguration) {
        if (configuration === void 0) { configuration = null; }
        if (customConfiguration === void 0) { customConfiguration = null; }
        return __assign(__assign(__assign({}, DEFAULT_WIZARD_ACTION), customConfiguration), configuration);
    };
    WizardActions.prototype.createNewAction.$inject = ["configuration", "customConfiguration"];
    /* @ngInject */ WizardActions = __decorate([
        SeDowngradeService()
    ], /* @ngInject */ WizardActions);
    return /* @ngInject */ WizardActions;
}());

/* @internal */
var /* @ngInject */ DefaultWizardActionStrategy = /** @class */ (function () {
    DefaultWizardActionStrategy.$inject = ["wizardActions"];
    function /* @ngInject */ DefaultWizardActionStrategy(wizardActions) {
        this.wizardActions = wizardActions;
    }
    /* @ngInject */ DefaultWizardActionStrategy.prototype.applyStrategy = function (wizardService, conf) {
        var nextAction = this.applyOverrides(wizardService, this.wizardActions.next(), conf.nextLabel, conf.onNext, conf.isFormValid);
        var doneAction = this.applyOverrides(wizardService, this.wizardActions.done(), conf.doneLabel, conf.onDone, conf.isFormValid);
        var backConf = conf.backLabel
            ? {
                i18n: conf.backLabel
            }
            : null;
        var backAction = this.wizardActions.back(backConf);
        conf.steps.forEach(function (step, index) {
            step.actions = [];
            if (index > 0) {
                step.actions.push(backAction);
            }
            if (index === conf.steps.length - 1) {
                step.actions.push(doneAction);
            }
            else {
                step.actions.push(nextAction);
            }
        });
        conf.cancelAction = this.applyOverrides(wizardService, this.wizardActions.cancel(), conf.cancelLabel, conf.onCancel, null);
        conf.templateOverride = 'modalWizardNavBarTemplate.html';
    };
    DefaultWizardActionStrategy.prototype.applyStrategy.$inject = ["wizardService", "conf"];
    /* @ngInject */ DefaultWizardActionStrategy.prototype.applyOverrides = function (wizardService, action, label, executeCondition, enableCondition) {
        if (label) {
            action.i18n = label;
        }
        if (executeCondition) {
            action.executeIfCondition = function () {
                return executeCondition(wizardService.getCurrentStepId());
            };
        }
        if (enableCondition) {
            action.enableIfCondition = function () {
                return enableCondition(wizardService.getCurrentStepId());
            };
        }
        return action;
    };
    DefaultWizardActionStrategy.prototype.applyOverrides.$inject = ["wizardService", "action", "label", "executeCondition", "enableCondition"];
    /* @ngInject */ DefaultWizardActionStrategy = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [WizardActions])
    ], /* @ngInject */ DefaultWizardActionStrategy);
    return /* @ngInject */ DefaultWizardActionStrategy;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
window.__smartedit__.addDecoratorPayload("Component", "ModalWizardTemplateComponent", {
    selector: 'se-modal-wizard-template',
    template: "\n        <div id=\"yModalWizard\">\n            <div class=\"se-modal-wizard-template\">\n                <se-modal-wizard-nav-bar\n                    [navActions]=\"_wizardContext?.navActions\"\n                    (executeAction)=\"executeAction($event)\"\n                ></se-modal-wizard-nav-bar>\n                <se-modal-wizard-step-outlet\n                    [steps]=\"_wizardContext?._steps\"\n                    [compileHtmlNgController]=\"legacyController\"\n                    [wizardService]=\"wizardService\"\n                    [wizardApiInjector]=\"wizardInjector\"\n                ></se-modal-wizard-step-outlet>\n            </div>\n        </div>\n    "
});
var ModalWizardTemplateComponent = /** @class */ (function () {
    function ModalWizardTemplateComponent(modalManager, wizardActions, defaultWizardActionStrategy, upgrade, componentFactoryResolver, injector) {
        this.modalManager = modalManager;
        this.wizardActions = wizardActions;
        this.defaultWizardActionStrategy = defaultWizardActionStrategy;
        this.upgrade = upgrade;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    ModalWizardTemplateComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.modalManager.getModalData().subscribe(function (config) {
            _this.wizardService = new WizardService(_this.defaultWizardActionStrategy, stringUtils);
            _this.wizardService.properties = config.properties;
            _this.assignExternalController(config);
            if (typeof _this.getWizardConfig !== 'function') {
                throw new Error('The provided controller must provide a getWizardConfig() function.');
            }
            var modalConfig = _this.getWizardConfig();
            _this._wizardContext = {
                _steps: modalConfig.steps
            };
            _this.executeAction = function (action) {
                _this.wizardService.executeAction(action);
            };
            _this.wizardService.onLoadStep = function (stepIndex, step) {
                _this.modalManager.setTitle(step.title);
                if (step.templateUrl) {
                    _this._wizardContext.templateUrl = step.templateUrl;
                }
                else if (step.component) {
                    _this._wizardContext.component = step.component;
                }
                _this.modalManager.removeAllButtons();
                var buttonsConfig = (step.actions || []).map(function (action) {
                    return _this.convertActionToButtonConf(action);
                });
                _this.modalManager.addButtons(buttonsConfig);
            };
            _this.wizardService.onClose = function (result) {
                _this.modalManager.close(result);
            };
            _this.wizardService.onCancel = function () {
                _this.modalManager.close();
            };
            _this.wizardService.onStepsUpdated = function (steps) {
                _this.setupNavBar(steps);
                _this._wizardContext._steps = steps;
            };
            _this.wizardService.initialize(modalConfig);
            _this.setupModal(modalConfig);
        });
    };
    ModalWizardTemplateComponent.prototype.setupNavBar = function (steps) {
        var _this = this;
        this._wizardContext.navActions = steps.map(function (step, index) {
            var action = _this.wizardActions.navBarAction({
                id: 'NAV-' + step.id,
                stepIndex: index,
                wizardService: _this.wizardService,
                destinationIndex: index,
                i18n: step.name,
                isCurrentStep: function () { return action.stepIndex === _this.wizardService.getCurrentStepIndex(); }
            });
            return action;
        });
    };
    ModalWizardTemplateComponent.prototype.setupModal = function (setupConfig) {
        var _this = this;
        this._wizardContext.templateOverride = setupConfig.templateOverride;
        if (setupConfig.cancelAction) {
            this.modalManager.setDismissCallback(function () {
                return _this.wizardService.executeAction(setupConfig.cancelAction);
            });
        }
        this.setupNavBar(setupConfig.steps);
    };
    ModalWizardTemplateComponent.prototype.convertActionToButtonConf = function (action) {
        var _this = this;
        return {
            id: action.id,
            style: action.isMainAction
                ? utils.FundamentalModalButtonStyle.Primary
                : utils.FundamentalModalButtonStyle.Default,
            label: action.i18n,
            action: utils.FundamentalModalButtonAction.None,
            disabledFn: function () { return !action.enableIfCondition(); },
            callback: function () {
                _this.wizardService.executeAction(action);
                return rxjs.of(null);
            }
        };
    };
    ModalWizardTemplateComponent.prototype.assignExternalController = function (config) {
        if (config.controller) {
            this.assignLegacyController(config);
        }
        if (config.component) {
            this.assignAngularController(config);
        }
    };
    ModalWizardTemplateComponent.prototype.assignLegacyController = function (config) {
        var _this = this;
        lodash.assign(this, this.$controller(config.controller, {
            wizardManager: this.wizardService
        }));
        this.legacyController = {
            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
            value: function () { return _this; },
            alias: config.controllerAs
        };
    };
    ModalWizardTemplateComponent.prototype.assignAngularController = function (config) {
        var injector = core.Injector.create({
            providers: [{ provide: WIZARD_MANAGER, useValue: this.wizardService }],
            parent: this.injector
        });
        var factory = this.componentFactoryResolver.resolveComponentFactory(config.component);
        var createdComponent = factory.create(injector).instance;
        lodash.assign(this, createdComponent);
        this.wizardInjector = core.Injector.create({
            providers: [{ provide: WIZARD_API, useValue: createdComponent }],
            parent: this.injector
        });
    };
    Object.defineProperty(ModalWizardTemplateComponent.prototype, "$controller", {
        get: function () {
            return this.upgrade.$injector.get('$controller');
        },
        enumerable: false,
        configurable: true
    });
    ModalWizardTemplateComponent = __decorate([
        core.Component({
            selector: 'se-modal-wizard-template',
            template: "\n        <div id=\"yModalWizard\">\n            <div class=\"se-modal-wizard-template\">\n                <se-modal-wizard-nav-bar\n                    [navActions]=\"_wizardContext?.navActions\"\n                    (executeAction)=\"executeAction($event)\"\n                ></se-modal-wizard-nav-bar>\n                <se-modal-wizard-step-outlet\n                    [steps]=\"_wizardContext?._steps\"\n                    [compileHtmlNgController]=\"legacyController\"\n                    [wizardService]=\"wizardService\"\n                    [wizardApiInjector]=\"wizardInjector\"\n                ></se-modal-wizard-step-outlet>\n            </div>\n        </div>\n    "
        }),
        __metadata("design:paramtypes", [utils.FundamentalModalManagerService,
            WizardActions,
            DefaultWizardActionStrategy,
            _static.UpgradeModule,
            core.ComponentFactoryResolver,
            core.Injector])
    ], ModalWizardTemplateComponent);
    return ModalWizardTemplateComponent;
}());

/**
 * Used to create wizards that are embedded into the {@link ModalService}.
 */
var /* @ngInject */ ModalWizard = /** @class */ (function () {
    ModalWizard.$inject = ["modalService"];
    function /* @ngInject */ ModalWizard(modalService) {
        this.modalService = modalService;
    }
    /**
     * Open provides a simple way to create modal wizards, with much of the boilerplate taken care of for you
     * such as look, feel and wizard navigation.
     *
     * @returns Promise that will either be resolved (wizard finished) or
     * rejected (wizard cancelled).
     */
    /* @ngInject */ ModalWizard.prototype.open = function (config) {
        var _this = this;
        this.validateConfig(config);
        return new Promise(function (resolve, reject) {
            var ref = _this.modalService.open({
                component: ModalWizardTemplateComponent,
                templateConfig: { isDismissButtonVisible: true },
                data: config,
                config: {
                    focusTrapped: false,
                    backdropClickCloseable: false
                }
            });
            ref.afterClosed.subscribe(resolve, reject);
        });
    };
    ModalWizard.prototype.open.$inject = ["config"];
    /* @ngInject */ ModalWizard.prototype.validateConfig = function (config) {
        if (!config.controller && !config.component) {
            throw new Error('WizardService - initialization exception. No controller nor component provided');
        }
        if (config.controller && config.component) {
            throw new Error('WizardService - initialization exception. Provide either controller or component');
        }
    };
    ModalWizard.prototype.validateConfig.$inject = ["config"];
    /* @ngInject */ ModalWizard = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.IModalService])
    ], /* @ngInject */ ModalWizard);
    return /* @ngInject */ ModalWizard;
}());

/**
 * Module containing all wizard related services
 * # Creating a modal wizard in a few simple steps
 *
 * For AngularJS usage:
 *
 * 1. Inject {@link ModalWizard} where you want to use the wizard.
 * 2. Create a new controller for your wizard. This controller will be used for all steps of the wizard.
 * 3. Implement a function in your new controller called getWizardConfig that returns a {@link ModalWizardConfig}
 * 4. Use [open]{@link ModalWizard#open} method, passing in your new controller
 *
 * For Angular usage
 * 1. Import WizardModule from "smarteditcommons" to your module imports
 * 2. Inject {@link ModalWizard} using ModalWizard constructor from "smarteditcommons".
 * 3. Create a new component controller for your wizard. This component will be used for all steps of the wizard.
 * 4. Create step components to be rendered inside the wizard. If access to component controller is needed, inject the parent reference
 * 5. Implement a method in your new controller called getWizardConfig that returns a {@link ModalWizardConfig}
 * 6. Use [open]{@link ModalWizard#open} method, passing in your new controller
 *
 * ### Example AngularJS
 *
 *      \@SeInjectable()
 *      export class MyAngularJsWizardService {
 * 		    constructor(private modalWizard) {}
 * 		    open() {
 * 			    this.modalWizard.open({
 * 				    controller: (wizardManager: any) => {
 * 					    'ngInject';
 * 					    return {
 * 						        steps: [{
 * 							    id: 'step1',
 * 							    name: 'i18n.step1.name',
 * 							    title: 'i18n.step1.title',
 * 							    templateUrl: 'some/template1.html'
 * 						    }, {
 * 							    id: 'step2',
 * 							    name: 'i18n.step2.name',
 * 							    title: 'i18n.step2.title',
 * 							    templateUrl: 'some/template2.html'
 * 						    }]
 * 					    };
 * 				    }
 * 			    });
 * 		    }
 *      }
 *
 * ### Example Angular
 *
 *      export class MyAngularWizardService {
 * 		    constructor(private modalWizard: ModalWizard) {}
 * 		    open() {
 * 			    this.modalWizard.open({
 *                  component: MyWizardControllerComponent,
 * 			    });
 * 		    }
 *      }
 *
 */
var WizardModule = /** @class */ (function () {
    function WizardModule() {
    }
    WizardModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, CompileHtmlModule, core$1.TranslateModule],
            providers: [ModalWizard, WizardActions, DefaultWizardActionStrategy],
            declarations: [
                ModalWizardTemplateComponent,
                ModalWizardNavBarComponent,
                ModalWizardStepOutletComponent
            ],
            entryComponents: [
                ModalWizardTemplateComponent,
                ModalWizardNavBarComponent,
                ModalWizardStepOutletComponent
            ]
        })
    ], WizardModule);
    return WizardModule;
}());

/** @internal */
function $exceptionHandler($log) {
    'ngInject';
    var ignorePatterns = [/^Possibly unhandled rejection/];
    var patternsForE2EErrorLogs = [
        /Unexpected request/,
        /No more request expected/ // missing http mock patterns in e2e
    ];
    return function exceptionHandler(exception, cause) {
        /*
         * original exception occuring in a promise based API won't show here
         * the catch set in decoration is necessary to log them
         */
        if (ignorePatterns.some(function (pattern) { return pattern.test(exception); })) {
            return;
        }
        if (patternsForE2EErrorLogs.some(function (pattern) { return pattern.test(exception); })) {
            $log.error("E2E mock issue: " + exception);
            return;
        }
        $log.error(exception);
    };
}
function isAjaxError(error) {
    return error.hasOwnProperty('headers');
}
/*
 * Helper function used on all known promise based Angular 1.6 APIs
 * to handle promise rejection in an AOP fashion through Angular decorators
 */
function handlePromiseRejections($q, $log, lodash, promise) {
    var defaultFailureCallback = function (error) {
        if (undefined !== error && 'canceled' !== error) {
            if (lodash.isPlainObject(error)) {
                if (!isAjaxError(error)) {
                    $log.error("exception caught in promise: " + JSON.stringify(error));
                }
            }
            else if (!lodash.isBoolean(error)) {
                $log.error(error);
            }
        }
        return $q.reject(error);
    };
    var oldThen = promise.then;
    promise.then = function (successCallback, _failureCallback, notifyCallback) {
        var failureCallback = _failureCallback ? _failureCallback : defaultFailureCallback;
        return oldThen.call(this, successCallback, failureCallback, notifyCallback);
    };
    return promise;
}
/** @internal */
var /* @ngInject */ ConfigModule = /** @class */ (function () {
    function /* @ngInject */ ConfigModule() {
    }
    /* @ngInject */ ConfigModule = __decorate([
        SeModule({
            providers: [$exceptionHandler],
            /*
             * Decoration all known promise based Angular 1.6 APIs
             * to handle promise rejection in an AOP fashion
             */
            config: ["$qProvider", "$provide", function ($qProvider, $provide) {
                'ngInject';
                $qProvider.errorOnUnhandledRejections(true);
                $provide.decorator('$q', ["$delegate", "$log", "lodash", function ($delegate, $log, lodash) {
                    'ngInject';
                    var originalWhen = $delegate.when;
                    $delegate.when = function () {
                        if (arguments[0] && !arguments[0].then) {
                            return handlePromiseRejections($delegate, $log, lodash, originalWhen.apply(this, arguments));
                        }
                        else {
                            return originalWhen.apply(this, arguments);
                        }
                    };
                    var originalAll = $delegate.all;
                    $delegate.all = function () {
                        return handlePromiseRejections($delegate, $log, lodash, originalAll.apply($delegate, arguments));
                    };
                    var originalDefer = $delegate.defer;
                    $delegate.defer = function () {
                        var deferred = originalDefer.bind($delegate)();
                        handlePromiseRejections($delegate, $log, lodash, deferred.promise);
                        return deferred;
                    };
                    return $delegate;
                }]);
                $provide.decorator('$timeout', ["$delegate", "$q", "$log", "lodash", function ($delegate, $q, $log, lodash) {
                    'ngInject';
                    var originalTimeout = $delegate;
                    function wrappedTimeout() {
                        var p;
                        var args = arguments;
                        if (typeof window.Zone === 'function') {
                            new window.Zone().run(function () {
                                p = handlePromiseRejections($q, $log, lodash, originalTimeout.apply($delegate, args));
                            });
                        }
                        else {
                            p = handlePromiseRejections($q, $log, lodash, originalTimeout.apply($delegate, args));
                        }
                        return p;
                    }
                    lodash.merge(wrappedTimeout, originalTimeout);
                    return wrappedTimeout;
                }]);
            }]
        })
    ], /* @ngInject */ ConfigModule);
    return /* @ngInject */ ConfigModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ModalButtonActions;
(function (ModalButtonActions) {
    ModalButtonActions["None"] = "none";
    ModalButtonActions["Close"] = "close";
    ModalButtonActions["Dismiss"] = "dismiss";
})(ModalButtonActions || (ModalButtonActions = {}));

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ModalButtonStyles;
(function (ModalButtonStyles) {
    ModalButtonStyles["Default"] = "default";
    ModalButtonStyles["Primary"] = "primary";
})(ModalButtonStyles || (ModalButtonStyles = {}));

var defaultButtonOptions = {
    id: 'button.id',
    label: 'button.label',
    action: ModalButtonActions.None,
    style: ModalButtonStyles.Primary,
    disabled: false,
    callback: null
};

/**
 * The ModalManager is a service designed to provide easy runtime modification to various aspects of a modal window,
 * such as the modifying the title, adding a buttons, setting callbacks, etc...
 *
 * The ModalManager constructor is not exposed publicly, but an instance of ModalManager is added to the scope of
 * the modal content implicitly through the scope chain/prototyping. As long as you don't create an
 * {@link https://docs.angularjs.org/guide/scope isolated scope} for the modal, you can access it through $scope.modalManager
 *
 * ### Example
 *
 *       .controller('modalTestController', function($scope, $log) {
 *          var buttonHandlerFn = function (buttonId) {
 *              $log.debug("button with id", buttonId, "was pressed!");
 *          };
 *          $scope.modalManager.setButtonHandler(buttonHandlerFn);
 *          ...
 */
var ModalManager = /** @class */ (function () {
    function ModalManager(config, // specify interface
    $translate, modalInstance) {
        var _this = this;
        this.config = config;
        this.$translate = $translate;
        this.modalInstance = modalInstance;
        this.title = '';
        this.showDismissX = true;
        this.buttons = [];
        this._defaultButtonOptions = defaultButtonOptions;
        if (!this.modalInstance) {
            throw new Error('no.modalInstance.injected');
        }
        if (typeof this.config.title === 'string') {
            this.title = config.title;
        }
        if (typeof this.config.titleSuffix === 'string') {
            this.titleSuffix = config.titleSuffix;
        }
        if (this.config.buttons) {
            this.buttons = __spreadArrays(this.buttons, this.config.buttons.map(function (options) {
                return _this.createButton(options);
            }));
        }
        this.closeFunction = this.modalInstance.close;
        this.dismissFunction = this.modalInstance.dismiss;
    }
    /**
     * @returns Added button
     */
    ModalManager.prototype.addButton = function (newButtonConf) {
        var button = this.createButton(newButtonConf);
        this.buttons = __spreadArrays(this.buttons, [button]);
        return button;
    };
    /**
     * **Caution!**
     *
     * This is a reference to the buttons being used by the modal manager, not a clone. This should
     * only be used to read or update properties provided in the Button configuration.
     * See [addButton]{@link ModalManager#addButton} for more details.
     *
     * @returns An array of all the buttons on the modal window, empty array if there are no buttons.
     */
    ModalManager.prototype.getButtons = function () {
        return this.buttons;
    };
    ModalManager.prototype.removeAllButtons = function () {
        this.buttons = [];
    };
    ModalManager.prototype.removeButton = function (buttonId) {
        this.buttons = this.buttons.filter(function (options) { return options.id !== buttonId; });
    };
    /**
     * Enables a button on the modal window, allowing it to be pressed.
     */
    ModalManager.prototype.enableButton = function (buttonId) {
        this.buttons = this.buttons.map(function (options) {
            return options.id === buttonId ? __assign(__assign({}, options), { disabled: false }) : options;
        });
    };
    /**
     * Disables the button on the modal window, preventing it from being pressed.
     */
    ModalManager.prototype.disableButton = function (buttonId) {
        this.buttons = this.buttons.map(function (options) {
            return options.id === buttonId ? __assign(__assign({}, options), { disabled: true }) : options;
        });
    };
    /**
     * @returns The first button found with a matching id, otherwise null.
     */
    ModalManager.prototype.getButton = function (buttonId) {
        return this.buttons.find(function (options) { return options.id === buttonId; });
    };
    /**
     * Whether to display the "X" dismiss button at the top right corner of the modal window,
     * when the modal header is displayed.
     */
    ModalManager.prototype.setShowHeaderDismiss = function (showButton) {
        if (typeof showButton === 'boolean') {
            this.showDismissX = showButton;
        }
        else {
            throw new Error('modalService.ModalManager.showDismissX.illegal.param');
        }
    };
    /**
     * Sets the function to be called when the X dismiss button at the top right corner of the modal window
     * is pressed. This function must either return null or a promise.
     *
     * If the promise is resolved, or if the function returns null or undefined, then the modal is closed and the returned
     * modal promise is rejected.
     *
     * If the callback promise is rejected, the modal is not closed, allowing you to provide some kind of validation
     * before closing.
     */
    ModalManager.prototype.setDismissCallback = function (callback) {
        this.dismissCallback = callback;
    };
    /**
     * @param buttonHandlerFunction Callback function that is called when any button on the
     * modal, that has no [callback]{@link IModalButtonOptions#callback}, is pressed.
     * If a button has a [callback]{@link IModalButtonOptions#callback} function, then that function will be
     * that function will be called instead.
     *
     * This callback function receives a single parameter, which is the string ID of the button that was pressed.
     * Additionally, this function must either return null, undefined or a promise.
     *
     * If null/undefined is return, the modal will continue to process the Button Action.
     * In this case, no data will be returned to the modal promise if the modal is closed.
     *
     * If a promise is returned by this function, then the Button Action
     * may be cancelled/ignored by rejecting the promise. If the promise is resolved, the {@link ModalManager}
     * will continue to process the Button Action.
     *
     * If by resolving the promise returned by this callback function with data passed to the resolve, and the Button Action
     * is such that it results in the modal closing, then the modal promise is resolved or rejected with that same data. This allows you to pass data from this function
     * to the `modalService.open(...)` caller.
     *
     * See [for more details on the button callback]{@link IModalButtonOptions.callback}
     *
     *
     * A few scenarios for example:
     * #1 A button with a button callback is pressed.
     * <br/>Result: callback function is never called.
     *
     * #2 A button is pressed, callback function returns null
     * <br/>Result: The modal manager will execute any action on the button
     *
     * #3 A button is pressed, callback function returns a promise, that promise is rejected
     * <br/>Result: Modal Manager will ignore the button action and nothing else will happen
     *
     * #4 A button with a dismiss action is pressed, callback function returns a promise, and that promise is resolved with data "Hello"
     * <br/>Result: ModalManager will execute the dismiss action, closing the modal, and errorCallback of the modal promise, passing "Hello" as data
     *
     *
     * Code sample of validating some data before closing the modal
     *
     * ### Example
     *
     *      function validateSomething(): boolean {
     *          return true;
     *      };
     *
     *      function buttonHandlerFn (buttonId: string): Promise<any> {
     *         if (buttonId === 'submit') {
     *             const deferred = $q.defer();
     *             if (validateSomething()) {
     *               deferred.resolve("someResult");
     *              } else {
     *                  deferred.reject();  // cancel the submit button's close action
     *               }
     *              return deferred.promise;
     *           }
     *      };
     *
     *      $scope.modalManager.setButtonHandler(buttonHandlerFn);
     *
     */
    ModalManager.prototype.setButtonHandler = function (buttonHandlerFunction) {
        this.buttonEventCallback = buttonHandlerFunction;
    };
    /**
     * The close function will close the modal window, passing the provided data (if any) to the successCallback
     * of the modal promise by resolving the promise.
     *
     * @param data Any data to be returned to the resolved modal promise when the modal is closed.
     */
    ModalManager.prototype.close = function (dataToReturn) {
        if (this.closeFunction) {
            this.closeFunction(dataToReturn);
        }
    };
    /**
     * The dismiss function will close the modal window, rejecting the modal promise with the provided data.
     */
    ModalManager.prototype.dismiss = function (dataToReturn) {
        if (this.dismissFunction) {
            this.dismissFunction(dataToReturn);
        }
    };
    ModalManager.prototype._showDismissButton = function () {
        return this.showDismissX;
    };
    ModalManager.prototype._buttonPressed = function (button) {
        var _this = this;
        var callbackReturnedPromise;
        if (button.callback) {
            callbackReturnedPromise = button.callback();
        }
        else if (this.buttonEventCallback) {
            callbackReturnedPromise = this.buttonEventCallback(button.id);
        }
        if (button.action !== ModalButtonActions.None) {
            var exitFn_1 = button.action === ModalButtonActions.Close ? this.close : this.dismiss;
            if (callbackReturnedPromise) {
                callbackReturnedPromise.then(function (data) { return exitFn_1.call(_this, data); }).catch(lodash.noop);
            }
            else {
                exitFn_1.call(this);
            }
        }
        if (callbackReturnedPromise) {
            callbackReturnedPromise.then(lodash.noop).catch(lodash.noop);
        }
    };
    ModalManager.prototype._handleDismissButton = function () {
        var _this = this;
        if (this.dismissCallback) {
            this.dismissCallback()
                .then(function (result) { return _this.dismiss(result); })
                .catch(lodash.noop);
        }
        else {
            this.dismiss();
        }
    };
    ModalManager.prototype._hasButtons = function () {
        return this.buttons.length > 0;
    };
    ModalManager.prototype.createButton = function (buttonConfig) {
        var config = __assign(__assign({}, this._defaultButtonOptions), buttonConfig);
        this.$translate(buttonConfig.label || this._defaultButtonOptions.label).then(function (label) {
            config.label = label;
        });
        var styleValidated = Object.keys(ModalButtonStyles).some(function (key) { return ModalButtonStyles[key] === config.style; });
        var actionValidated = Object.keys(ModalButtonActions).some(function (key) { return ModalButtonActions[key] === config.action; });
        if (!styleValidated) {
            throw new Error('modalService.ModalManager._createButton.illegal.button.style');
        }
        if (!actionValidated) {
            throw new Error('modalService.ModalManager._createButton.illegal.button.action');
        }
        return config;
    };
    return ModalManager;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
function modalControllerClassFactory(conf) {
    // @ngInject
    var ModalController = /** @class */ (function () {
        ModalController.$inject = ["$scope", "$uibModalInstance", "$translate", "$controller", "$templateCache", "stringUtils"];
        function ModalController($scope, $uibModalInstance, $translate, $controller, $templateCache, stringUtils) {
            this.$scope = $scope;
            this.$uibModalInstance = $uibModalInstance;
            this.$translate = $translate;
            this.$controller = $controller;
            this.$templateCache = $templateCache;
            this.stringUtils = stringUtils;
            this._modalManager = new ModalManager(conf, this.$translate, this.$uibModalInstance);
            this.$scope.modalController = this;
            if (conf.controller) {
                angular$1.extend(this, this.$controller(conf.controller, {
                    $scope: $scope,
                    modalManager: this._modalManager
                }));
                if (this.init) {
                    this.init();
                }
            }
            if (conf.controllerAs) {
                this.$scope[conf.controllerAs] = this;
            }
            if (conf.templateInline) {
                this.templateUrl = 'modalTemplateKey' + btoa(this.stringUtils.generateIdentifier());
                this.$templateCache.put(this.templateUrl, conf.templateInline);
            }
            else {
                this.templateUrl = conf.templateUrl;
            }
        }
        ModalController.prototype.init = function () {
            // ModalController doensn't provide init implementation
        };
        ModalController.prototype.close = function (data) {
            this._modalManager.close(data);
            this.$templateCache.remove(this.templateUrl);
        };
        ModalController.prototype.dismiss = function (data) {
            this._modalManager.dismiss(data);
            this.$templateCache.remove(this.templateUrl);
        };
        ModalController.prototype._getModalType = function () {
            var type = conf.templateInline
                ? conf.inlineTemplateSelector
                : this.templateUrl.split('.')[0];
            return 'se-modal--' + type;
        };
        return ModalController;
    }());
    return ModalController;
}

window.__smartedit__.addDecoratorPayload("Injectable", "ModalService", { providedIn: 'root' });
/**
 * Service responsible for opening the modals after providing configuration
 */
var /* @ngInject */ ModalService = /** @class */ (function (_super) {
    __extends(/* @ngInject */ ModalService, _super);
    ModalService.$inject = ["fundamentalModalService", "upgrade"];
    function /* @ngInject */ ModalService(fundamentalModalService, upgrade) {
        var _this = _super.call(this, fundamentalModalService) || this;
        _this.fundamentalModalService = fundamentalModalService;
        _this.upgrade = upgrade;
        return _this;
    }
    /* @ngInject */ ModalService.prototype.hasOpenModals = function () {
        return !!this.$uibModalStack.getTop() || this.fundamentalModalService.hasOpenModals();
    };
    /**
     * Dismisses all instances of modals both produced by angular bootstrap ui and Fundamental
     */
    /* @ngInject */ ModalService.prototype.dismissAll = function () {
        if (this.$uibModalStack.getTop()) {
            this.$uibModalStack.dismissAll();
        }
        if (this.fundamentalModalService.hasOpenModals()) {
            this.fundamentalModalService.dismissAll();
        }
    };
    /* @ngInject */ ModalService.prototype.open = function (conf) {
        return conf.component
            ? _super.prototype.open.call(this, conf)
            : this.angularJSOpen(conf);
    };
    ModalService.prototype.open.$inject = ["conf"];
    /* @ngInject */ ModalService.prototype.angularJSOpen = function (conf) {
        var configuration = conf || {};
        if (configuration.templateUrl && configuration.templateInline) {
            throw new Error('modalService.configuration.errors.2.templates.provided');
        }
        return this.$uibModal.open({
            templateUrl: 'modalTemplate.html',
            size: configuration.size || 'lg',
            backdrop: 'static',
            keyboard: false,
            controller: modalControllerClassFactory(configuration),
            controllerAs: 'modalController',
            windowClass: configuration.cssClasses || null,
            animation: !conf.animation && this.$animate.enabled()
        }).result;
    };
    ModalService.prototype.angularJSOpen.$inject = ["conf"];
    Object.defineProperty(/* @ngInject */ ModalService.prototype, "$uibModalStack", {
        get: function () {
            return this.upgrade.$injector.get('$uibModalStack');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(/* @ngInject */ ModalService.prototype, "$uibModal", {
        get: function () {
            return this.upgrade.$injector.get('$uibModal');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(/* @ngInject */ ModalService.prototype, "$animate", {
        get: function () {
            return this.upgrade.$injector.get('$animate');
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ ModalService = __decorate([
        SeDowngradeService(),
        core.Injectable({ providedIn: 'root' }),
        __metadata("design:paramtypes", [core$2.ModalService,
            _static.UpgradeModule])
    ], /* @ngInject */ ModalService);
    return /* @ngInject */ ModalService;
}(utils.ModalService));

// eslint-disable-next-line @typescript-eslint/no-var-requires
var NgUiBootstrapModule = require('angular-ui-bootstrap'); // Only supports CommonJS
/**
 * Module containing {@link ModalService}.
 */
var /* @ngInject */ ModalServiceModule = /** @class */ (function () {
    function /* @ngInject */ ModalServiceModule() {
    }
    /* @ngInject */ ModalServiceModule = __decorate([
        SeModule({
            imports: [NgUiBootstrapModule, 'translationServiceModule', 'functionsModule', 'coretemplates'],
            providers: [
                {
                    /**
                     * Injectable angular constant<br/>
                     * Defines the action to be taken after executing a button on a modal window. To be used when adding a button to the modal,
                     * either when opening a modal (see [getButtons]{@link ModalManager#getButtons}) or
                     * when adding a button to an existing modal (see [open]{@link ModalService#open})
                     *
                     * ### Example
                     *
                     *      myModalManager.addButton({
                     *          id: 'button id',
                     *          label: 'close_modal',
                     *          action: MODAL_BUTTON_ACTIONS.CLOSE
                     *      });
                     *
                     */
                    provide: 'MODAL_BUTTON_ACTIONS',
                    useValue: {
                        /**
                         * Indicates to the {@link ModalManager} that after executing the modal button
                         * no action should be performed.
                         */
                        NONE: ModalButtonActions.None,
                        /**
                         * Indicates to the {@link ModalManager} that after executing the modal button,
                         * the modal window should close, and the {@link https://docs.angularjs.org/api/ng/service/$q promise} returned by the modal should be resolved.
                         */
                        CLOSE: ModalButtonActions.Close,
                        /**
                         * Indicates to the {@link ModalManager} that after executing the modal button,
                         * the modal window should close, and the {@link https://docs.angularjs.org/api/ng/service/$q promise} returned by the modal should be rejected.
                         */
                        DISMISS: ModalButtonActions.Dismiss
                    }
                },
                {
                    /**
                     * Injectable angular constant<br/>
                     * Defines the look and feel of a button on a modal window. To be used when adding a button to the modal,
                     * either when opening a modal (see [getButtons]{@link ModalManager#getButtons})) or
                     * when adding a button to an existing modal (see [open]{@link ModalService#open})
                     *
                     * ### Example
                     *      myModalManager.addButton({
                     *          id: 'button id',
                     *          label: 'cancel_button',
                     *          style: MODAL_BUTTON_STYLES.SECONDARY
                     *      });
                     *
                     */
                    provide: 'MODAL_BUTTON_STYLES',
                    useValue: {
                        /**
                         * Equivalent to SECONDARY
                         */
                        DEFAULT: ModalButtonStyles.Default,
                        /**
                         * Indicates to the modal window that this button is the primary button of the modal, such as save or submit,
                         * and should be styled accordingly.
                         */
                        PRIMARY: ModalButtonStyles.Primary,
                        /**
                         * Indicates to the modal window that this button is a secondary button of the modal, such as cancel,
                         * and should be styled accordingly.
                         */
                        SECONDARY: ModalButtonStyles.Default
                    }
                }
            ]
        })
    ], /* @ngInject */ ModalServiceModule);
    return /* @ngInject */ ModalServiceModule;
}());

var IUIBootstrapModalService = /** @class */ (function () {
    function IUIBootstrapModalService() {
    }
    IUIBootstrapModalService.prototype.getPromiseChain = function () {
        return null;
    };
    IUIBootstrapModalService.prototype.open = function (options) {
        return null;
    };
    return IUIBootstrapModalService;
}());

var IUIBootstrapModalStackService = /** @class */ (function () {
    function IUIBootstrapModalStackService() {
    }
    IUIBootstrapModalStackService.prototype.close = function (modalInstance, result) {
        return undefined;
    };
    IUIBootstrapModalStackService.prototype.dismiss = function (modalInstance, reason) {
        return undefined;
    };
    IUIBootstrapModalStackService.prototype.dismissAll = function (reason) {
        return undefined;
    };
    IUIBootstrapModalStackService.prototype.getTop = function () {
        return undefined;
    };
    IUIBootstrapModalStackService.prototype.open = function (modalInstance, modal) {
        return undefined;
    };
    return IUIBootstrapModalStackService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var TOOLBAR_ITEM = new core.InjectionToken('TOOLBAR_ITEM');
(function (ToolbarItemType) {
    ToolbarItemType["TEMPLATE"] = "TEMPLATE";
    ToolbarItemType["ACTION"] = "ACTION";
    ToolbarItemType["HYBRID_ACTION"] = "HYBRID_ACTION";
})(exports.ToolbarItemType || (exports.ToolbarItemType = {}));
(function (ToolbarSection) {
    ToolbarSection["left"] = "left";
    ToolbarSection["middle"] = "middle";
    ToolbarSection["right"] = "right";
})(exports.ToolbarSection || (exports.ToolbarSection = {}));
(function (ToolbarDropDownPosition) {
    ToolbarDropDownPosition["left"] = "left";
    ToolbarDropDownPosition["center"] = "center";
    ToolbarDropDownPosition["right"] = "right";
})(exports.ToolbarDropDownPosition || (exports.ToolbarDropDownPosition = {}));
/**
 * Provides an abstract extensible toolbar service. Used to manage and perform actions to either the SmartEdit
 * application or the SmartEdit container.
 *
 * This class serves as an interface and should be extended, not instantiated.
 */
var IToolbarService = /** @class */ (function () {
    function IToolbarService(logService, $templateCache, permissionService) {
        this.logService = logService;
        this.$templateCache = $templateCache;
        this.permissionService = permissionService;
        this.aliases = [];
        this.actions = {};
    }
    IToolbarService.prototype.getActions = function () {
        return this.actions;
    };
    IToolbarService.prototype.getAliases = function () {
        return this.aliases;
    };
    /**
     * Takes an array of items and maps them internally for display and trigger through an internal callback key.
     * The action's properties are made available through the included template by a variable named 'item'.
     *
     * The toolbar item can accept a context that is displayed beside the toolbar item using either ContextTemplate or ContextTemplateUrl.
     * This context can be shown or hidden by calling the events `seConstantsModule.SHOW_TOOLBAR_ITEM_CONTEXT` and
     * `seConstantsModule.HIDE_TOOLBAR_ITEM_CONTEXT` respectively. Both the events need the key of the toolbar item as data.
     *
     * ### Example
     *
     *      crossFrameEventService.publish(SHOW_TOOLBAR_ITEM_CONTEXT, 'toolbar.item.key');
     *
     */
    IToolbarService.prototype.addItems = function (_items) {
        var _this = this;
        var promisesToResolve = _items
            .filter(function (item) {
            // Validate provided actions -> The filter will return only valid items.
            var includeAction = true;
            if (!item.key) {
                _this.logService.error('addItems() - Cannot add item without key.');
                includeAction = false;
            }
            if (item.contextTemplate && item.contextTemplateUrl) {
                _this.logService.error('addItems() - Toolbar item should contain only one of contextTemplate or contextTemplateUrl');
                includeAction = false;
            }
            return includeAction;
        })
            .map(function (item) {
            var key = item.key;
            _this.actions[key] = item.callback;
            var generatedContextTemplateUrl;
            if (item.contextTemplate) {
                generatedContextTemplateUrl =
                    'toolbarItemContextTemplate' +
                        btoa(stringUtils.generateIdentifier()) +
                        '.html';
                _this.$templateCache.put(generatedContextTemplateUrl, item.contextTemplate);
            }
            else {
                generatedContextTemplateUrl = item.contextTemplateUrl;
            }
            var toolbarItem = {
                key: key,
                name: item.nameI18nKey,
                iconClassName: item.iconClassName,
                description: item.descriptionI18nKey,
                icons: item.icons,
                type: item.type,
                include: item.include,
                priority: item.priority || 500,
                section: item.section || 'left',
                isOpen: false,
                component: item.component,
                actionButtonFormat: item.actionButtonFormat,
                keepAliveOnClose: item.keepAliveOnClose || false,
                contextTemplateUrl: generatedContextTemplateUrl,
                contextComponent: item.contextComponent,
                dropdownPosition: item.dropdownPosition,
                permissions: item.permissions
            };
            return _this._populateIsPermissionGranted(toolbarItem);
        });
        return Promise.all(promisesToResolve).then(function (items) {
            if (items.length > 0) {
                _this.addAliases(items);
            }
            return;
        });
    };
    IToolbarService.prototype._populateIsPermissionGranted = function (toolbarItem) {
        if (toolbarItem.permissions) {
            return Promise.resolve(this.permissionService
                .isPermitted([
                {
                    names: toolbarItem.permissions
                }
            ])
                .then(function (isGranted) {
                toolbarItem.isPermissionGranted = isGranted;
                return toolbarItem;
            }));
        }
        else {
            toolbarItem.isPermissionGranted = true;
            return Promise.resolve(toolbarItem);
        }
    };
    /// //////////////////////////////////
    // Proxied Functions : these functions will be proxied if left unimplemented
    /// //////////////////////////////////
    IToolbarService.prototype.addAliases = function (items) {
        'proxyFunction';
        return;
    };
    IToolbarService.prototype.removeItemByKey = function (key) {
        'proxyFunction';
        return;
    };
    IToolbarService.prototype._removeItemOnInner = function (itemKey) {
        'proxyFunction';
        return;
    };
    IToolbarService.prototype.removeAliasByKey = function (itemKey) {
        'proxyFunction';
        return;
    };
    IToolbarService.prototype.triggerActionOnInner = function (action) {
        'proxyFunction';
        return;
    };
    return IToolbarService;
}());

var pathRegExp = /web.+\/(\w+)\.html/;
var delegator = function ($delegate) {
    'ngInject';
    var namePathMap = {};
    var originalPut = $delegate.put;
    $delegate.put = function () {
        var path = arguments[0];
        var template = arguments[1];
        if (pathRegExp.test(path)) {
            var fileName = pathRegExp.exec(path)[1] + '.html';
            if (!namePathMap[fileName]) {
                originalPut.apply($delegate, [fileName, template]);
                namePathMap[fileName] = path;
            }
            else {
                throw new Error("[templateCacheDecorator] html templates " + namePathMap[fileName] + " and " + path + " are conflicting, you must give them different filenames");
            }
        }
        return originalPut.apply($delegate, arguments);
    };
    // ============== UNCOMMENT THIS TO DEBUG TEMPLATECACHE ==============
    // ========================== DO NOT COMMIT ==========================
    // const originalGet = $delegate.get;
    //
    // $delegate.get = function() {
    //     const path: string = arguments[0];
    //     const $log: angular.ILogService = angular.injector(['ng']).get('$log');
    //
    //     $log.debug("$templateCache GET: " + path);
    //     return originalGet.apply($delegate, arguments);
    // };
    return $delegate;
};
delegator.$inject = ["$delegate"];
var /* @ngInject */ TemplateCacheDecoratorModule = /** @class */ (function () {
    function /* @ngInject */ TemplateCacheDecoratorModule() {
    }
    /* @ngInject */ TemplateCacheDecoratorModule = __decorate([
        SeModule({
            config: ["$provide", function ($provide) {
                'ngInject';
                $provide.decorator('$templateCache', ['$delegate', delegator]);
            }]
        })
    ], /* @ngInject */ TemplateCacheDecoratorModule);
    return /* @ngInject */ TemplateCacheDecoratorModule;
}());

/**
 * Service containing truncate string functions.
 * @internal
 */
var /* @ngInject */ TextTruncateService = /** @class */ (function () {
    function /* @ngInject */ TextTruncateService() {
    }
    /**
     * Truncates text to the nearest word depending on character length.
     * Truncates below character length.
     *
     * @param limit index in text to truncate to
     */
    /* @ngInject */ TextTruncateService.prototype.truncateToNearestWord = function (limit, text, ellipsis) {
        if (ellipsis === void 0) { ellipsis = ''; }
        if (lodash.isNil(text) || limit > text.length) {
            return new TruncatedText(text, text, false);
        }
        var regexp = /(\s)/g;
        var truncatedGroups = text.match(regexp);
        var truncateIndex = 0;
        if (!truncatedGroups) {
            truncateIndex = limit;
        }
        else {
            for (var i = 0; i < truncatedGroups.length; i++) {
                var nextPosition = this.getPositionOfCharacters(text, truncatedGroups[i], i + 1);
                if (nextPosition > limit) {
                    break;
                }
                truncateIndex = nextPosition;
            }
        }
        var truncated = text.substr(0, truncateIndex);
        return new TruncatedText(text, truncated, true, ellipsis);
    };
    TextTruncateService.prototype.truncateToNearestWord.$inject = ["limit", "text", "ellipsis"];
    /* @ngInject */ TextTruncateService.prototype.getPositionOfCharacters = function (searchString, characters, index) {
        return searchString.split(characters, index).join(characters).length;
    };
    TextTruncateService.prototype.getPositionOfCharacters.$inject = ["searchString", "characters", "index"];
    /* @ngInject */ TextTruncateService = __decorate([
        SeDowngradeService()
    ], /* @ngInject */ TextTruncateService);
    return /* @ngInject */ TextTruncateService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var FrequentlyChangingContentName = 'FrequentlyChangingContent';
var frequentlyChangingContent = new utils.CacheAction(FrequentlyChangingContentName);

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * @internal
 * @ignore
 */
var RarelyChangingContentName = 'RarelyChangingContent';
var rarelyChangingContent = new utils.CacheAction(RarelyChangingContentName);

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
// TODO : merge the EVENT strings and the tag ones
var authorizationEvictionTag = new utils.EvictionTag({ event: 'AUTHORIZATION_SUCCESS' });

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
// TODO : merge the EVENT strings and the tag ones
var userEvictionTag = new utils.EvictionTag({ event: 'USER_HAS_CHANGED' });

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var catalogSyncedEvictionTag = new utils.EvictionTag({ event: 'CATALOG_SYNCHRONIZED_EVENT' });
var catalogEvictionTag = new utils.EvictionTag({
    event: 'CATALOG_EVENT',
    relatedTags: [catalogSyncedEvictionTag, userEvictionTag]
});

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var pageCreationEvictionTag = new utils.EvictionTag({ event: 'PAGE_CREATED_EVENT' });
var pageDeletionEvictionTag = new utils.EvictionTag({ event: 'PAGE_DELETED_EVENT' });
var pageUpdateEvictionTag = new utils.EvictionTag({ event: 'PAGE_UPDATED_EVENT' });
var pageRestoredEvictionTag = new utils.EvictionTag({ event: 'PAGE_RESTORED_EVENT' });
var pageChangeEvictionTag = new utils.EvictionTag({ event: 'PAGE_CHANGE' });
var pageEvictionTag = new utils.EvictionTag({
    event: 'pageEvictionTag',
    relatedTags: [pageCreationEvictionTag, pageDeletionEvictionTag, pageUpdateEvictionTag]
});

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var contentCatalogUpdateEvictionTag = new utils.EvictionTag({
    event: 'EVENT_CONTENT_CATALOG_UPDATE'
});

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var perspectiveChangedEvictionTag = new utils.EvictionTag({
    event: 'EVENT_PERSPECTIVE_CHANGED'
});

var CONTENT_CATALOG_VERSION_DETAILS_RESOURCE_API = '/cmssmarteditwebservices/v1/sites/:siteUID/contentcatalogs';
var /* @ngInject */ ContentCatalogRestService = /** @class */ (function (_super) {
    __extends(/* @ngInject */ ContentCatalogRestService, _super);
    ContentCatalogRestService.$inject = ["restServiceFactory"];
    function /* @ngInject */ ContentCatalogRestService(restServiceFactory) {
        return _super.call(this, restServiceFactory, CONTENT_CATALOG_VERSION_DETAILS_RESOURCE_API) || this;
    }
    /* @ngInject */ ContentCatalogRestService = __decorate([
        SeDowngradeService(),
        utils.CacheConfig({
            actions: [rarelyChangingContent],
            tags: [userEvictionTag, pageEvictionTag, contentCatalogUpdateEvictionTag]
        }),
        utils.OperationContextRegistered(CONTENT_CATALOG_VERSION_DETAILS_RESOURCE_API, ['CMS', 'INTERACTIVE']),
        __metadata("design:paramtypes", [utils.RestServiceFactory])
    ], /* @ngInject */ ContentCatalogRestService);
    return /* @ngInject */ ContentCatalogRestService;
}(utils.AbstractCachedRestService));

var /* @ngInject */ ProductCatalogRestService = /** @class */ (function (_super) {
    __extends(/* @ngInject */ ProductCatalogRestService, _super);
    ProductCatalogRestService.$inject = ["restServiceFactory"];
    function /* @ngInject */ ProductCatalogRestService(restServiceFactory) {
        return _super.call(this, restServiceFactory, '/cmssmarteditwebservices/v1/sites/:siteUID/productcatalogs') || this;
    }
    /* @ngInject */ ProductCatalogRestService = __decorate([
        SeDowngradeService(),
        utils.CacheConfig({ actions: [rarelyChangingContent], tags: [userEvictionTag] }),
        __metadata("design:paramtypes", [utils.RestServiceFactory])
    ], /* @ngInject */ ProductCatalogRestService);
    return /* @ngInject */ ProductCatalogRestService;
}(utils.AbstractCachedRestService));

var /* @ngInject */ PermissionsRestService = /** @class */ (function () {
    PermissionsRestService.$inject = ["restServiceFactory"];
    function /* @ngInject */ PermissionsRestService(restServiceFactory) {
        this.URI = '/permissionswebservices/v1/permissions/global/search';
        this.resource = restServiceFactory.get(this.URI);
    }
    /* @ngInject */ PermissionsRestService.prototype.get = function (queryData) {
        return this.resource
            .queryByPost({ principalUid: queryData.user }, { permissionNames: queryData.permissionNames })
            .then(function (data) { return ({
            permissions: data.permissions
        }); });
    };
    PermissionsRestService.prototype.get.$inject = ["queryData"];
    /* @ngInject */ PermissionsRestService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.RestServiceFactory])
    ], /* @ngInject */ PermissionsRestService);
    return /* @ngInject */ PermissionsRestService;
}());

/**
 * This service makes calls to the Global Permissions REST API to check if the current user was
 * granted certain permissions.
 */
var /* @ngInject */ AuthorizationService = /** @class */ (function () {
    AuthorizationService.$inject = ["logService", "sessionService", "permissionsRestService"];
    function /* @ngInject */ AuthorizationService(logService, sessionService, permissionsRestService) {
        this.logService = logService;
        this.sessionService = sessionService;
        this.permissionsRestService = permissionsRestService;
    }
    /**
     * This method checks if the current user is granted the given global permissions.
     *
     * @param permissionNames The list of global permissions to check.
     *
     * @returns True if the user is granted all of the given permissions, false otherwise
     *
     * ### Throws
     *
     * - Will throw an error if the permissionNames array is empty.
     */
    /* @ngInject */ AuthorizationService.prototype.hasGlobalPermissions = function (permissionNames) {
        var _this = this;
        if (!permissionNames.length || permissionNames.length < 1) {
            throw new Error('permissionNames must be a non-empty array');
        }
        var onSuccess = function (permissions) {
            return _this.mergePermissionResults(permissions, permissionNames);
        };
        var onError = function () {
            _this.logService.error('AuthorizationService - Failed to determine authorization for the following permissions: ' +
                permissionNames.toString());
            return false;
        };
        return this.getPermissions(permissionNames).then(onSuccess, onError);
    };
    AuthorizationService.prototype.hasGlobalPermissions.$inject = ["permissionNames"];
    /*
     * This method will look for the result for the given permission name. If found, it is
     * verified that it has been granted. Otherwise, the method will return false.
     */
    /* @ngInject */ AuthorizationService.prototype.getPermissionResult = function (permissionResults, permissionName) {
        var permission = permissionResults.permissions.find(function (result) {
            return result.key.toLowerCase() === permissionName.toLowerCase();
        });
        return !!permission && permission.value === 'true';
    };
    AuthorizationService.prototype.getPermissionResult.$inject = ["permissionResults", "permissionName"];
    /*
     * This method merges permission results. It iterates through the list of permission names that
     * were checked and evaluates if the permission is granted. It immediately returns false when
     * it encounters a permission that is denied.
     */
    /* @ngInject */ AuthorizationService.prototype.mergePermissionResults = function (permissionResults, permissionNames) {
        var hasPermission = !!permissionNames && permissionNames.length > 0;
        var index = 0;
        while (hasPermission && index < permissionNames.length) {
            hasPermission =
                hasPermission &&
                    this.getPermissionResult(permissionResults, permissionNames[index++]);
        }
        return hasPermission;
    };
    AuthorizationService.prototype.mergePermissionResults.$inject = ["permissionResults", "permissionNames"];
    /*
     * This method makes a call to the Global Permissions API with the given permission names
     * and returns the list of results.
     */
    /* @ngInject */ AuthorizationService.prototype.getPermissions = function (permissionNames) {
        var _this = this;
        return this.sessionService.getCurrentUsername().then(function (user) {
            if (!user) {
                return { permissions: [] };
            }
            return _this.permissionsRestService.get({
                user: user,
                permissionNames: permissionNames.join(',')
            });
        });
    };
    AuthorizationService.prototype.getPermissions.$inject = ["permissionNames"];
    /* @ngInject */ AuthorizationService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService,
            utils.ISessionService,
            PermissionsRestService])
    ], /* @ngInject */ AuthorizationService);
    return /* @ngInject */ AuthorizationService;
}());

/**
 * @internal
 * @ignore
 */
var /* @ngInject */ CrossFrameEventServiceGateway = /** @class */ (function () {
    CrossFrameEventServiceGateway.$inject = ["gatewayFactory"];
    function /* @ngInject */ CrossFrameEventServiceGateway(gatewayFactory) {
        return gatewayFactory.createGateway('CROSS_FRAME_EVENT');
    }
    /* @ngInject */ CrossFrameEventServiceGateway.crossFrameEventServiceGatewayToken = new core.InjectionToken('crossFrameEventServiceGatewayToken');
    /* @ngInject */ CrossFrameEventServiceGateway = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [GatewayFactory])
    ], /* @ngInject */ CrossFrameEventServiceGateway);
    return /* @ngInject */ CrossFrameEventServiceGateway;
}());

window.__smartedit__.addDecoratorPayload("Injectable", "CrossFrameEventService", { providedIn: 'root' });
/**
 * The Cross Frame Event Service is responsible for publishing and subscribing events within and between frames.
 *
 * It uses {@link GatewayFactory} and {@link SystemEventService} to transmit events.
 */
var /* @ngInject */ CrossFrameEventService = /** @class */ (function () {
    CrossFrameEventService.$inject = ["systemEventService", "crossFrameEventServiceGateway", "windowUtils"];
    function /* @ngInject */ CrossFrameEventService(systemEventService, crossFrameEventServiceGateway, windowUtils) {
        this.systemEventService = systemEventService;
        this.crossFrameEventServiceGateway = crossFrameEventServiceGateway;
        this.windowUtils = windowUtils;
    }
    /**
     * Publishes an event within and across the gateway.
     *
     * The publish method is used to send events using [publishAsync]{@link SystemEventService#publishAsync}
     * and as well send the message across the gateway by using [publish]{@link MessageGateway#publish} of the {@link GatewayFactory}.
     */
    /* @ngInject */ CrossFrameEventService.prototype.publish = function (eventId, data) {
        var promises = [this.systemEventService.publishAsync(eventId, data)];
        if (this.windowUtils.getGatewayTargetFrame()) {
            promises.push(this.crossFrameEventServiceGateway.publish(eventId, data));
        }
        return Promise.all(promises);
    };
    CrossFrameEventService.prototype.publish.$inject = ["eventId", "data"];
    /**
     * Subscribe to an event across both frames.
     *
     * The subscribe method is used to register for listening to events using subscribe method of
     * {@link SystemEventService} and as well send the registration message across the gateway by using
     * [subscribe]{@link MessageGateway#subscribe} of the {@link GatewayFactory}.
     *
     * @param handler Callback function to be invoked
     * @returns The function to call in order to unsubscribe the event listening.
     * This will unsubscribe both from the systemEventService and the crossFrameEventServiceGatway.
     */
    /* @ngInject */ CrossFrameEventService.prototype.subscribe = function (eventId, handler) {
        var systemEventServiceUnsubscribeFn = this.systemEventService.subscribe(eventId, handler);
        var crossFrameEventServiceGatewayUnsubscribeFn = this.crossFrameEventServiceGateway.subscribe(eventId, handler);
        var unsubscribeFn = function () {
            systemEventServiceUnsubscribeFn();
            crossFrameEventServiceGatewayUnsubscribeFn();
        };
        return unsubscribeFn;
    };
    CrossFrameEventService.prototype.subscribe.$inject = ["eventId", "handler"];
    /* @ngInject */ CrossFrameEventService = __decorate([
        SeDowngradeService(),
        core.Injectable({ providedIn: 'root' }),
        __param(1, core.Inject(CrossFrameEventServiceGateway.crossFrameEventServiceGatewayToken)),
        __metadata("design:paramtypes", [SystemEventService,
            MessageGateway,
            WindowUtils])
    ], /* @ngInject */ CrossFrameEventService);
    return /* @ngInject */ CrossFrameEventService;
}());

var GatewayProxiedName = 'GatewayProxied';
var GatewayProxied = utils.annotationService.getClassAnnotationFactory(GatewayProxiedName);
function GatewayProxiedAnnotationFactory(gatewayProxy) {
    'ngInject';
    return utils.annotationService.setClassAnnotationFactory(GatewayProxiedName, function (factoryArguments) {
        return function (instance, originalConstructor, invocationArguments) {
            originalConstructor.call.apply(originalConstructor, __spreadArrays([instance], invocationArguments));
            instance.gatewayId = diNameUtils.buildServiceName(originalConstructor);
            gatewayProxy.initForService(instance, factoryArguments.length > 0 ? factoryArguments : null);
        };
    });
}

/**
 * @internal
 * @ignore
 */
var /* @ngInject */ Instrumentation = /** @class */ (function () {
    Instrumentation.$inject = ["readObjectStructure"];
    function /* @ngInject */ Instrumentation(readObjectStructure) {
        this.readObjectStructure = readObjectStructure;
        this._FUNCTION_EXECUTION_DATA = {};
        this._DECORATED_MODULES = [];
        this._DEFAULT_LEVEL = 10;
        this.alreadyBrowsed = [];
        this.functionsUtils = new utils.FunctionsUtils();
    }
    /* @ngInject */ Instrumentation.prototype.execute = function (config, _LEVEL, isRoot) {
        var _this = this;
        var LEVEL = _LEVEL || this._DEFAULT_LEVEL;
        if (config.modules === undefined) {
            return;
        }
        this._logFunctionArgumentsAndReturnValue = this._logFunctionArgumentsAndReturnValue.bind(this);
        this._getServiceConfig = this._getServiceConfig.bind(this);
        this._getIterableDelegate = this._getIterableDelegate.bind(this);
        this._getDelegateFunctions = this._getDelegateFunctions.bind(this);
        this._extractComponentBindings = this._extractComponentBindings.bind(this);
        this._extractDirectiveBindings = this._extractDirectiveBindings.bind(this);
        var $provide = config.$provide;
        config.modules.forEach(function (moduleName) {
            _this.alreadyBrowsed.push(moduleName);
            if (!isRoot) {
                if (_this._DECORATED_MODULES.indexOf(moduleName) > -1 ||
                    !moduleName.endsWith('Module')) {
                    return;
                }
            }
            _this._DECORATED_MODULES.push(moduleName);
            var moduleConfig = _this._getServiceConfig(moduleName);
            // FIXME: necessary to concat?
            var serviceExcludeFunctions = moduleConfig.exclude.concat(config.globalExcludedFunctions || []);
            var serviceIncludeFunctions = moduleConfig.include.concat(config.globalIncludedFunctions || []);
            /* forbiddenNameSpaces angular.module:false */
            var module = angular$1.module(moduleName);
            module._invokeQueue.forEach(function (invoke) {
                var fn = invoke[1];
                if (['factory', 'component', 'service', 'directive'].indexOf(fn) > -1) {
                    var args = invoke[2];
                    var recipeName_1 = args[0];
                    if (fn === 'component') {
                        _this._extractComponentBindings(args);
                    }
                    else if (fn === 'directive') {
                        _this._extractDirectiveBindings(args);
                    }
                    else {
                        try {
                            if (_this._isEligible(recipeName_1, config.globalExcludedRecipes, config.globalIncludedRecipes)) {
                                $provide.decorator(recipeName_1, ["$delegate", function ($delegate) {
                                    var iterableDelegate = _this._getIterableDelegate($delegate);
                                    var originals = _this._getDelegateFunctions(iterableDelegate, serviceExcludeFunctions, serviceIncludeFunctions);
                                    originals.forEach(function (original) {
                                        if (!iterableDelegate[original.name].__DECORATED__) {
                                            var self_1 = _this;
                                            var isEmpty = self_1.functionsUtils.isEmpty(original.fn);
                                            if (isEmpty) {
                                                iterableDelegate[original.name] = function () {
                                                    'proxyFunction';
                                                    var result = original.fn.apply(this, arguments);
                                                    self_1._logFunctionArgumentsAndReturnValue(recipeName_1, original.name, arguments, result);
                                                    return result;
                                                };
                                            }
                                            else {
                                                iterableDelegate[original.name] = function () {
                                                    var result = original.fn.apply(this, arguments);
                                                    self_1._logFunctionArgumentsAndReturnValue(recipeName_1, original.name, arguments, result);
                                                    return result;
                                                };
                                            }
                                            iterableDelegate[original.name].__DECORATED__ = true;
                                        }
                                    });
                                    return $delegate;
                                }]);
                            }
                            else {
                                _this.warn('not eligible recipe : ' + recipeName_1);
                            }
                        }
                        catch (e) {
                            _this.error(e);
                            _this.warn('Warning-No-Service-Exists: ' +
                                recipeName_1 +
                                ' of type ' +
                                fn +
                                ', moduleName: ' +
                                moduleName);
                        }
                    }
                }
            });
            if (LEVEL > 0) {
                var NEW_LEVEL_1 = LEVEL - 1;
                module.requires.forEach(function (_moduleName) {
                    if (_this.alreadyBrowsed.indexOf(_moduleName) === -1 &&
                        config.defaultExcludeModules.indexOf(_moduleName) === -1 &&
                        _moduleName.indexOf('Mock') === -1) {
                        _this.execute({
                            globalExcludedRecipes: config.globalExcludedRecipes,
                            globalIncludedRecipes: config.globalIncludedRecipes,
                            globalExcludedFunctions: config.globalExcludedFunctions,
                            globalIncludedFunctions: config.globalIncludedFunctions,
                            modules: [_moduleName],
                            $provide: config.$provide,
                            defaultExcludeModules: config.defaultExcludeModules
                        }, NEW_LEVEL_1, false);
                    }
                });
            }
        });
    };
    Instrumentation.prototype.execute.$inject = ["config", "_LEVEL", "isRoot"];
    /* @ngInject */ Instrumentation.prototype._getServiceConfig = function (service) {
        return typeof service === 'string'
            ? {
                name: service,
                exclude: [],
                include: []
            }
            : service;
    };
    Instrumentation.prototype._getServiceConfig.$inject = ["service"];
    /* @ngInject */ Instrumentation.prototype._getIterableDelegate = function ($delegate) {
        return $delegate.prototype ? $delegate.prototype : $delegate;
    };
    Instrumentation.prototype._getIterableDelegate.$inject = ["$delegate"];
    /* @ngInject */ Instrumentation.prototype._matches = function (name, nameRegex) {
        return new RegExp(nameRegex, 'gi').test(name);
    };
    Instrumentation.prototype._matches.$inject = ["name", "nameRegex"];
    /* @ngInject */ Instrumentation.prototype._getDelegateFunctions = function ($delegate, serviceExcludeFunctions, serviceIncludeFunctions) {
        var result = [];
        for (var fnName in $delegate) {
            if (typeof $delegate[fnName] === 'function') {
                if (this._isEligible(fnName, serviceExcludeFunctions, serviceIncludeFunctions)) {
                    result.push({
                        name: fnName,
                        fn: $delegate[fnName]
                    });
                }
            }
        }
        return result;
    };
    Instrumentation.prototype._getDelegateFunctions.$inject = ["$delegate", "serviceExcludeFunctions", "serviceIncludeFunctions"];
    /* @ngInject */ Instrumentation.prototype._isEligible = function (recipeName, excludes, includes) {
        return ((!includes.length || !!includes.find(this._matches.bind(this, recipeName))) &&
            (!excludes.length || !excludes.find(this._matches.bind(this, recipeName))));
    };
    Instrumentation.prototype._isEligible.$inject = ["recipeName", "excludes", "includes"];
    /* @ngInject */ Instrumentation.prototype._resultIsPromise = function (result) {
        return !!result && (result.$$state !== undefined || !!result.then);
    };
    Instrumentation.prototype._resultIsPromise.$inject = ["result"];
    /* @ngInject */ Instrumentation.prototype._keyExists = function (key) {
        if (this._FUNCTION_EXECUTION_DATA[key] !== undefined) {
            return true;
        }
        return false;
    };
    Instrumentation.prototype._keyExists.$inject = ["key"];
    /* @ngInject */ Instrumentation.prototype._extractComponentBindings = function (args) {
        var componentName = args[0];
        var bindVariables = args[1].bindings;
        this._logDirectiveResult(componentName, bindVariables);
    };
    Instrumentation.prototype._extractComponentBindings.$inject = ["args"];
    /* @ngInject */ Instrumentation.prototype._extractDirectiveBindings = function (args) {
        var directiveName = args[0];
        try {
            var secondAttribute = args[1];
            var directiveConfig = null;
            if (typeof secondAttribute === 'function') {
                directiveConfig = secondAttribute();
            }
            else if (secondAttribute instanceof Array) {
                directiveConfig = secondAttribute[secondAttribute.length - 1]();
            }
            if (directiveConfig) {
                var scope = directiveConfig.scope;
                var bindToController = directiveConfig.bindToController;
                this._logDirectiveResult(directiveName, undefined, scope, bindToController);
            }
        }
        catch (e) {
            this._logDirectiveResult(directiveName);
        }
    };
    Instrumentation.prototype._extractDirectiveBindings.$inject = ["args"];
    /* @ngInject */ Instrumentation.prototype._logFunctionArgumentsAndReturnValue = function (serviceName, functionName, _args, result) {
        var _this = this;
        var args = this.readObjectStructure(Array.prototype.slice.call(_args));
        var key = null;
        try {
            key = serviceName + '~' + functionName + '~' + angular$1.toJson(args);
        }
        catch (e) {
            this.error('COULD NOT GENERATE KEY');
            return result;
        }
        if (this._keyExists(key)) {
            return result;
        }
        this._FUNCTION_EXECUTION_DATA[key] = {};
        if (this._resultIsPromise(result)) {
            return result.then(function (res) {
                try {
                    _this._FUNCTION_EXECUTION_DATA[key] = {
                        serviceName: serviceName,
                        functionName: functionName,
                        arguments: args,
                        result: {
                            promiseValue: _this.readObjectStructure(res)
                        }
                    };
                    _this.warn(angular$1.toJson(_this._FUNCTION_EXECUTION_DATA[key]));
                }
                catch (e) {
                    _this.error('COULD NOT STRINGIFY');
                }
                return Promise.resolve(res);
            }, function (reason) {
                _this.error('ERROR WHILE RESOLVING RESULT: ' + reason);
                _this._FUNCTION_EXECUTION_DATA[key] = {
                    serviceName: serviceName,
                    functionName: functionName,
                    arguments: args,
                    result: { promiseValue: reason }
                };
                _this.warn(angular$1.toJson(_this._FUNCTION_EXECUTION_DATA[key]));
                return Promise.reject(reason);
            });
        }
        else {
            this._FUNCTION_EXECUTION_DATA[key] = {
                serviceName: serviceName,
                functionName: functionName,
                arguments: args,
                result: this.readObjectStructure(result)
            };
            try {
                this.warn(angular$1.toJson(this._FUNCTION_EXECUTION_DATA[key]));
            }
            catch (e) {
                this.error('COULD NOT STRINGIFY');
            }
            return result;
        }
    };
    Instrumentation.prototype._logFunctionArgumentsAndReturnValue.$inject = ["serviceName", "functionName", "_args", "result"];
    /* @ngInject */ Instrumentation.prototype._logDirectiveResult = function (directiveName, bindings, scope, bindToController) {
        this.warn(angular$1.toJson({
            directiveName: directiveName,
            bindings: bindings,
            scope: scope,
            bindToController: bindToController
        }));
    };
    Instrumentation.prototype._logDirectiveResult.$inject = ["directiveName", "bindings", "scope", "bindToController"];
    /* @ngInject */ Instrumentation.prototype.warn = function (message) {
        // eslint-disable-next-line no-console
        console.warn(message);
    };
    Instrumentation.prototype.warn.$inject = ["message"];
    /* @ngInject */ Instrumentation.prototype.error = function (message) {
        // eslint-disable-next-line no-console
        console.error(message);
    };
    Instrumentation.prototype.error.$inject = ["message"];
    /* @ngInject */ Instrumentation = __decorate([
        SeInjectable(),
        __metadata("design:paramtypes", [Function])
    ], /* @ngInject */ Instrumentation);
    return /* @ngInject */ Instrumentation;
}());
function getItemFromSessionStorage(name) {
    try {
        return window.sessionStorage.getItem(name);
    }
    catch (e) {
        /*
         * would fail if:
         * - sessionStorage is not implemented
         * - accessing sessionStorage is forbidden in CORS because of default "Block third-party cookies" settings in chrome
         */
        return null;
    }
}
/** @internal */
var instrument = function ($provide, readObjectStructure, TOP_LEVEL_MODULE_NAME) {
    'ngInject';
    if (getItemFromSessionStorage('isInstrumented') === 'true') {
        new Instrumentation(readObjectStructure).execute({
            globalExcludedRecipes: [
                'assetsService',
                'configurationExtractorService',
                'experienceService'
            ],
            globalIncludedRecipes: [
                '^.*Interface$',
                '^.*Service$',
                '^.*Helper$',
                '^.*Hanlder$',
                '^.*Editor$',
                '^I.*$',
                '^.*Decorator$',
                '^.*Directive$',
                '^.*Registry$',
                '^.*Listener$',
                '^.*Resource$',
                '^.*Populator$',
                '^.*Constants$',
                '^.*Factory$',
                '^.*Facade$',
                '^.*Interceptor$',
                '^.*Manager$',
                '^.*Class$',
                '^.*Strategy',
                '^.*Predicate',
                '^.*Retry',
                '^.*Gateway'
            ],
            globalExcludedFunctions: ['^_.*$', '^\\$', 'lodash', 'yjQuery'],
            globalIncludedFunctions: ['^.*$'],
            defaultExcludeModules: [
                'functionsModule',
                'ycmssmarteditModule',
                'ui.bootstrap',
                'ui.select',
                'yjQuery',
                'instrumentModule',
                'ui.tree',
                'treeModule' // contains fetchChildren function that extracts dom objects that contains circular structure
            ],
            modules: [TOP_LEVEL_MODULE_NAME],
            $provide: $provide
        }, 15, true);
    }
};
instrument.$inject = ["$provide", "readObjectStructure", "TOP_LEVEL_MODULE_NAME"];

var /* @ngInject */ LanguageService = /** @class */ (function (_super) {
    __extends(/* @ngInject */ LanguageService, _super);
    LanguageService.$inject = ["logService", "translateService", "promiseUtils", "eventService", "browserService", "storageService", "injector", "languageServiceConstants"];
    function /* @ngInject */ LanguageService(logService, translateService, promiseUtils, eventService, browserService, storageService, injector, languageServiceConstants) {
        var _this = _super.call(this, logService, translateService, promiseUtils, eventService, browserService, storageService, injector, languageServiceConstants) || this;
        _this.logService = logService;
        _this.translateService = translateService;
        _this.promiseUtils = promiseUtils;
        _this.eventService = eventService;
        _this.browserService = browserService;
        _this.storageService = storageService;
        _this.injector = injector;
        _this.languageServiceConstants = languageServiceConstants;
        return _this;
    }
    /**
     * Fetches a list of language descriptors for the specified storefront site UID.
     * The object containing the list of sites is fetched using REST calls to the cmswebservices languages API.
     */
    /* @ngInject */ LanguageService.prototype.getLanguagesForSite = function (siteUID) {
        var _this = this;
        return this.languageRestService
            .get({
            siteUID: siteUID
        })
            .then(function (languagesList) { return languagesList.languages; }, function (error) {
            _this.logService.error('LanguageService.getLanguagesForSite() - Error loading languages');
            return Promise.reject(error);
        });
    };
    LanguageService.prototype.getLanguagesForSite.$inject = ["siteUID"];
    Object.defineProperty(/* @ngInject */ LanguageService.prototype, "languageRestService", {
        get: function () {
            return this.injector
                .get(utils.RestServiceFactory)
                .get(this.languageServiceConstants.LANGUAGE_RESOURCE_URI);
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        utils.Cached({ actions: [utils.rarelyChangingContent] }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", Promise)
    ], /* @ngInject */ LanguageService.prototype, "getLanguagesForSite", null);
    /* @ngInject */ LanguageService = __decorate([
        SeDowngradeService(),
        __param(3, core.Inject(utils.EVENT_SERVICE)),
        __param(7, core.Inject(utils.LANGUAGE_SERVICE_CONSTANTS)),
        __metadata("design:paramtypes", [utils.LogService,
            core$1.TranslateService,
            utils.PromiseUtils, Object, utils.BrowserService,
            utils.IStorageService,
            core.Injector, Object])
    ], /* @ngInject */ LanguageService);
    return /* @ngInject */ LanguageService;
}(utils.LanguageService));

/**
 * @internal
 * @ignore
 */
var /* @ngInject */ LanguageServiceGateway = /** @class */ (function () {
    LanguageServiceGateway.$inject = ["gatewayFactory"];
    function /* @ngInject */ LanguageServiceGateway(gatewayFactory) {
        /* @ngInject */ LanguageServiceGateway_1.instance =
            /* @ngInject */ LanguageServiceGateway_1.instance || gatewayFactory.createGateway('languageSwitch');
    }
    /* @ngInject */ LanguageServiceGateway_1 = /* @ngInject */ LanguageServiceGateway;
    /* @ngInject */ LanguageServiceGateway.prototype.getInstance = function () {
        return /* @ngInject */ LanguageServiceGateway_1.instance;
    };
    var /* @ngInject */ LanguageServiceGateway_1;
    /* @ngInject */ LanguageServiceGateway = /* @ngInject */ LanguageServiceGateway_1 = __decorate([
        SeDowngradeService(),
        core.Injectable(),
        __metadata("design:paramtypes", [GatewayFactory])
    ], /* @ngInject */ LanguageServiceGateway);
    return /* @ngInject */ LanguageServiceGateway;
}());

var IPerspectiveService = /** @class */ (function () {
    function IPerspectiveService() {
    }
    /**
     * This method registers a perspective.
     * When an end user selects a perspective in the SmartEdit web application,
     * all features bound to the perspective will be enabled when their respective enablingCallback functions are invoked
     * and all features not bound to the perspective will be disabled when their respective disablingCallback functions are invoked.
     */
    IPerspectiveService.prototype.register = function (configuration) {
        'proxyFunction';
        return null;
    };
    /**
     * This method activates a perspective identified by its key and deactivates the currently active perspective.
     * Activating a perspective consists in activating any feature that is bound to the perspective
     * or any feature that is bound to the perspective's referenced perspectives and deactivating any features
     * that are not bound to the perspective or to its referenced perspectives.
     * After the perspective is changed, the `seConstantsModule.EVENT_PERSPECTIVE_CHANGED`
     * event is published on the {@link CrossFrameEventService}, with no data.
     *
     * @param key The key that uniquely identifies the perspective to be activated. This is the same key as the key used in the [register]{@link IPerspectiveService#register} method.
     */
    IPerspectiveService.prototype.switchTo = function (key) {
        'proxyFunction';
        return null;
    };
    /**
     * This method returns true if a perspective is selected.
     */
    IPerspectiveService.prototype.hasActivePerspective = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method switches the currently-selected perspective to the default perspective.
     * It will also disable all features for the default perspective before enabling them all back.
     * If no value has been stored in the smartedit-perspectives cookie, the value of the default perspective is se.none.
     * If a value is stored in the cookie, that value is used as the default perspective.
     */
    IPerspectiveService.prototype.selectDefault = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method returns true if the current active perspective is the Preview mode (No active overlay).
     *
     * @returns A promise with the boolean flag that indicates if the current perspective is the Preview mode.
     */
    IPerspectiveService.prototype.isEmptyPerspectiveActive = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method is used to refresh the prespective.
     * If there is an exising perspective set then it is refreshed by replaying all the features associated to the current perspective.
     * If there is no perspective set or if the perspective is not permitted then we set the default perspective.
     */
    IPerspectiveService.prototype.refreshPerspective = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method returns the key of the perspective that is currently loaded.
     *
     * @returns A promise that resolves to the key of the current perspective loaded in the storefront, null otherwise.
     */
    IPerspectiveService.prototype.getActivePerspectiveKey = function () {
        'proxyFunction';
        return null;
    };
    /**
     * This method returns true if the active perspective has the hotkey enabled
     */
    IPerspectiveService.prototype.isHotkeyEnabledForActivePerspective = function () {
        'proxyFunction';
        return null;
    };
    IPerspectiveService.prototype.getActivePerspective = function () {
        'proxyFunction';
        return null;
    };
    IPerspectiveService.prototype.getPerspectives = function () {
        'proxyFunction';
        return null;
    };
    return IPerspectiveService;
}());

var /* @ngInject */ GenericEditorStackService = /** @class */ (function () {
    GenericEditorStackService.$inject = ["systemEventService", "logService"];
    function /* @ngInject */ GenericEditorStackService(systemEventService, logService) {
        this.systemEventService = systemEventService;
        this.logService = logService;
        this._editorsStacks = {};
        this.systemEventService.subscribe(/* @ngInject */ GenericEditorStackService_1.EDITOR_PUSH_TO_STACK_EVENT, this.pushEditorEventHandler.bind(this));
        this.systemEventService.subscribe(/* @ngInject */ GenericEditorStackService_1.EDITOR_POP_FROM_STACK_EVENT, this.popEditorEventHandler.bind(this));
    }
    /* @ngInject */ GenericEditorStackService_1 = /* @ngInject */ GenericEditorStackService;
    // --------------------------------------------------------------------------------------
    // API
    // --------------------------------------------------------------------------------------
    /* @ngInject */ GenericEditorStackService.prototype.isAnyGenericEditorOpened = function () {
        return lodash.size(this._editorsStacks) >= 1;
    };
    /* @ngInject */ GenericEditorStackService.prototype.areMultipleGenericEditorsOpened = function () {
        return (lodash.size(this._editorsStacks) > 1 ||
            lodash.some(this._editorsStacks, function (stack) { return stack.length > 1; }));
    };
    /* @ngInject */ GenericEditorStackService.prototype.getEditorsStack = function (editorStackId) {
        return this._editorsStacks[editorStackId] || null;
    };
    GenericEditorStackService.prototype.getEditorsStack.$inject = ["editorStackId"];
    /* @ngInject */ GenericEditorStackService.prototype.isTopEditorInStack = function (editorStackId, editorId) {
        var result = false;
        var stack = this._editorsStacks[editorStackId];
        if (stack) {
            var topEditor = stack[stack.length - 1];
            result = topEditor && topEditor.editorId === editorId;
        }
        return result;
    };
    GenericEditorStackService.prototype.isTopEditorInStack.$inject = ["editorStackId", "editorId"];
    // --------------------------------------------------------------------------------------
    // Helper Methods
    // --------------------------------------------------------------------------------------
    /* @ngInject */ GenericEditorStackService.prototype.pushEditorEventHandler = function (eventId, editorToPushInfo) {
        this.validateId(editorToPushInfo);
        var stackId = editorToPushInfo.editorStackId;
        if (!this._editorsStacks[stackId]) {
            this._editorsStacks[stackId] = [];
        }
        this._editorsStacks[stackId].push({
            component: editorToPushInfo.component,
            componentType: editorToPushInfo.componentType,
            editorId: editorToPushInfo.editorId
        });
    };
    GenericEditorStackService.prototype.pushEditorEventHandler.$inject = ["eventId", "editorToPushInfo"];
    /* @ngInject */ GenericEditorStackService.prototype.popEditorEventHandler = function (eventId, editorToPopInfo) {
        this.validateId(editorToPopInfo);
        var stackId = editorToPopInfo.editorStackId;
        var stack = this._editorsStacks[stackId];
        if (!stack) {
            this.logService.warn('genericEditorStackService - Stack of editors not found. Cannot pop editor.');
            return;
        }
        stack.pop();
        if (stack.length === 0) {
            delete this._editorsStacks[stackId];
        }
    };
    GenericEditorStackService.prototype.popEditorEventHandler.$inject = ["eventId", "editorToPopInfo"];
    /* @ngInject */ GenericEditorStackService.prototype.validateId = function (editorInfo) {
        if (!editorInfo.editorStackId) {
            throw new Error('genericEditorStackService - Must provide a stack id.');
        }
    };
    GenericEditorStackService.prototype.validateId.$inject = ["editorInfo"];
    var /* @ngInject */ GenericEditorStackService_1;
    /* @ngInject */ GenericEditorStackService.EDITOR_PUSH_TO_STACK_EVENT = 'EDITOR_PUSH_TO_STACK_EVENT';
    /* @ngInject */ GenericEditorStackService.EDITOR_POP_FROM_STACK_EVENT = 'EDITOR_POP_FROM_STACK_EVENT';
    /* @ngInject */ GenericEditorStackService = /* @ngInject */ GenericEditorStackService_1 = __decorate([
        SeDowngradeService(),
        core.Injectable(),
        __metadata("design:paramtypes", [SystemEventService, utils.LogService])
    ], /* @ngInject */ GenericEditorStackService);
    return /* @ngInject */ GenericEditorStackService;
}());

/**
 * Used for HTTP error code 400. It removes all errors of type 'ValidationError' and displays alert messages for non-validation errors.
 */
var /* @ngInject */ NonValidationErrorInterceptor = /** @class */ (function () {
    NonValidationErrorInterceptor.$inject = ["alertService", "genericEditorStackService"];
    function /* @ngInject */ NonValidationErrorInterceptor(alertService, genericEditorStackService) {
        this.alertService = alertService;
        this.genericEditorStackService = genericEditorStackService;
    }
    /* @ngInject */ NonValidationErrorInterceptor.prototype.predicate = function (request, response) {
        return response.status === 400;
    };
    NonValidationErrorInterceptor.prototype.predicate.$inject = ["request", "response"];
    /* @ngInject */ NonValidationErrorInterceptor.prototype.responseError = function (request, response) {
        var _this = this;
        if (response.error && response.error.errors) {
            response.error.errors
                .filter(function (error) {
                var isValidationError = error.type === 'ValidationError';
                return (!isValidationError ||
                    (isValidationError &&
                        !_this.genericEditorStackService.isAnyGenericEditorOpened()));
            })
                .forEach(function (error) {
                _this.alertService.showDanger({
                    message: error.message || 'se.unknown.request.error',
                    timeout: 10000
                });
            });
        }
        return Promise.reject(response);
    };
    NonValidationErrorInterceptor.prototype.responseError.$inject = ["request", "response"];
    /* @ngInject */ NonValidationErrorInterceptor = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [IAlertService,
            GenericEditorStackService])
    ], /* @ngInject */ NonValidationErrorInterceptor);
    return /* @ngInject */ NonValidationErrorInterceptor;
}());

/**
 * Used for HTTP error code 400 from the Preview API when the pageId is not found in the context. The request will
 * be replayed without the pageId.
 *
 * This can happen in a few different scenarios. For instance, you are on electronics catalog, on some custom page called XYZ.
 * If you use the experience selector and switch to apparel catalog, it will try to create a new preview ticket
 * with apparel catalog and pageId of XYZ. Since XYZ doesn't exist in apparel, it will fail. So we remove the page ID
 * and create a preview for homepage as a default/fallback.
 */
var /* @ngInject */ PreviewErrorInterceptor = /** @class */ (function () {
    PreviewErrorInterceptor.$inject = ["injector", "logService", "sharedDataService"];
    function /* @ngInject */ PreviewErrorInterceptor(injector, logService, sharedDataService) {
        this.injector = injector;
        this.logService = logService;
        this.sharedDataService = sharedDataService;
    }
    /* @ngInject */ PreviewErrorInterceptor.prototype.predicate = function (request, response) {
        return (response.status === 400 &&
            request.url.indexOf(PREVIEW_RESOURCE_URI) > -1 &&
            !utils.stringUtils.isBlank(request.body.pageId) &&
            this._hasUnknownIdentifierError(response.error.errors));
    };
    PreviewErrorInterceptor.prototype.predicate.$inject = ["request", "response"];
    /* @ngInject */ PreviewErrorInterceptor.prototype.responseError = function (request, response) {
        this.logService.info('The error 400 above on preview is expected in some scenarios, typically when switching catalogs from experience selector.');
        this.logService.info('Removing the pageId [' +
            request.body.pageId +
            '] and creating a preview for homepage');
        delete request.body.pageId;
        this.sharedDataService.update(EXPERIENCE_STORAGE_KEY, function (experience) {
            delete experience.pageId;
            return experience;
        });
        this.injector.get('iframeManagerService').setCurrentLocation(null);
        return this.injector.get(http.HttpClient).request(request).toPromise();
    };
    PreviewErrorInterceptor.prototype.responseError.$inject = ["request", "response"];
    /* @ngInject */ PreviewErrorInterceptor.prototype._hasUnknownIdentifierError = function (errors) {
        var unknownIdentifierErrors = errors.filter(function (error) {
            return error.type === 'UnknownIdentifierError';
        });
        return !!unknownIdentifierErrors.length;
    };
    PreviewErrorInterceptor.prototype._hasUnknownIdentifierError.$inject = ["errors"];
    /* @ngInject */ PreviewErrorInterceptor = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [core.Injector,
            utils.LogService,
            utils.ISharedDataService])
    ], /* @ngInject */ PreviewErrorInterceptor);
    return /* @ngInject */ PreviewErrorInterceptor;
}());

/**
 * Used for HTTP error code 404 (Not Found) except for an HTML or a language resource. It will display the response.message in an alert message.
 */
var /* @ngInject */ ResourceNotFoundErrorInterceptor = /** @class */ (function () {
    ResourceNotFoundErrorInterceptor.$inject = ["alertService", "httpUtils"];
    function /* @ngInject */ ResourceNotFoundErrorInterceptor(alertService, httpUtils) {
        this.alertService = alertService;
        this.httpUtils = httpUtils;
    }
    /* @ngInject */ ResourceNotFoundErrorInterceptor.prototype.predicate = function (request, response) {
        return (response.status === 404 &&
            !this.httpUtils.isHTMLRequest(request, response) &&
            !this._isLanguageResourceRequest(request.url));
    };
    ResourceNotFoundErrorInterceptor.prototype.predicate.$inject = ["request", "response"];
    /* @ngInject */ ResourceNotFoundErrorInterceptor.prototype.responseError = function (request, response) {
        this.alertService.showDanger({
            message: response.statusText === utils.StatusText.UNKNOW_ERROR
                ? 'se.unknown.request.error'
                : response.message,
            timeout: 10000
        });
        return Promise.reject(response);
    };
    ResourceNotFoundErrorInterceptor.prototype.responseError.$inject = ["request", "response"];
    /* @ngInject */ ResourceNotFoundErrorInterceptor.prototype._isLanguageResourceRequest = function (url) {
        var languageResourceRegex = new RegExp(LANGUAGE_RESOURCE_URI.replace(/\:.*\//g, '.*/'));
        return languageResourceRegex.test(url);
    };
    ResourceNotFoundErrorInterceptor.prototype._isLanguageResourceRequest.$inject = ["url"];
    /* @ngInject */ ResourceNotFoundErrorInterceptor = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [IAlertService, utils.HttpUtils])
    ], /* @ngInject */ ResourceNotFoundErrorInterceptor);
    return /* @ngInject */ ResourceNotFoundErrorInterceptor;
}());

function operationContextInteractivePredicate(response, operationContext) {
    return operationContext === OPERATION_CONTEXT.INTERACTIVE;
}
function operationContextNonInteractivePredicate(response, operationContext) {
    return lodash.includes([
        OPERATION_CONTEXT.BACKGROUND_TASKS,
        OPERATION_CONTEXT.NON_INTERACTIVE,
        OPERATION_CONTEXT.BATCH_OPERATIONS
    ], operationContext);
}
function operationContextCMSPredicate(response, operationContext) {
    return operationContext === OPERATION_CONTEXT.CMS;
}
function operationContextToolingPredicate(response, operationContext) {
    return operationContext === OPERATION_CONTEXT.TOOLING;
}

var /* @ngInject */ InterceptorHelper = /** @class */ (function () {
    InterceptorHelper.$inject = ["logService"];
    function /* @ngInject */ InterceptorHelper(logService) {
        this.logService = logService;
    }
    /* @ngInject */ InterceptorHelper.prototype.handleRequest = function (config, callback) {
        return this._handle(config, config, callback, false);
    };
    InterceptorHelper.prototype.handleRequest.$inject = ["config", "callback"];
    /* @ngInject */ InterceptorHelper.prototype.handleResponse = function (response, callback) {
        return this._handle(response, response.config, callback, false);
    };
    InterceptorHelper.prototype.handleResponse.$inject = ["response", "callback"];
    /* @ngInject */ InterceptorHelper.prototype.handleResponseError = function (response, callback) {
        return this._handle(response, response.config, callback, true);
    };
    InterceptorHelper.prototype.handleResponseError.$inject = ["response", "callback"];
    /* @ngInject */ InterceptorHelper.prototype._isEligibleForInterceptors = function (config) {
        return config && config.url && !/.+\.html$/.test(config.url);
    };
    InterceptorHelper.prototype._isEligibleForInterceptors.$inject = ["config"];
    /* @ngInject */ InterceptorHelper.prototype._handle = function (chain, config, callback, isError) {
        try {
            if (this._isEligibleForInterceptors(config)) {
                return callback();
            }
            else {
                if (isError) {
                    return Promise.reject(chain);
                }
                else {
                    return chain;
                }
            }
        }
        catch (e) {
            this.logService.error('caught error in one of the interceptors', e);
            if (isError) {
                return Promise.reject(chain);
            }
            else {
                return chain;
            }
        }
    };
    InterceptorHelper.prototype._handle.$inject = ["chain", "config", "callback", "isError"];
    /* @ngInject */ InterceptorHelper = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.LogService])
    ], /* @ngInject */ InterceptorHelper);
    return /* @ngInject */ InterceptorHelper;
}());

/**
 * Used to determine whether smartedit is running in a e2e (test) mode
 */
/** @internal */
var /* @ngInject */ TestModeService = /** @class */ (function () {
    TestModeService.$inject = ["upgrade"];
    function /* @ngInject */ TestModeService(upgrade) {
        this.upgrade = upgrade;
        this.TEST_KEY = 'e2eMode';
    }
    /* @ngInject */ TestModeService_1 = /* @ngInject */ TestModeService;
    /**
     * Returns true if smartedit is running in e2e (test) mode, otherwise false.
     */
    /* @ngInject */ TestModeService.prototype.isE2EMode = function () {
        return this.isE2EModeLegacy() || this.isE2EModeNg();
    };
    /* @ngInject */ TestModeService.prototype.isE2EModeNg = function () {
        try {
            return this.upgrade.injector.get(/* @ngInject */ TestModeService_1.TEST_TOKEN);
        }
        catch (e) {
            return false;
        }
    };
    /* @ngInject */ TestModeService.prototype.isE2EModeLegacy = function () {
        return (this.upgrade.$injector &&
            this.upgrade.$injector.has(this.TEST_KEY) &&
            this.upgrade.$injector.get(this.TEST_KEY));
    };
    var /* @ngInject */ TestModeService_1;
    // Constants
    /* @ngInject */ TestModeService.TEST_TOKEN = new core.InjectionToken('TEST_KEY_TOKEN');
    /* @ngInject */ TestModeService = /* @ngInject */ TestModeService_1 = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [_static.UpgradeModule])
    ], /* @ngInject */ TestModeService);
    return /* @ngInject */ TestModeService;
}());

/* @internal */
var /* @ngInject */ PolyfillService = /** @class */ (function () {
    PolyfillService.$inject = ["browserService", "testModeService"];
    function /* @ngInject */ PolyfillService(browserService, testModeService) {
        this.browserService = browserService;
        this.testModeService = testModeService;
    }
    /* @ngInject */ PolyfillService.prototype.isEligibleForEconomyMode = function () {
        return this.browserService.isIE() || this.testModeService.isE2EMode();
    };
    /* @ngInject */ PolyfillService.prototype.isEligibleForExtendedView = function () {
        return (this.browserService.isIE() ||
            this.browserService.isFF() ||
            this.testModeService.isE2EMode());
    };
    /* @ngInject */ PolyfillService.prototype.isEligibleForThrottledScrolling = function () {
        return this.browserService.isIE();
    };
    /* @ngInject */ PolyfillService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.BrowserService, TestModeService])
    ], /* @ngInject */ PolyfillService);
    return /* @ngInject */ PolyfillService;
}());

/**
 * The PriorityService handles arrays of {@link IPrioritized} elements.
 */
var /* @ngInject */ PriorityService = /** @class */ (function () {
    PriorityService.$inject = ["stringUtils"];
    function /* @ngInject */ PriorityService(stringUtils) {
        this.stringUtils = stringUtils;
    }
    /**
     * Will sort the candidate array by ascendign or descending priority.
     * Even if the priority is not defined for a number of elements, the sorting will still be consistent over invocations
     * @param candidate Elements to be sorted
     * @param ascending If true, candidate will be sorted by ascending priority.
     * @returns The sorted candidate array.
     */
    /* @ngInject */ PriorityService.prototype.sort = function (candidate, ascending) {
        var _this = this;
        return candidate.sort(function (item1, item2) {
            var output = item1.priority - item2.priority;
            if (output === 0) {
                output = _this.stringUtils
                    .encode(item1)
                    .localeCompare(_this.stringUtils.encode(item2));
            }
            return output;
        });
    };
    PriorityService.prototype.sort.$inject = ["candidate", "ascending"];
    /* @ngInject */ PriorityService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.StringUtils])
    ], /* @ngInject */ PriorityService);
    return /* @ngInject */ PriorityService;
}());

var /* @ngInject */ SmarteditBootstrapGateway = /** @class */ (function () {
    SmarteditBootstrapGateway.$inject = ["gatewayFactory"];
    function /* @ngInject */ SmarteditBootstrapGateway(gatewayFactory) {
        this.instance = this.instance || gatewayFactory.createGateway('smartEditBootstrap');
    }
    /* @ngInject */ SmarteditBootstrapGateway.prototype.getInstance = function () {
        return this.instance;
    };
    /* @ngInject */ SmarteditBootstrapGateway.prototype.subscribe = function (eventId, callback) {
        return this.getInstance().subscribe(eventId, callback);
    };
    SmarteditBootstrapGateway.prototype.subscribe.$inject = ["eventId", "callback"];
    /* @ngInject */ SmarteditBootstrapGateway.prototype.publish = function (eventId, _data, retries, pk) {
        if (retries === void 0) { retries = 0; }
        return this.getInstance().publish(eventId, _data, retries, pk);
    };
    SmarteditBootstrapGateway.prototype.publish.$inject = ["eventId", "_data", "retries", "pk"];
    /* @ngInject */ SmarteditBootstrapGateway.prototype.processEvent = function (event) {
        return this.getInstance().processEvent(event);
    };
    SmarteditBootstrapGateway.prototype.processEvent.$inject = ["event"];
    /* @ngInject */ SmarteditBootstrapGateway = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [GatewayFactory])
    ], /* @ngInject */ SmarteditBootstrapGateway);
    return /* @ngInject */ SmarteditBootstrapGateway;
}());

/**
 * Any route not starting with 'ng' will be delegated to legacy Angular JS router.
 *
 * @internal
 * @ignore
 */
var CustomHandlingStrategy = /** @class */ (function () {
    function CustomHandlingStrategy() {
    }
    CustomHandlingStrategy.isNgRoute = function (url) {
        return url.startsWith("/" + NG_ROUTE_PREFIX);
    };
    CustomHandlingStrategy.prototype.shouldProcessUrl = function (url) {
        return CustomHandlingStrategy.isNgRoute(url.toString());
    };
    CustomHandlingStrategy.prototype.extract = function (url) {
        return url;
    };
    CustomHandlingStrategy.prototype.merge = function (newUrlPart, rawUrl) {
        return newUrlPart;
    };
    return CustomHandlingStrategy;
}());

(function (NavigationEventSource) {
    NavigationEventSource["NG"] = "ng";
    NavigationEventSource["AJS"] = "ajs";
})(exports.NavigationEventSource || (exports.NavigationEventSource = {}));

/**
 * A service that provides navigation and URL manipulation capabilities.
 * It is a reliant source of information on routing state in Smartedit.
 */
var /* @ngInject */ SmarteditRoutingService = /** @class */ (function () {
    SmarteditRoutingService.$inject = ["router", "document", "logService", "upgrade"];
    function /* @ngInject */ SmarteditRoutingService(router, document, logService, upgrade) {
        this.router = router;
        this.document = document;
        this.logService = logService;
        this.upgrade = upgrade;
        this.listenersInitialized = false;
        this.routeChangeError$ = new rxjs.ReplaySubject();
        this.routeChangeStart$ = new rxjs.ReplaySubject();
        this.routeChangeSuccess$ = new rxjs.ReplaySubject();
        this.previousRouterUrl = '';
    }
    /**
     *  Initializes listeners for navigation events.
     */
    /* @ngInject */ SmarteditRoutingService.prototype.init = function () {
        if (!this.listenersInitialized) {
            this.notifyOnAngularRouteEvents();
            this.notifyOnAngularJSRouteEvents();
            this.listenersInitialized = true;
        }
    };
    /** Navigates based on the provided URL (absolute). */
    /* @ngInject */ SmarteditRoutingService.prototype.go = function (url) {
        return this.router.navigateByUrl(url);
    };
    SmarteditRoutingService.prototype.go.$inject = ["url"];
    /** Returns the current router URL. */
    /* @ngInject */ SmarteditRoutingService.prototype.path = function () {
        return this.router.url;
    };
    /** Returns absolute URL. */
    /* @ngInject */ SmarteditRoutingService.prototype.absUrl = function () {
        return this.document.location.href;
    };
    /** Notifies when the route change has started. */
    /* @ngInject */ SmarteditRoutingService.prototype.routeChangeStart = function () {
        var _this = this;
        this.warnAboutListenersNotInitialized();
        return this.routeChangeStart$.pipe(operators.filter(function (event) {
            return !!event.url && event.url !== _this.previousRouterUrl;
        }), operators.map(function (event) { return event.routeData; }));
    };
    /** Notifies when the route change has ended. */
    /* @ngInject */ SmarteditRoutingService.prototype.routeChangeSuccess = function () {
        var _this = this;
        this.warnAboutListenersNotInitialized();
        return this.routeChangeSuccess$.pipe(operators.filter(function (event) {
            return !!event.url && event.url !== _this.previousRouterUrl;
        }), operators.map(function (event) { return event.routeData; }));
    };
    /** Notifies when the route change has failed. */
    /* @ngInject */ SmarteditRoutingService.prototype.routeChangeError = function () {
        this.warnAboutListenersNotInitialized();
        return this.routeChangeError$.pipe(operators.map(function (event) { return event.routeData; }));
    };
    /** Reloads the given URL. If not provided, it will reload the current URL. */
    /* @ngInject */ SmarteditRoutingService.prototype.reload = function (url) {
        var _this = this;
        if (url === void 0) { url = this.router.url; }
        return this.router
            .navigateByUrl('/', { skipLocationChange: true })
            .then(function () { return _this.router.navigateByUrl(url); });
    };
    SmarteditRoutingService.prototype.reload.$inject = ["url"];
    /**
     * Extracts `url` from Angular router event or `current.originalPath` from AngularJS event
     */
    /* @ngInject */ SmarteditRoutingService.prototype.getCurrentUrlFromEvent = function (event) {
        if (event instanceof router.NavigationStart ||
            event instanceof router.NavigationEnd ||
            event instanceof router.NavigationError) {
            return event.url;
        }
        return event && event.current && event.current.originalPath;
    };
    SmarteditRoutingService.prototype.getCurrentUrlFromEvent.$inject = ["event"];
    /**
     * @internal
     * @ignore
     */
    /* @ngInject */ SmarteditRoutingService.prototype.warnAboutListenersNotInitialized = function () {
        if (!this.listenersInitialized) {
            this.logService.warn('Listeners not initialized, run `init()` first.');
        }
    };
    /**
     * @internal
     * @ignore
     */
    /* @ngInject */ SmarteditRoutingService.prototype.notifyOnAngularRouteEvents = function () {
        var _this = this;
        this.router.events.subscribe(function (event) {
            // For some reason CustomHandlingStrategy.shouldProcessUrl is called twice
            // when switching from NG route to AJS route e.g.: /ng -> /pages/...
            // it's get called with /pages/... and then suddenly with /ng
            // however event.url is /pages/... and not /ng
            // That's why it has to do another check for ng prefix in route
            // to avoid duplicated events
            if (event && event.url && !CustomHandlingStrategy.isNgRoute(event.url)) {
                return;
            }
            switch (true) {
                case event instanceof router.NavigationStart: {
                    _this.routeChangeStart$.next({
                        from: exports.NavigationEventSource.NG,
                        url: event.url,
                        routeData: event
                    });
                    break;
                }
                case event instanceof router.NavigationError: {
                    _this.routeChangeError$.next({
                        from: exports.NavigationEventSource.NG,
                        url: event.url,
                        routeData: event
                    });
                    break;
                }
                case event instanceof router.NavigationEnd: {
                    _this.routeChangeSuccess$.next({
                        from: exports.NavigationEventSource.NG,
                        url: event.url,
                        routeData: event
                    });
                    _this.previousRouterUrl = event && event.url;
                    break;
                }
            }
        });
    };
    /**
     * @internal
     * @ignore
     */
    /* @ngInject */ SmarteditRoutingService.prototype.notifyOnAngularJSRouteEvents = function () {
        var _this = this;
        this.upgrade.$injector
            .get('$rootScope')
            .$on('$routeChangeSuccess', function (event, current, previous) {
            _this.routeChangeSuccess$.next({
                from: exports.NavigationEventSource.AJS,
                url: current && current.originalPath,
                routeData: { event: event, current: current, previous: previous }
            });
            _this.previousRouterUrl = current && current.originalPath;
        });
        this.upgrade.$injector
            .get('$rootScope')
            .$on('$routeChangeError', function (event, current, previous, rejection) {
            _this.routeChangeError$.next({
                from: exports.NavigationEventSource.AJS,
                url: current && current.originalPath,
                routeData: { event: event, current: current, previous: previous, rejection: rejection }
            });
        });
        this.upgrade.$injector
            .get('$rootScope')
            .$on('$routeChangeStart', function (event, next, current) {
            _this.routeChangeStart$.next({
                from: exports.NavigationEventSource.AJS,
                url: next && next.originalPath,
                routeData: { event: event, next: next, current: current }
            });
        });
    };
    /* @ngInject */ SmarteditRoutingService = __decorate([
        SeDowngradeService(),
        __param(0, core.Optional()),
        __param(1, core.Inject(common.DOCUMENT)),
        __metadata("design:paramtypes", [router.Router,
            Document,
            utils.LogService,
            _static.UpgradeModule])
    ], /* @ngInject */ SmarteditRoutingService);
    return /* @ngInject */ SmarteditRoutingService;
}());

var /* @ngInject */ AuthenticationManager = /** @class */ (function (_super) {
    __extends(/* @ngInject */ AuthenticationManager, _super);
    AuthenticationManager.$inject = ["routing"];
    function /* @ngInject */ AuthenticationManager(routing) {
        var _this = _super.call(this) || this;
        _this.routing = routing;
        return _this;
    }
    /* @ngInject */ AuthenticationManager.prototype.onLogout = function () {
        var currentLocation = this.routing.path();
        if (utils.stringUtils.isBlank(currentLocation) || currentLocation === "/" + NG_ROUTE_PREFIX) {
            this.routing.reload();
        }
        else {
            this.routing.go(NG_ROUTE_PREFIX);
        }
    };
    /* @ngInject */ AuthenticationManager.prototype.onUserHasChanged = function () {
        this.routing.reload();
    };
    /* @ngInject */ AuthenticationManager = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [SmarteditRoutingService])
    ], /* @ngInject */ AuthenticationManager);
    return /* @ngInject */ AuthenticationManager;
}(utils.IAuthenticationManagerService));

/*
 * Meant to be a non-protected API
 */
var /* @ngInject */ SettingsService = /** @class */ (function () {
    SettingsService.$inject = ["restServicefactory"];
    function /* @ngInject */ SettingsService(restServicefactory) {
        this.restService = restServicefactory.get(SETTINGS_URI);
    }
    /* @ngInject */ SettingsService.prototype.load = function () {
        return this.restService.get();
    };
    /* @ngInject */ SettingsService.prototype.get = function (key) {
        return this.load().then(function (map) { return map[key]; });
    };
    SettingsService.prototype.get.$inject = ["key"];
    /* @ngInject */ SettingsService.prototype.getBoolean = function (key) {
        return this.load().then(function (map) { return map[key] === true || map[key] === 'true'; });
    };
    SettingsService.prototype.getBoolean.$inject = ["key"];
    /* @ngInject */ SettingsService.prototype.getStringList = function (key) {
        return this.load().then(function (map) { return map[key]; });
    };
    SettingsService.prototype.getStringList.$inject = ["key"];
    __decorate([
        utils.Cached({ actions: [rarelyChangingContent] }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Promise)
    ], /* @ngInject */ SettingsService.prototype, "load", null);
    /* @ngInject */ SettingsService = __decorate([
        SeDowngradeService(utils.ISettingsService),
        core.Injectable(),
        __metadata("design:paramtypes", [utils.RestServiceFactory])
    ], /* @ngInject */ SettingsService);
    return /* @ngInject */ SettingsService;
}());

/**
 * The SeRouteService is a hybrid service that allows to add legacy (for AngularJS) as well as Angular routes to the application.
 * It also collects information about each route to build route related shortcut links.
 */
var SeRouteService = /** @class */ (function () {
    function SeRouteService() {
    }
    /**
     * **Deprecated since 2105, use [provideNgRoute]{@link SeRouteService#provideNgRoute}.**
     *
     * Must be called before `provideLegacyRoute`
     *
     * @deprecated
     */
    SeRouteService.init = function ($routeProvider) {
        this.$routeProvider = $routeProvider;
    };
    /**
     * **Deprecated since 2105, use [provideNgRoute]{@link SeRouteService#provideNgRoute}.**
     *
     * Adds new Angular route to the application. For more information please see documentation for RouterModule.forRoot.
     * @returns A wrapper around an NgModule that associates it with the providers.
     * @deprecated
     */
    SeRouteService.provideNgRoute = function (routes, config) {
        this.validateNgRoutes(routes);
        this.provideRouteShortcutConfigs(routes);
        return router.RouterModule.forRoot(routes, config);
    };
    /**
     * Adds new AngularJS route to the application.
     */
    SeRouteService.provideLegacyRoute = function (legacyRoute) {
        if (!this.$routeProvider) {
            throw new Error('Please call SeRouteService.init($routeProvider) first');
        }
        var seRoute = {
            path: legacyRoute.path,
            priority: legacyRoute.priority,
            titleI18nKey: legacyRoute.titleI18nKey,
            shortcutComponent: legacyRoute.shortcutComponent
        };
        this.provideRouteShortcutConfigs([seRoute]);
        return this.$routeProvider.when(legacyRoute.path, legacyRoute.route);
    };
    Object.defineProperty(SeRouteService, "routeShortcutConfigs", {
        /**
         * Returns a list of all shortcut configs.
         */
        get: function () {
            return this.routeShortcuts;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Populates the route shortcut list. It filters route shortcuts that cannot be used
     * as shortcuts.
     */
    SeRouteService.provideRouteShortcutConfigs = function (routes) {
        var _this = this;
        var routeShortcutConfigs = [];
        this.generateRouteShortcutConfig(routeShortcutConfigs, routes);
        routeShortcutConfigs
            .filter(function (routeShortcutConfig) {
            return _this.canRegisterRouteShortcutConfig(routeShortcutConfig);
        })
            .forEach(function (routeShortcutConfig) {
            _this.routeShortcuts.push(routeShortcutConfig);
        });
    };
    /**
     * Recursively reads the list of routes and calculates the full path for each route.
     * Then populates the shortcut configs array with calculated data.
     */
    SeRouteService.generateRouteShortcutConfig = function (configs, routes, parent) {
        var _this = this;
        if (parent === void 0) { parent = ''; }
        routes.forEach(function (route) {
            if (route.path) {
                var fullPath = _this.getFullPath(parent, route);
                configs.push({
                    fullPath: fullPath,
                    titleI18nKey: route.titleI18nKey,
                    priority: route.priority,
                    shortcutComponent: route.shortcutComponent
                });
            }
            if (route.children) {
                var fullPath = _this.getFullPath(parent, route);
                var currentPath = route.path ? fullPath : parent;
                _this.generateRouteShortcutConfig(configs, route.children, currentPath);
            }
        });
    };
    /**
     * Returns the full path concatenating parent route with current one.
     */
    SeRouteService.getFullPath = function (parent, route) {
        return parent ? parent + '/' + route.path : route.path;
    };
    /**
     * Validates all Angular routes. Each route should start with NG_ROUTE_PREFIX.
     */
    SeRouteService.validateNgRoutes = function (routes) {
        routes.forEach(function (route) {
            if (route.path &&
                !route.path.startsWith(NG_ROUTE_PREFIX) &&
                !route.path.startsWith(NG_ROUTE_WILDCARD)) {
                throw new Error('Angular route must start with ' + NG_ROUTE_PREFIX);
            }
        });
    };
    /**
     * Validates whether the route shortcut config can be registered.
     * It's not registered if:
     * - the fullPath is not provided
     * - the fullPath contains placeholders that are not in CATALOG_AWARE_PATH_PLACEHOLDERS list.
     */
    SeRouteService.canRegisterRouteShortcutConfig = function (routeShortcutConfig) {
        if (!routeShortcutConfig.fullPath) {
            return false;
        }
        var fullPath = routeShortcutConfig.fullPath;
        this.CATALOG_AWARE_PATH_PLACEHOLDERS.forEach(function (placeholder) {
            fullPath = fullPath.replace(placeholder, '');
        });
        if (fullPath.indexOf(':') > -1) {
            return false;
        }
        return true;
    };
    SeRouteService.CATALOG_AWARE_PATH_PLACEHOLDERS = [':siteId', ':catalogId', ':catalogVersion'];
    SeRouteService.routeShortcuts = [];
    return SeRouteService;
}());

var /* @ngInject */ SeRouteModule = /** @class */ (function () {
    function /* @ngInject */ SeRouteModule() {
    }
    /* @ngInject */ SeRouteModule = __decorate([
        SeModule({
            providers: [SeRouteService]
        })
    ], /* @ngInject */ SeRouteModule);
    return /* @ngInject */ SeRouteModule;
}());

var YJQUERY_TOKEN = 'yjQuery';
/**
 * Return a jQuery wrapping factory while preserving potentially pre-existing jQuery in storefront and SmartEditContainer
 */
function yjQueryServiceFactory() {
    /* forbiddenNameSpaces (window as any):false */
    var namespace = 'smarteditJQuery';
    if (!window[namespace]) {
        if (window.$ && window.$.noConflict) {
            window[namespace] = window.$.noConflict(true);
        }
        else {
            window[namespace] = window.$;
        }
    }
    return window[namespace];
}
/**
 * This module manages the use of the jQuery library.
 * It enables to work with a "noConflict" version of jQuery in a storefront that may contain another version.
 */
var YjqueryModule = /** @class */ (function () {
    function YjqueryModule() {
    }
    YjqueryModule = __decorate([
        core.NgModule({
            providers: [
                {
                    provide: YJQUERY_TOKEN,
                    useFactory: yjQueryServiceFactory
                },
                moduleUtils.initialize(function (yjQuery) {
                    yjQuery.fn.extend({
                        getCssPath: function () {
                            var path;
                            var node = this;
                            while (node.length) {
                                var realNode = node[0];
                                var name_1 = realNode.className;
                                if (realNode.tagName === 'BODY') {
                                    break;
                                }
                                node = node.parent();
                                path = name_1 + (path ? '>' + path : '');
                            }
                            return path;
                        }
                    });
                    diBridgeUtils.downgradeService(YJQUERY_TOKEN, null, YJQUERY_TOKEN);
                }, [YJQUERY_TOKEN])
            ]
        })
    ], YjqueryModule);
    return YjqueryModule;
}());

var IN_VIEW_ELEMENTS_INTERSECTION_OBSERVER_OPTIONS = {
    // The root to use for intersection.
    // If not provided, use the top-level documents viewport.
    root: null,
    // Threshold(s) at which to trigger callback, specified as a ratio, or list of
    // ratios, of (visible area / total area) of the observed element (hence all
    // entries must be in the range [0, 1]). Callback will be invoked when the visible
    // ratio of the observed element crosses a threshold in the list.
    threshold: 0
};
/*
 * This is the configuration passed to the MutationObserver instance
 */
var IN_VIEW_ELEMENTS_MUTATION_OBSERVER_OPTIONS = {
    /*
     * enables observation of attribute mutations precisely for class="smartEditComponent" that may be added dynamically
     * turned to true dynamically if at least of the selectors is class sensitive
     */
    attributes: true,
    /*
     * instruct the observer not to keep in store the former values of the mutated attributes
     */
    attributeOldValue: false,
    /*
     * enables observation of addition and removal of nodes
     */
    childList: true,
    characterData: false,
    /*
     * enables recursive lookup without which only addition and removal of DIRECT children of the observed DOM root would be collected
     */
    subtree: true
};
/**
 * InViewElementObserver maintains a collection of eligible DOM elements considered "in view".
 * An element is considered eligible if matches at least one of the selectors passed to the service.
 * An eligible element is in view when and only when it intersects with the view port of the window frame.
 * This services provides as well convenience methods around "in view" components:
 */
var /* @ngInject */ InViewElementObserver = /** @class */ (function () {
    InViewElementObserver.$inject = ["logService", "document", "yjQuery"];
    function /* @ngInject */ InViewElementObserver(logService, document, yjQuery) {
        this.logService = logService;
        this.document = document;
        this.yjQuery = yjQuery;
        /*
         * Queue used to process components when intersecting the viewport
         * {Array.<{isIntersecting: Boolean, parent: DOMElement, processed: COMPONENT_STATE}>}
         */
        this.componentsQueue = [];
        this.selectors = [];
        this.hasClassBasedSelectors = false;
    }
    /**
     * Retrieves the element targeted by the given mousePosition.
     * On some browsers, the native Javascript API will not work when targeting
     * an element inside an iframe from the container if a container overlay blocks it.
     * In such case we resort to returning the targeted element amongst the list of "in view" elements
     */
    /* @ngInject */ InViewElementObserver.prototype.elementFromPoint = function (mousePosition) {
        var elementFromPointThroughNativeAPI = this.document.elementFromPoint(mousePosition.x, mousePosition.y);
        // we might potentially have an issue here if a browser has an intersection observer and document.elementFromPoint returns null.
        // Chrome version 66 when running in isE2EMode has the issue. But this is not likely to happen in reality because Chrome has an intersectionObserver
        // and hence it should just use the result from document.elementFromPoint.
        return (elementFromPointThroughNativeAPI ||
            this.getInViewElements().find(function (component) {
                return nodeUtils.isPointOverElement(mousePosition, component);
            }));
    };
    InViewElementObserver.prototype.elementFromPoint.$inject = ["mousePosition"];
    /**
     * Declares a new yjQuery selector in order to observe more elements.
     */
    /* @ngInject */ InViewElementObserver.prototype.addSelector = function (selector, callback) {
        var _this = this;
        if (!stringUtils.isBlank(selector) &&
            this.selectors.map(function (el) { return el.selector; }).indexOf(selector) === -1) {
            if (/\.[\w]+/.test(selector)) {
                this.hasClassBasedSelectors = true;
            }
            this.selectors.push({ selector: selector, callback: callback });
            this.restart();
        }
        return function () {
            var index = _this.selectors.map(function (el) { return el.selector; }).indexOf(selector);
            _this.selectors.splice(index, 1);
            _this.restart();
        };
    };
    InViewElementObserver.prototype.addSelector.$inject = ["selector", "callback"];
    /**
     * Retrieves the full list of eligible DOM elements even if they are not "in view".
     */
    /* @ngInject */ InViewElementObserver.prototype.getAllElements = function () {
        return this.componentsQueue.map(function (element) { return element.component; });
    };
    /**
     * Retrieves the list of currently "in view" DOM elements.
     */
    /* @ngInject */ InViewElementObserver.prototype.getInViewElements = function () {
        return this.componentsQueue
            .filter(function (element) { return element.isIntersecting; })
            .map(function (element) { return element.component; });
    };
    /* @ngInject */ InViewElementObserver.prototype.restart = function () {
        this.stopListener();
        this.initListener();
    };
    /*
     * stops and clean up all listeners
     */
    /* @ngInject */ InViewElementObserver.prototype.stopListener = function () {
        // Stop listening for DOM mutations
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            delete this.mutationObserver;
        }
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            delete this.intersectionObserver;
        }
        this.componentsQueue = [];
    };
    /*
     * initializes and starts all Intersection/DOM listeners:
     * - Intersection of eligible components with the viewport
     * - DOM mutations on eligible components (by Means of native MutationObserver)
     */
    /* @ngInject */ InViewElementObserver.prototype.initListener = function () {
        var _this = this;
        if (!this.mutationObserver) {
            this.mutationObserver = this._newMutationObserver(this._mutationObserverCallback.bind(this));
            if (!this.intersectionObserver) {
                // Intersection Observer is used to observe intersection of components with the viewport.
                // each time the 'isIntersecting' property of an entry changes, the Intersection Callback is called.
                // we are using the componentsQueue to hold the components references and their isIntersecting value.
                this.intersectionObserver = this._newIntersectionObserver(function (entries) {
                    var eligibleEntries = entries.filter(function (entry) {
                        return _this._isEligibleComponent(entry.target);
                    });
                    eligibleEntries.forEach(function (entry) {
                        _this._updateQueue(entry);
                    });
                    /*
                     * for each added selector, if at least one of the entries is a match, we call the assocated callback
                     *
                     */
                    _this.selectors
                        .filter(function (element) { return !!element.callback; })
                        .forEach(function (element) {
                        if (eligibleEntries.find(function (entry) {
                            return _this.yjQuery(entry.target).is(element.selector);
                        })) {
                            element.callback();
                        }
                    });
                });
            }
            // Observing all eligible components that are already in the page.
            // Note that when an element visible in the viewport is removed, the Intersection Callback is called so we don't need to use the Mutation Observe to oberser removal of Nodes.
            this._getEligibleElements().forEach(function (component) {
                _this.intersectionObserver.observe(component);
            });
        }
    };
    /*
     * Method used in mutationObserverCallback that extracts from mutations the list of added and removed nodes
     */
    /* @ngInject */ InViewElementObserver.prototype._aggregateAddedOrRemovedNodes = function (mutations, addedOnes) {
        var _this = this;
        var entries = lodash.flatten(mutations
            .filter(function (mutation) {
            // only keep mutations of type childList and addedNodes
            return mutation.type === MUTATION_TYPES.CHILD_LIST.NAME &&
                ((!!addedOnes && mutation.addedNodes && mutation.addedNodes.length) ||
                    (!addedOnes && mutation.removedNodes && mutation.removedNodes.length));
        })
            .map(function (mutation) {
            var children = lodash.flatten(Array.prototype.slice
                .call(addedOnes ? mutation.addedNodes : mutation.removedNodes)
                .filter(function (node) { return node.nodeType === Node.ELEMENT_NODE; })
                .map(function (child) {
                var eligibleChildren = _this._getAllEligibleChildren(child);
                return _this._isEligibleComponent(child)
                    ? [child].concat(eligibleChildren)
                    : eligibleChildren;
            }))
                .sort(nodeUtils.compareHTMLElementsPosition())
                // so that in case of nested eligible components the deeper element is picked
                .reverse();
            return children;
        }));
        /*
         * Despite MutationObserver specifications it so happens that sometimes,
         * depending on the very way a parent node is added with its children,
         * parent AND children will appear in a same mutation. We then must only keep the parent
         * Since the parent will appear first, the filtering lodash.uniqWith will always return the parent as opposed to the child which is what we need
         */
        return lodash.uniqWith(entries, function (entry1, entry2) {
            return entry1.contains(entry2) || entry2.contains(entry1);
        });
    };
    InViewElementObserver.prototype._aggregateAddedOrRemovedNodes.$inject = ["mutations", "addedOnes"];
    /*
     * Method used in mutationObserverCallback that extracts from mutations the list of nodes that have a mutation in the class attribute value
     */
    /* @ngInject */ InViewElementObserver.prototype._aggregateMutationsOnClass = function (mutations, addedOnes) {
        var _this = this;
        return lodash.compact(mutations
            .filter(function (mutation) {
            return mutation.target &&
                mutation.target.nodeType === Node.ELEMENT_NODE &&
                mutation.type === MUTATION_TYPES.ATTRIBUTES.NAME &&
                mutation.attributeName === 'class';
        })
            .map(function (mutation) {
            if (addedOnes && _this._isEligibleComponent(mutation.target)) {
                return mutation.target;
            }
            else if (!addedOnes &&
                _this._isEligibleComponent(mutation.target)) {
                return mutation.target;
            }
            return null;
        }));
    };
    InViewElementObserver.prototype._aggregateMutationsOnClass.$inject = ["mutations", "addedOnes"];
    /*
     * callback executed by the mutation observer every time mutations occur.
     * repositioning and resizing are not part of this except that every time a eligible component is added,
     * it is registered within the positionRegistry and the resizeListener
     */
    /* @ngInject */ InViewElementObserver.prototype._mutationObserverCallback = function (mutations) {
        var _this = this;
        this.logService.debug(mutations);
        this._aggregateAddedOrRemovedNodes(mutations, true).forEach(function (node) {
            _this.intersectionObserver.observe(node);
        });
        if (this.hasClassBasedSelectors) {
            this._aggregateMutationsOnClass(mutations, true).forEach(function (node) {
                _this.intersectionObserver.observe(node);
            });
        }
        this._aggregateAddedOrRemovedNodes(mutations, false).forEach(function (node) {
            var componentIndex = _this._getComponentIndexInQueue(node);
            if (componentIndex !== -1) {
                _this.componentsQueue.splice(componentIndex, 1);
            }
        });
        if (this.hasClassBasedSelectors) {
            this._aggregateMutationsOnClass(mutations, false).forEach(function (node) {
                var componentIndex = _this._getComponentIndexInQueue(node);
                if (componentIndex !== -1) {
                    _this.componentsQueue.splice(componentIndex, 1);
                }
            });
        }
    };
    InViewElementObserver.prototype._mutationObserverCallback.$inject = ["mutations"];
    /*
     * Add the given entry to the componentsQueue
     * The components in the queue are sorted according to their position in the DOM
     * so that the adding of components is done to have parents before children
     */
    /* @ngInject */ InViewElementObserver.prototype._updateQueue = function (entry) {
        var componentIndex = this._getComponentIndexInQueue(entry.target);
        if (componentIndex !== -1) {
            if (!entry.intersectionRatio && !this._isInDOM(entry.target)) {
                this.componentsQueue.splice(componentIndex, 1);
            }
            else {
                this.componentsQueue[componentIndex].isIntersecting = !!entry.intersectionRatio;
            }
        }
        else if (this._isInDOM(entry.target)) {
            // may have been removed by competing MutationObserver hence showign here but not intersecting
            this.componentsQueue.push({
                component: entry.target,
                isIntersecting: !!entry.intersectionRatio
            });
        }
    };
    InViewElementObserver.prototype._updateQueue.$inject = ["entry"];
    /// ///////////////////////////////////////////////////////////////////////////////////
    /// ///////////////////////////// HELPER METHODS //////////////////////////////////////
    /// ///////////////////////////////////////////////////////////////////////////////////
    /*
     * wrapping for test purposes
     */
    /* @ngInject */ InViewElementObserver.prototype._newMutationObserver = function (callback) {
        var mutationObserver = new MutationObserver(callback);
        mutationObserver.observe(this.document.body, lodash.merge(lodash.cloneDeep(IN_VIEW_ELEMENTS_MUTATION_OBSERVER_OPTIONS), {
            attributes: this.hasClassBasedSelectors
        }));
        return mutationObserver;
    };
    InViewElementObserver.prototype._newMutationObserver.$inject = ["callback"];
    /*
     * wrapping for test purposes
     */
    /* @ngInject */ InViewElementObserver.prototype._newIntersectionObserver = function (callback) {
        return new IntersectionObserver(callback, IN_VIEW_ELEMENTS_INTERSECTION_OBSERVER_OPTIONS);
    };
    InViewElementObserver.prototype._newIntersectionObserver.$inject = ["callback"];
    /* @ngInject */ InViewElementObserver.prototype._getJQuerySelector = function () {
        return this.selectors.map(function (el) { return el.selector; }).join(',');
    };
    /* @ngInject */ InViewElementObserver.prototype._isEligibleComponent = function (component) {
        return this.yjQuery(component).is(this._getJQuerySelector());
    };
    InViewElementObserver.prototype._isEligibleComponent.$inject = ["component"];
    /* @ngInject */ InViewElementObserver.prototype._getEligibleElements = function () {
        return Array.prototype.slice.call(this.yjQuery(this._getJQuerySelector()));
    };
    /* @ngInject */ InViewElementObserver.prototype._getAllEligibleChildren = function (component) {
        return Array.prototype.slice.call(component.querySelectorAll(this._getJQuerySelector()));
    };
    InViewElementObserver.prototype._getAllEligibleChildren.$inject = ["component"];
    /* @ngInject */ InViewElementObserver.prototype._getComponentIndexInQueue = function (component) {
        return this.componentsQueue.findIndex(function (obj) {
            return component === obj.component;
        });
    };
    InViewElementObserver.prototype._getComponentIndexInQueue.$inject = ["component"];
    /* @ngInject */ InViewElementObserver.prototype._isInDOM = function (component) {
        return this.yjQuery.contains(this.document.body, component);
    };
    InViewElementObserver.prototype._isInDOM.$inject = ["component"];
    /* @ngInject */ InViewElementObserver = __decorate([
        SeDowngradeService(),
        __param(1, core.Inject(common.DOCUMENT)),
        __param(2, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [utils.LogService,
            Document, Function])
    ], /* @ngInject */ InViewElementObserver);
    return /* @ngInject */ InViewElementObserver;
}());

/**
 * @internal
 * @ignore
 */
var /* @ngInject */ DragAndDropScrollingService = /** @class */ (function () {
    DragAndDropScrollingService.$inject = ["windowUtils", "translate", "inViewElementObserver", "yjQuery"];
    function /* @ngInject */ DragAndDropScrollingService(windowUtils, translate, inViewElementObserver, yjQuery) {
        this.windowUtils = windowUtils;
        this.translate = translate;
        this.inViewElementObserver = inViewElementObserver;
        this.yjQuery = yjQuery;
        this.SCROLLING_AREA_HEIGHT = 50;
        this.FAST_SCROLLING_AREA_HEIGHT = 25;
        this.SCROLLING_STEP = 5;
        this.FAST_SCROLLING_STEP = 15;
        this.topScrollArea = null;
        this.bottomScrollArea = null;
        this.throttleScrollingEnabled = false;
        this.inViewElementObserver.addSelector('#' + /* @ngInject */ DragAndDropScrollingService_1.TOP_SCROLL_AREA_ID);
        this.inViewElementObserver.addSelector('#' + /* @ngInject */ DragAndDropScrollingService_1.BOTTOM_SCROLL_AREA_ID);
        this.throttledScrollPage = lodash.throttle(this.scrollPage.bind(this), THROTTLE_SCROLLING_DELAY);
    }
    /* @ngInject */ DragAndDropScrollingService_1 = /* @ngInject */ DragAndDropScrollingService;
    /* @ngInject */ DragAndDropScrollingService.prototype.initialize = function () {
        this.scrollable = this.getSelector(this.windowUtils.getWindow().document.scrollingElement);
        this.addScrollAreas();
        this.addEventListeners();
        this.scrollDelta = 0;
        this.initialized = true;
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.deactivate = function () {
        this.removeEventListeners();
        this.scrollDelta = 0;
        this.initialized = false;
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.enable = function () {
        if (this.initialized) {
            // Calculate limits based on current state.
            this.scrollLimitY =
                this.scrollable.get(0).scrollHeight - this.windowUtils.getWindow().innerHeight;
            this.showScrollAreas();
        }
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.disable = function () {
        if (this.initialized) {
            var scrollAreas = this.getScrollAreas();
            // following trigger necessary to remove scrollable areas when loosing track of the mouse from the outer layer
            scrollAreas.trigger('dragleave');
            scrollAreas.hide();
        }
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.toggleThrottling = function (isEnabled) {
        this.throttleScrollingEnabled = isEnabled;
    };
    DragAndDropScrollingService.prototype.toggleThrottling.$inject = ["isEnabled"];
    /* @ngInject */ DragAndDropScrollingService.prototype.addScrollAreas = function () {
        var _this = this;
        this.topScrollArea = this.getSelector('<div id="' +
            /* @ngInject */ DragAndDropScrollingService_1.TOP_SCROLL_AREA_ID +
            '" class="' +
            SCROLL_AREA_CLASS +
            '"></div>').appendTo('body');
        this.bottomScrollArea = this.getSelector('<div id="' +
            /* @ngInject */ DragAndDropScrollingService_1.BOTTOM_SCROLL_AREA_ID +
            '" class="' +
            SCROLL_AREA_CLASS +
            '"></div>').appendTo('body');
        var scrollAreas = this.getScrollAreas();
        scrollAreas.height(this.SCROLLING_AREA_HEIGHT);
        this.topScrollArea.css({
            top: 0
        });
        this.bottomScrollArea.css({
            bottom: 0
        });
        scrollAreas.hide();
        var topMessage;
        var bottomMessage;
        return this.translate
            .get('se.draganddrop.uihint.top')
            .toPromise()
            .then(function (localizedTopMessage) {
            topMessage = localizedTopMessage;
            return _this.translate.get('se.draganddrop.uihint.bottom').toPromise();
        })
            .then(function (localizedBottomMsg) {
            bottomMessage = localizedBottomMsg;
            _this.topScrollArea.text(topMessage);
            _this.bottomScrollArea.text(bottomMessage);
        });
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.addEventListeners = function () {
        var scrollAreas = this.getScrollAreas();
        scrollAreas.on('dragenter', this.onDragEnter.bind(this));
        scrollAreas.on('dragover', this.onDragOver.bind(this));
        scrollAreas.on('dragleave', this.onDragLeave.bind(this));
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.removeEventListeners = function () {
        var scrollAreas = this.getScrollAreas();
        scrollAreas.off('dragenter');
        scrollAreas.off('dragover');
        scrollAreas.off('dragleave');
        scrollAreas.remove();
    };
    // Event Listeners
    /* @ngInject */ DragAndDropScrollingService.prototype.onDragEnter = function (event) {
        var scrollDelta = this.SCROLLING_STEP;
        var scrollArea = this.getSelector(event.target);
        var scrollAreaId = scrollArea.attr('id');
        if (scrollAreaId === /* @ngInject */ DragAndDropScrollingService_1.TOP_SCROLL_AREA_ID) {
            scrollDelta *= -1;
        }
        this.scrollDelta = scrollDelta;
        this.animationFrameId = this.windowUtils
            .getWindow()
            .requestAnimationFrame(this.scrollPage.bind(this));
    };
    DragAndDropScrollingService.prototype.onDragEnter.$inject = ["event"];
    /* @ngInject */ DragAndDropScrollingService.prototype.onDragOver = function (evt) {
        var event = evt.originalEvent;
        var scrollArea = this.getSelector(event.target);
        var scrollAreaId = scrollArea.attr('id');
        if (scrollAreaId === /* @ngInject */ DragAndDropScrollingService_1.TOP_SCROLL_AREA_ID) {
            if (event.clientY <= this.FAST_SCROLLING_AREA_HEIGHT) {
                this.scrollDelta = -this.FAST_SCROLLING_STEP;
            }
            else {
                this.scrollDelta = -this.SCROLLING_STEP;
            }
        }
        else {
            var windowHeight = this.windowUtils.getWindow().innerHeight;
            if (event.clientY >= windowHeight - this.FAST_SCROLLING_AREA_HEIGHT) {
                this.scrollDelta = this.FAST_SCROLLING_STEP;
            }
            else {
                this.scrollDelta = this.SCROLLING_STEP;
            }
        }
    };
    DragAndDropScrollingService.prototype.onDragOver.$inject = ["evt"];
    /* @ngInject */ DragAndDropScrollingService.prototype.onDragLeave = function () {
        this.scrollDelta = 0;
        this.windowUtils.getWindow().cancelAnimationFrame(this.animationFrameId);
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.scrollPage = function () {
        if (this.scrollDelta) {
            var scrollTop = this.scrollable.scrollTop();
            var continueScrolling = false;
            if (this.scrollDelta > 0 && scrollTop < this.scrollLimitY) {
                continueScrolling = true;
            }
            else if (this.scrollDelta < 0 && scrollTop > 0) {
                continueScrolling = true;
            }
            if (continueScrolling) {
                var current = this.scrollable.scrollTop();
                var next = current + this.scrollDelta;
                this.scrollable.scrollTop(next);
                this.animationFrameId = this.windowUtils
                    .getWindow()
                    .requestAnimationFrame(this.throttleScrollingEnabled
                    ? this.throttledScrollPage
                    : this.scrollPage.bind(this));
            }
            this.showScrollAreas();
        }
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.getSelector = function (selector) {
        return this.yjQuery(selector);
    };
    DragAndDropScrollingService.prototype.getSelector.$inject = ["selector"];
    /* @ngInject */ DragAndDropScrollingService.prototype.getScrollAreas = function () {
        return this.yjQuery([
            '#' + /* @ngInject */ DragAndDropScrollingService_1.TOP_SCROLL_AREA_ID,
            '#' + /* @ngInject */ DragAndDropScrollingService_1.BOTTOM_SCROLL_AREA_ID
        ].join(','));
    };
    /* @ngInject */ DragAndDropScrollingService.prototype.showScrollAreas = function () {
        var scrollTop = this.scrollable.scrollTop();
        if (scrollTop === 0) {
            this.topScrollArea.hide();
        }
        else {
            this.topScrollArea.show();
        }
        if (scrollTop >= this.scrollLimitY) {
            this.bottomScrollArea.hide();
        }
        else {
            this.bottomScrollArea.show();
        }
    };
    var /* @ngInject */ DragAndDropScrollingService_1;
    /* @ngInject */ DragAndDropScrollingService.TOP_SCROLL_AREA_ID = 'top_scroll_page';
    /* @ngInject */ DragAndDropScrollingService.BOTTOM_SCROLL_AREA_ID = 'bottom_scroll_page';
    /* @ngInject */ DragAndDropScrollingService = /* @ngInject */ DragAndDropScrollingService_1 = __decorate([
        SeDowngradeService(),
        __param(3, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [utils.WindowUtils,
            core$1.TranslateService,
            InViewElementObserver, Function])
    ], /* @ngInject */ DragAndDropScrollingService);
    return /* @ngInject */ DragAndDropScrollingService;
}());

var /* @ngInject */ DragAndDropService = /** @class */ (function () {
    DragAndDropService.$inject = ["yjQuery", "dragAndDropScrollingService", "inViewElementObserver", "systemEventService", "dragAndDropCrossOrigin"];
    function /* @ngInject */ DragAndDropService(yjQuery, dragAndDropScrollingService, inViewElementObserver, systemEventService, dragAndDropCrossOrigin) {
        this.yjQuery = yjQuery;
        this.dragAndDropScrollingService = dragAndDropScrollingService;
        this.inViewElementObserver = inViewElementObserver;
        this.systemEventService = systemEventService;
        this.dragAndDropCrossOrigin = dragAndDropCrossOrigin;
        this.configurations = {};
        this.isDragAndDropExecuting = false;
        this.dragAndDropCrossOrigin.initialize();
    }
    /* @ngInject */ DragAndDropService_1 = /* @ngInject */ DragAndDropService;
    /**
     * This method registers a new instance of the drag and drop service.
     * Note: Registering doesn't start the service. It just provides the configuration, which later must be applied with the apply method.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.register = function (configuration) {
        // Validate
        if (!configuration || !configuration.id) {
            throw new Error('dragAndDropService - register(): Configuration needs an ID.');
        }
        this.configurations[configuration.id] = configuration;
        if (!utils.stringUtils.isBlank(configuration.targetSelector)) {
            this.inViewElementObserver.addSelector(configuration.targetSelector);
        }
    };
    DragAndDropService.prototype.register.$inject = ["configuration"];
    /**
     * This method removes the drag and drop instances specified by the provided IDs.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.unregister = function (configurationsIDList) {
        var _this = this;
        configurationsIDList.forEach(function (configurationID) {
            var configuration = _this.configurations[configurationID];
            if (configuration) {
                _this.deactivateConfiguration(configuration);
                _this.deactivateScrolling(configuration);
                delete _this.configurations[configurationID];
            }
        });
    };
    DragAndDropService.prototype.unregister.$inject = ["configurationsIDList"];
    /**
     * This method applies all drag and drop configurations registered.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.applyAll = function () {
        var _this = this;
        lodash.forEach(this.configurations, function (currentConfig) {
            _this.apply(currentConfig.id);
        });
    };
    /**
     * This method apply the configuration specified by the provided ID in the current page. After this method is executed drag and drop can be started by the user.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.apply = function (configurationID) {
        var configuration = this.configurations[configurationID];
        if (configuration) {
            this.update(configuration.id);
            this.cacheDragImages(configuration);
            this.initializeScrolling(configuration);
        }
    };
    DragAndDropService.prototype.apply.$inject = ["configurationID"];
    /**
     * This method updates the drag and drop instance specified by the provided ID in the current page. It is important to execute this method every time a draggable or droppable element
     * is added or removed from the page DOM.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.update = function (configurationID) {
        var configuration = this.configurations[configurationID];
        if (configuration) {
            this.deactivateConfiguration(configuration);
            this._update(configuration);
        }
    };
    DragAndDropService.prototype.update.$inject = ["configurationID"];
    /**
     * This method forces the page to prepare for a drag and drop operation. This method is necessary when the drag and drop operation is started somewhere else,
     * like on a different iFrame.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.markDragStarted = function () {
        this.setDragAndDropExecutionStatus(true);
        this.dragAndDropScrollingService.enable();
    };
    // Method used to stop drag and drop from another frame.
    /**
     * This method forces the page to clean after a drag and drop operation. This method is necessary when the drag and drop operation is stopped somewhere else,
     * like on a different iFrame.
     *
     */
    /* @ngInject */ DragAndDropService.prototype.markDragStopped = function () {
        this.setDragAndDropExecutionStatus(false);
        this.dragAndDropScrollingService.disable();
    };
    /* @ngInject */ DragAndDropService.prototype._update = function (configuration) {
        var _this = this;
        var sourceSelectors = lodash.isArray(configuration.sourceSelector)
            ? configuration.sourceSelector
            : [configuration.sourceSelector];
        sourceSelectors.forEach(function (sourceSelector) {
            var draggableElements = _this.getSelector(sourceSelector + ':not([draggable])');
            draggableElements.attr(/* @ngInject */ DragAndDropService_1.DRAGGABLE_ATTR, 'true');
            draggableElements.on('dragstart', _this.onDragStart.bind(_this, configuration));
            draggableElements.on('dragend', _this.onDragEnd.bind(_this, configuration));
        });
        var droppableElements = this.getSelector(configuration.targetSelector + ':not([draggable])');
        droppableElements.attr(/* @ngInject */ DragAndDropService_1.DROPPABLE_ATTR, 'true'); // Not needed by HTML5. It's to mark element as processed.
        droppableElements.on('dragenter', this.onDragEnter.bind(this, configuration));
        droppableElements.on('dragover', this.onDragOver.bind(this, configuration));
        droppableElements.on('drop', this.onDrop.bind(this, configuration));
        droppableElements.on('dragleave', this.onDragLeave.bind(this, configuration));
    };
    DragAndDropService.prototype._update.$inject = ["configuration"];
    /* @ngInject */ DragAndDropService.prototype.deactivateConfiguration = function (configuration) {
        var sourceSelectors = Array.isArray(configuration.sourceSelector)
            ? configuration.sourceSelector.join(',')
            : configuration.sourceSelector;
        var draggableElements = this.getSelector(sourceSelectors);
        var droppableElements = this.getSelector(configuration.targetSelector);
        draggableElements.removeAttr(/* @ngInject */ DragAndDropService_1.DRAGGABLE_ATTR);
        droppableElements.removeAttr(/* @ngInject */ DragAndDropService_1.DROPPABLE_ATTR);
        draggableElements.off('dragstart');
        draggableElements.off('dragend');
        droppableElements.off('dragenter');
        droppableElements.off('dragover');
        droppableElements.off('dragleave');
        droppableElements.off('drop');
    };
    DragAndDropService.prototype.deactivateConfiguration.$inject = ["configuration"];
    // Draggable Listeners
    /* @ngInject */ DragAndDropService.prototype.onDragStart = function (configuration, yjQueryEvent) {
        var _this = this;
        // The native transferData object is modified outside the setTimeout since it can only be modified
        // inside the dragStart event handler (otherwise an exception is thrown by the browser).
        var evt = yjQueryEvent.originalEvent;
        this.setDragTransferData(configuration, evt);
        // Necessary because there's a bug in Chrome (and probably Safari) where dragEnd is triggered right after
        // dragStart whenever DOM is modified in the event handler. The problem can be circumvented by using setTimeout.
        setTimeout(function () {
            var component = _this.yjQuery(yjQueryEvent.target).closest('.' + OVERLAY_COMPONENT_CLASS);
            _this.setDragAndDropExecutionStatus(true, component);
            _this.dragAndDropScrollingService.enable();
            if (configuration.startCallback) {
                configuration.startCallback(evt);
            }
        }, 0);
    };
    DragAndDropService.prototype.onDragStart.$inject = ["configuration", "yjQueryEvent"];
    /* @ngInject */ DragAndDropService.prototype.onDragEnd = function (configuration, yjQueryEvent) {
        var evt = yjQueryEvent.originalEvent;
        this.dragAndDropScrollingService.disable();
        if (this.isDragAndDropExecuting && configuration.stopCallback) {
            configuration.stopCallback(evt);
        }
        this.setDragAndDropExecutionStatus(false);
    };
    DragAndDropService.prototype.onDragEnd.$inject = ["configuration", "yjQueryEvent"];
    // Droppable Listeners
    /* @ngInject */ DragAndDropService.prototype.onDragEnter = function (configuration, yjQueryEvent) {
        var evt = yjQueryEvent.originalEvent;
        evt.preventDefault();
        if (this.isDragAndDropExecuting && configuration.dragEnterCallback) {
            configuration.dragEnterCallback(evt);
        }
    };
    DragAndDropService.prototype.onDragEnter.$inject = ["configuration", "yjQueryEvent"];
    /* @ngInject */ DragAndDropService.prototype.onDragOver = function (configuration, yjQueryEvent) {
        var evt = yjQueryEvent.originalEvent;
        evt.preventDefault();
        if (this.isDragAndDropExecuting && configuration.dragOverCallback) {
            configuration.dragOverCallback(evt);
        }
    };
    DragAndDropService.prototype.onDragOver.$inject = ["configuration", "yjQueryEvent"];
    /* @ngInject */ DragAndDropService.prototype.onDrop = function (configuration, yjQueryEvent) {
        var evt = yjQueryEvent.originalEvent;
        evt.preventDefault(); // Necessary to receive the on drop event. Otherwise, other handlers are executed.
        evt.stopPropagation();
        if (evt.relatedTarget && evt.relatedTarget.nodeType === 3) {
            return true;
        }
        if (evt.target === evt.relatedTarget) {
            return true;
        }
        if (this.isDragAndDropExecuting && configuration.dropCallback) {
            configuration.dropCallback(evt);
        }
        return false;
    };
    DragAndDropService.prototype.onDrop.$inject = ["configuration", "yjQueryEvent"];
    /* @ngInject */ DragAndDropService.prototype.onDragLeave = function (configuration, yjQueryEvent) {
        var evt = yjQueryEvent.originalEvent;
        evt.preventDefault();
        if (this.isDragAndDropExecuting && configuration.outCallback) {
            configuration.outCallback(evt);
        }
    };
    DragAndDropService.prototype.onDragLeave.$inject = ["configuration", "yjQueryEvent"];
    // Helper Functions
    /* @ngInject */ DragAndDropService.prototype.cacheDragImages = function (configuration) {
        var helperImg;
        if (configuration.helper) {
            helperImg = configuration.helper();
        }
        if (!helperImg) {
            return;
        }
        if (typeof helperImg === 'string') {
            configuration._cachedDragImage = new Image();
            configuration._cachedDragImage.src = helperImg;
        }
        else {
            configuration._cachedDragImage = helperImg;
        }
    };
    DragAndDropService.prototype.cacheDragImages.$inject = ["configuration"];
    /* @ngInject */ DragAndDropService.prototype.setDragTransferData = function (configuration, evt) {
        // Note: Firefox recently added some restrictions to their drag and drop functionality; it only
        // allows starting drag and drop operations if there's data present in the dataTransfer object.
        // Otherwise, the whole operation fails silently. Thus, some data needs to be added.
        evt.dataTransfer.setData('Text', configuration.id);
        if (configuration._cachedDragImage && evt.dataTransfer.setDragImage) {
            evt.dataTransfer.setDragImage(configuration._cachedDragImage, 0, 0);
        }
    };
    DragAndDropService.prototype.setDragTransferData.$inject = ["configuration", "evt"];
    /* @ngInject */ DragAndDropService.prototype.getSelector = function (selector) {
        return this.yjQuery(selector);
    };
    DragAndDropService.prototype.getSelector.$inject = ["selector"];
    /* @ngInject */ DragAndDropService.prototype.setDragAndDropExecutionStatus = function (isExecuting, element) {
        this.isDragAndDropExecuting = isExecuting;
        this.systemEventService.publish(isExecuting
            ? SMARTEDIT_DRAG_AND_DROP_EVENTS.DRAG_DROP_START
            : SMARTEDIT_DRAG_AND_DROP_EVENTS.DRAG_DROP_END, element);
    };
    DragAndDropService.prototype.setDragAndDropExecutionStatus.$inject = ["isExecuting", "element"];
    /* @ngInject */ DragAndDropService.prototype.initializeScrolling = function (configuration) {
        if (configuration.enableScrolling && this.browserRequiresCustomScrolling()) {
            this.dragAndDropScrollingService.initialize();
        }
    };
    DragAndDropService.prototype.initializeScrolling.$inject = ["configuration"];
    /* @ngInject */ DragAndDropService.prototype.deactivateScrolling = function (configuration) {
        if (configuration.enableScrolling && this.browserRequiresCustomScrolling()) {
            this.dragAndDropScrollingService.deactivate();
        }
    };
    DragAndDropService.prototype.deactivateScrolling.$inject = ["configuration"];
    /* @ngInject */ DragAndDropService.prototype.browserRequiresCustomScrolling = function () {
        // NOTE: It'd be better to identify if native scrolling while dragging is enabled in the browser, but
        // currently there's no way to know. Thus, browser fixing is necessary.
        return true;
    };
    var /* @ngInject */ DragAndDropService_1;
    /* @ngInject */ DragAndDropService.DRAGGABLE_ATTR = 'draggable';
    /* @ngInject */ DragAndDropService.DROPPABLE_ATTR = 'data-droppable';
    /* @ngInject */ DragAndDropService = /* @ngInject */ DragAndDropService_1 = __decorate([
        SeDowngradeService(),
        __param(0, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [Function, DragAndDropScrollingService,
            InViewElementObserver,
            SystemEventService,
            IDragAndDropCrossOrigin])
    ], /* @ngInject */ DragAndDropService);
    return /* @ngInject */ DragAndDropService;
}());

/**
 * Contains a service that provides a rich drag and drop experience tailored for CMS operations.
 */
var DragAndDropServiceModule = /** @class */ (function () {
    function DragAndDropServiceModule() {
    }
    DragAndDropServiceModule = __decorate([
        core.NgModule({
            providers: [InViewElementObserver, DragAndDropScrollingService, DragAndDropService]
        })
    ], DragAndDropServiceModule);
    return DragAndDropServiceModule;
}());

// eslint-disable-next-line no-redeclare
var IDragEventType = {
    DROP: 'drop',
    DRAG_ENTER: 'dragenter',
    DRAG_OVER: 'dragover',
    DRAG_LEAVE: 'dragleave'
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * @internal
 * @ignore
 */
var StorageNamespaceConverter = /** @class */ (function () {
    function StorageNamespaceConverter() {
    }
    StorageNamespaceConverter.ERR_INVALID_NAMESPACED_ID = function (id) {
        return new Error("StorageNamespaceConverter - Invalid namespaced id [" + id + "]");
    };
    StorageNamespaceConverter.getNamespacedStorageId = function (namespace, storageId) {
        return "" + namespace + this.separator + storageId;
    };
    StorageNamespaceConverter.getStorageIdFromNamespacedId = function (namespacedId) {
        var matches = namespacedId.match(new RegExp(this.namespaceDecoderRegexStr));
        if (matches && matches[2].length > 0) {
            return matches[2];
        }
        throw StorageNamespaceConverter.ERR_INVALID_NAMESPACED_ID(namespacedId);
    };
    StorageNamespaceConverter.getNamespaceFromNamespacedId = function (namespacedId) {
        var matches = namespacedId.match(new RegExp(this.namespaceDecoderRegexStr));
        if (matches && matches[1].length > 0) {
            return matches[1];
        }
        throw StorageNamespaceConverter.ERR_INVALID_NAMESPACED_ID(namespacedId);
    };
    /**
     * Given:
     *  namespace = nmsp
     *  storageId = stoid
     *
     * Produces:
     *  newStorageId = nmsp<ns:id>stoid
     *
     * Fastest implementation I could think of that (most likely) will not clash with weird storageIds
     *
     * This algorithm is a bit overly simple, and assumes that neither storageId nor namespace contains "<ns:id>"
     * I think this is a fairly safe assumption, but if we have time in the future, we should escape any existing
     * matches of the string.
     */
    StorageNamespaceConverter.separator = '<ns:id>';
    StorageNamespaceConverter.namespaceDecoderRegexStr = '(.*)' + StorageNamespaceConverter.separator + '(.*)';
    return StorageNamespaceConverter;
}());

/**
 * @internal
 * @ignore
 */
var NamespacedStorageManager = /** @class */ (function () {
    function NamespacedStorageManager(storageManager, namespace) {
        this.storageManager = storageManager;
        this.namespace = namespace;
    }
    NamespacedStorageManager.prototype.getStorage = function (storageConfiguration) {
        storageConfiguration.storageId = this.getNamespaceStorageId(storageConfiguration.storageId);
        return this.storageManager.getStorage(storageConfiguration);
    };
    NamespacedStorageManager.prototype.deleteStorage = function (storageId, force) {
        if (force === void 0) { force = false; }
        return this.storageManager.deleteStorage(this.getNamespaceStorageId(storageId), force);
    };
    NamespacedStorageManager.prototype.deleteExpiredStorages = function (force) {
        if (force === void 0) { force = false; }
        return this.storageManager.deleteExpiredStorages(force);
    };
    NamespacedStorageManager.prototype.hasStorage = function (storageId) {
        return this.storageManager.hasStorage(this.getNamespaceStorageId(storageId));
    };
    NamespacedStorageManager.prototype.registerStorageController = function (controller) {
        return this.storageManager.registerStorageController(controller);
    };
    NamespacedStorageManager.prototype.getNamespaceStorageId = function (storageId) {
        return StorageNamespaceConverter.getNamespacedStorageId(this.namespace, storageId);
    };
    NamespacedStorageManager.prototype.getStorageManager = function () {
        return this.storageManager;
    };
    return NamespacedStorageManager;
}());

/**
 * @internal
 * @ignore
 */
var StorageManagerFactory = /** @class */ (function () {
    function StorageManagerFactory(theOneAndOnlyStorageManager) {
        this.theOneAndOnlyStorageManager = theOneAndOnlyStorageManager;
    }
    StorageManagerFactory.ERR_INVALID_NAMESPACE = function (namespace) {
        return new Error("StorageManagerFactory Error: invalid namespace [" + namespace + "]. Namespace must be a non-empty string");
    };
    StorageManagerFactory.prototype.getStorageManager = function (namespace) {
        this.validateNamespace(namespace);
        return new NamespacedStorageManager(this.theOneAndOnlyStorageManager, namespace);
    };
    StorageManagerFactory.prototype.validateNamespace = function (namespace) {
        if (typeof namespace !== 'string' || namespace.length <= 0) {
            throw StorageManagerFactory.ERR_INVALID_NAMESPACE(namespace);
        }
    };
    return StorageManagerFactory;
}());

var IStorageGateway = /** @class */ (function () {
    function IStorageGateway() {
    }
    IStorageGateway.prototype.handleStorageRequest = function (storageConfiguration, method, args) {
        'proxyFunction';
        return Promise.resolve();
    };
    return IStorageGateway;
}());

/**
 * Represents a manager of multiple {@link IStorage}(s).
 *
 * Typically there is 1 StorageManager in the system, and it is responsible accessing, creating and deleting storages,
 * usually by delegating to {@link IStorageController}(s).
 *
 */
var IStorageManager = /** @class */ (function () {
    function IStorageManager() {
    }
    IStorageManager.prototype.registerStorageController = function (controller) {
        'proxyFunction';
    };
    /**
     * Check if a storage has been created.
     */
    IStorageManager.prototype.hasStorage = function (storageId) {
        'proxyFunction';
        return null;
    };
    /**
     * Get an existing or new storage
     */
    IStorageManager.prototype.getStorage = function (storageConfiguration) {
        'proxyFunction';
        return null;
    };
    /**
     * Permanently delete a storage and all its data
     *
     * @param force If force is false and a storage is found with no storage controller to handle its
     * type then it will not be deleted. This can be useful in some cases when you haven't registered a controller yet.
     */
    IStorageManager.prototype.deleteStorage = function (storageId, force) {
        'proxyFunction';
        return Promise.resolve(true);
    };
    /**
     * Delete all storages that have exceeded their idle timeout time.
     * See {@link IStorageOptions} for more details
     * @param force If force is false and a storage is found with no storage controller to handle its
     * type then it will not be deleted. This can be useful in some cases when you haven't registered a controller yet.
     */
    IStorageManager.prototype.deleteExpiredStorages = function (force) {
        'proxyFunction';
        return Promise.resolve(true);
    };
    return IStorageManager;
}());

/**
 * Represents a typical factory of {@link IStorageManager}(s).
 * There should typically only be 1 StorageManager in the system, which make this factory seem redundant, but it's used
 * to create wrapper around the single real StorageManager.
 *
 * The main use-case is for namespacing. A namespaced storagemanager will take care to prevent storageID clashes
 * between extensions or teams.
 */
var IStorageManagerFactory = /** @class */ (function () {
    function IStorageManagerFactory() {
    }
    /**
     * @param namespace A unique namespace for all your storage ids
     */
    IStorageManagerFactory.prototype.getStorageManager = function (namespace) {
        'proxyFunction';
        return null;
    };
    return IStorageManagerFactory;
}());

var IStorageManagerGateway = /** @class */ (function (_super) {
    __extends(IStorageManagerGateway, _super);
    function IStorageManagerGateway() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IStorageManagerGateway.prototype.getStorageSanitityCheck = function (storageConfiguration) {
        'proxyFunction';
        return Promise.resolve(true);
    };
    return IStorageManagerGateway;
}(IStorageManager));

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Interface for the AngularJS provider that allows you to mutate the default
 * storage properties before the storage system is initialized.
 */
var IStoragePropertiesService = /** @class */ (function () {
    function IStoragePropertiesService() {
    }
    IStoragePropertiesService.prototype.getProperty = function (propertyName) {
        'proxyFunction';
        return null;
    };
    return IStoragePropertiesService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var STORAGE_PROPERTIES_TOKEN = new core.InjectionToken('storageProperties');
var DO_NOT_USE_STORAGE_MANAGER_TOKEN = new core.InjectionToken('doNotUseStorageManager');

/**
 * Provides a Timer object that can invoke a callback after a certain period of time.
 *
 * A `Timer` must be instanciated calling **`timerService.createTimer()`**.
 * This `Timer` service uses native setInterval function and adds additional functions to it.
 */
var Timer = /** @class */ (function () {
    /**
     * @param _callback Callback function that will be invoked upon timeout.
     * @param _duration The number of milliseconds to wait before the callback is invoked.
     */
    function Timer(zone, _callback, _duration) {
        if (_duration === void 0) { _duration = 1000; }
        this.zone = zone;
        this._callback = _callback;
        this._duration = _duration;
        /**
         * Keeps the interval reference. This will only be non-null when the
         * timer is actively counting down to callback invocation
         */
        this._timer = null;
    }
    /**
     * Returns true if the timer is active (counting down).
     */
    Timer.prototype.isActive = function () {
        return !!this._timer;
    };
    /**
     * Stops the timer, and then starts it again. If a new duration is given, the timer's duration will be set to that new value.
     *
     * @param duration The new number of milliseconds to wait before the callback is invoked.
     * If not provided, the previously set duration is used.
     */
    Timer.prototype.restart = function (duration) {
        this._duration = duration || this._duration;
        this.stop();
        this.start();
    };
    /**
     * Start the timer, which will invoke the callback upon timeout.
     *
     * @param duration The new number of milliseconds to wait before the callback is invoked.
     * If not provided, the previously set duration is used.
     */
    Timer.prototype.start = function (duration) {
        var _this = this;
        this._duration = duration || this._duration;
        this.zone.runOutsideAngular(function () {
            _this._timer = setInterval(function () {
                try {
                    if (_this._callback) {
                        _this._callback();
                    }
                    else {
                        _this.stop();
                    }
                }
                catch (e) {
                    _this.stop();
                }
            }, _this._duration);
        });
    };
    /**
     * Stop the current timer, if it is running, which will prevent the callback from being invoked.
     */
    Timer.prototype.stop = function () {
        clearInterval(this._timer);
        this._timer = null;
    };
    /**
     * Sets the duration to a new value.
     *
     * @param duration The new number of milliseconds to wait before the callback is invoked.
     * If not provided, the previously set duration is used.
     */
    Timer.prototype.resetDuration = function (duration) {
        this._duration = duration || this._duration;
    };
    /**
     * Clean up the internal object references
     */
    Timer.prototype.teardown = function () {
        this.stop();
        this._callback = null;
        this._duration = null;
        this._timer = null;
    };
    return Timer;
}());

var /* @ngInject */ TimerService = /** @class */ (function () {
    TimerService.$inject = ["ngZone"];
    function /* @ngInject */ TimerService(ngZone) {
        this.ngZone = ngZone;
    }
    /* @ngInject */ TimerService.prototype.createTimer = function (callback, duration) {
        return new Timer(this.ngZone, callback, duration);
    };
    TimerService.prototype.createTimer.$inject = ["callback", "duration"];
    /* @ngInject */ TimerService = __decorate([
        SeDowngradeService(),
        core.Injectable(),
        __metadata("design:paramtypes", [core.NgZone])
    ], /* @ngInject */ TimerService);
    return /* @ngInject */ TimerService;
}());

/**
 * Angular utility service for JQuery operations
 */
var /* @ngInject */ JQueryUtilsService = /** @class */ (function () {
    JQueryUtilsService.$inject = ["yjQuery", "document", "EXTENDED_VIEW_PORT_MARGIN", "windowUtils"];
    function /* @ngInject */ JQueryUtilsService(yjQuery, document, EXTENDED_VIEW_PORT_MARGIN, windowUtils) {
        this.yjQuery = yjQuery;
        this.document = document;
        this.EXTENDED_VIEW_PORT_MARGIN = EXTENDED_VIEW_PORT_MARGIN;
        this.windowUtils = windowUtils;
    }
    /**
     * Parses a string HTML into a queriable DOM object
     * @param parent the DOM element from which we want to extract matching selectors
     * @param extractionSelector the yjQuery selector identifying the elements to be extracted
     */
    /* @ngInject */ JQueryUtilsService.prototype.extractFromElement = function (parent, extractionSelector) {
        var element = this.yjQuery(parent);
        return element.filter(extractionSelector).add(element.find(extractionSelector));
    };
    JQueryUtilsService.prototype.extractFromElement.$inject = ["parent", "extractionSelector"];
    /**
     * Parses a string HTML into a queriable DOM object, preserving any JavaScript present in the HTML.
     * Note - as this preserves the JavaScript present it must only be used on HTML strings originating
     * from a known safe location. Failure to do so may result in an XSS vulnerability.
     *
     */
    /* @ngInject */ JQueryUtilsService.prototype.unsafeParseHTML = function (stringHTML) {
        return this.yjQuery.parseHTML(stringHTML, null, true);
    };
    JQueryUtilsService.prototype.unsafeParseHTML.$inject = ["stringHTML"];
    /**
     * Checks whether passed HTMLElement is a part of the DOM
     */
    /* @ngInject */ JQueryUtilsService.prototype.isInDOM = function (element) {
        return this.document.documentElement.contains(element);
    };
    JQueryUtilsService.prototype.isInDOM.$inject = ["element"];
    /**
     *
     * Determines whether a DOM element is partially or totally intersecting with the "extended" viewPort
     * the "extended" viewPort is the real viewPort that extends up and down by a margin, in pixels, given by the overridable constant EXTENDED_VIEW_PORT_MARGIN
     */
    /* @ngInject */ JQueryUtilsService.prototype.isInExtendedViewPort = function (element) {
        if (!this.document.documentElement.contains(element)) {
            return false;
        }
        var elem = this.yjQuery(element);
        var bounds = __assign(__assign({}, elem.offset()), { width: elem.outerWidth(), height: elem.outerHeight() });
        var doc = this.document.scrollingElement || this.document.documentElement;
        return nodeUtils.areIntersecting({
            left: -this.EXTENDED_VIEW_PORT_MARGIN + doc.scrollLeft,
            width: this.windowUtils.getWindow().innerWidth + 2 * this.EXTENDED_VIEW_PORT_MARGIN,
            top: -this.EXTENDED_VIEW_PORT_MARGIN + doc.scrollTop,
            height: this.windowUtils.getWindow().innerHeight + 2 * this.EXTENDED_VIEW_PORT_MARGIN
        }, bounds);
    };
    JQueryUtilsService.prototype.isInExtendedViewPort.$inject = ["element"];
    /* @ngInject */ JQueryUtilsService = __decorate([
        SeDowngradeService(),
        __param(0, core.Inject(YJQUERY_TOKEN)),
        __param(1, core.Inject(common.DOCUMENT)),
        __param(2, core.Inject(EXTENDED_VIEW_PORT_MARGIN_TOKEN)),
        __metadata("design:paramtypes", [Function, Document, Number, WindowUtils])
    ], /* @ngInject */ JQueryUtilsService);
    return /* @ngInject */ JQueryUtilsService;
}());

window.__smartedit__.addDecoratorPayload("Injectable", "L10nService", {
    providedIn: 'root'
});
/**
 * Service which exposes a subscription of the current language.
 */
var /* @ngInject */ L10nService = /** @class */ (function () {
    L10nService.$inject = ["languageService", "crossFrameEventService"];
    function /* @ngInject */ L10nService(languageService, crossFrameEventService) {
        var _this = this;
        this.languageService = languageService;
        this.languageSwitchSubject = new rxjs.BehaviorSubject(null);
        this.languageSwitch$ = this.languageSwitchSubject.asObservable();
        this.unRegSwitchLanguageEvent = crossFrameEventService.subscribe(utils.SWITCH_LANGUAGE_EVENT, function () { return _this.resolveLanguage(); });
    }
    /* @ngInject */ L10nService.prototype.ngOnDestroy = function () {
        this.unRegSwitchLanguageEvent();
        this.languageSwitchSubject.unsubscribe();
    };
    /* @ngInject */ L10nService.prototype.resolveLanguage = function () {
        return __awaiter(this, void 0, void 0, function () {
            var resolvedLanguage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.languageService.getResolveLocaleIsoCode()];
                    case 1:
                        resolvedLanguage = _a.sent();
                        this.languageSwitchSubject.next(resolvedLanguage);
                        return [2 /*return*/];
                }
            });
        });
    };
    /* @ngInject */ L10nService = __decorate([
        SeDowngradeService(),
        core.Injectable({
            providedIn: 'root'
        }),
        __metadata("design:paramtypes", [LanguageService,
            CrossFrameEventService])
    ], /* @ngInject */ L10nService);
    return /* @ngInject */ L10nService;
}());

/** @ignore */
function getLocalizedFilterFn(language) {
    return function (localizedMap) {
        if (typeof localizedMap === 'string') {
            return localizedMap;
        }
        else if (localizedMap) {
            return localizedMap[language] || localizedMap[Object.keys(localizedMap)[0]];
        }
        else {
            return undefined;
        }
    };
}
/**
 * Pipe for translating localized maps for the current language.
 *
 * ### Example
 *
 *      localizedMap = {
 *        en: 'dummyText in english',
 *        fr: 'dummyText in french'
 *      };
 *
 *      {{ localizedMap | seL10n | async }}
 *
 */
var L10nPipe = /** @class */ (function () {
    function L10nPipe(l10nService) {
        this.l10nService = l10nService;
    }
    L10nPipe.prototype.transform = function (localizedMap) {
        var _this = this;
        return this.l10nService.languageSwitch$.pipe(operators.startWith(null), operators.pairwise(), operators.tap(function (_a) {
            var prev = _a[0], curr = _a[1];
            if (prev !== curr) {
                _this.filterFn = getLocalizedFilterFn(curr);
            }
        }), operators.map(function () { return _this.filterFn(localizedMap); }));
    };
    L10nPipe = __decorate([
        core.Pipe({
            name: 'seL10n'
        }),
        __metadata("design:paramtypes", [L10nService])
    ], L10nPipe);
    return L10nPipe;
}());

/**
 * @internal
 * @ignore
 */
function getInitialFilterFn() {
    return (function (str) { return str; });
}
function setupL10nFilter(languageService, crossFrameEventService) {
    var l10n;
    function prepareFilter() {
        return __awaiter(this, void 0, void 0, function () {
            var resolvedLanguage;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        l10n = getInitialFilterFn();
                        l10n.$stateful = false;
                        return [4 /*yield*/, languageService.getResolveLocaleIsoCode()];
                    case 1:
                        resolvedLanguage = _a.sent();
                        l10n = getLocalizedFilterFn(resolvedLanguage);
                        l10n.$stateful = false;
                        return [2 /*return*/];
                }
            });
        });
    }
    prepareFilter();
    crossFrameEventService.subscribe(utils.SWITCH_LANGUAGE_EVENT, prepareFilter);
    return function (localizedMap) { return l10n(localizedMap); };
}
/**
 * **Deprecated since 2005, use {@link L10nPipe}.**
 *
 * Filter that accepts a localized map as input and returns the value corresponding to the resolvedLocale of {@link SmarteditCommonsModule} and defaults to the first entry.
 *
 * This class serves as an interface and should be extended, not instantiated.
 *
 * ### Parameters
 *
 * `l10n` - localizedMap the map of language isocodes / values
 *
 * @deprecated
 */
var L10nFilter = /** @class */ (function () {
    function L10nFilter() {
    }
    L10nFilter.transform = ["languageService", "crossFrameEventService", function (languageService, crossFrameEventService) {
        'ngInject';
        return setupL10nFilter(languageService, crossFrameEventService);
    }];
    L10nFilter = __decorate([
        SeFilter()
    ], L10nFilter);
    return L10nFilter;
}());

var /* @ngInject */ L10nModule = /** @class */ (function () {
    function /* @ngInject */ L10nModule() {
    }
    /* @ngInject */ L10nModule = __decorate([
        SeModule({
            declarations: [L10nFilter]
        })
    ], /* @ngInject */ L10nModule);
    return /* @ngInject */ L10nModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var CATALOG_DETAILS_ITEM_DATA = new core.InjectionToken('CATALOG_DETAILS_ITEM_DATA');

/**
 * A service that is responsible for indicating the bootstrap status of legacy AngularJS application to ensure the
 * legacy dependencies are available.
 */
var /* @ngInject */ AngularJSBootstrapIndicatorService = /** @class */ (function () {
    function /* @ngInject */ AngularJSBootstrapIndicatorService() {
        this._smarteditContainerReady = new rxjs.BehaviorSubject(false);
        this._smarteditReady = new rxjs.BehaviorSubject(false);
    }
    /* @ngInject */ AngularJSBootstrapIndicatorService.prototype.setSmarteditContainerReady = function () {
        this._smarteditContainerReady.next(true);
    };
    /* @ngInject */ AngularJSBootstrapIndicatorService.prototype.setSmarteditReady = function () {
        this._smarteditReady.next(true);
    };
    /**
     * Notifies about the availability of legacySmarteditContainer
     */
    /* @ngInject */ AngularJSBootstrapIndicatorService.prototype.onSmarteditContainerReady = function () {
        return this._smarteditContainerReady.pipe(operators.filter(function (isReady) { return isReady; }));
    };
    /**
     * Notifies about the availability of legacySmartedit
     */
    /* @ngInject */ AngularJSBootstrapIndicatorService.prototype.onSmarteditReady = function () {
        return this._smarteditReady.pipe(operators.filter(function (isReady) { return isReady; }));
    };
    /* @ngInject */ AngularJSBootstrapIndicatorService = __decorate([
        core.Injectable()
    ], /* @ngInject */ AngularJSBootstrapIndicatorService);
    return /* @ngInject */ AngularJSBootstrapIndicatorService;
}());

/**
 * A service responsible for delivering AngularJS dependencies lazily.
 * This is needed because if Angular service uses AngularJS dependencies, and the service is bootstrapped before the initialization of
 * AngularJS the injector error will occur.
 *
 * With AngularJSLazyDependenciesService we request the dependencies only when they are needed.
 */
var /* @ngInject */ AngularJSLazyDependenciesService = /** @class */ (function () {
    AngularJSLazyDependenciesService.$inject = ["upgrade"];
    function /* @ngInject */ AngularJSLazyDependenciesService(upgrade) {
        this.upgrade = upgrade;
    }
    /* @ngInject */ AngularJSLazyDependenciesService.prototype.$injector = function () {
        return this.upgrade.$injector;
    };
    /* @ngInject */ AngularJSLazyDependenciesService.prototype.$templateCache = function () {
        return this.$injector().get('$templateCache');
    };
    /* @ngInject */ AngularJSLazyDependenciesService.prototype.$rootScope = function () {
        return this.$injector().get('$rootScope');
    };
    /* @ngInject */ AngularJSLazyDependenciesService.prototype.$location = function () {
        return this.$injector().get('$location');
    };
    /* @ngInject */ AngularJSLazyDependenciesService = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [_static.UpgradeModule])
    ], /* @ngInject */ AngularJSLazyDependenciesService);
    return /* @ngInject */ AngularJSLazyDependenciesService;
}());

/**
 * **Deprecated since 2005, use {@link TreeDragAndDropEvent}.**
 *
 * A plain JSON object, representing the event triggered when dragging and dropping nodes in the {@link YtreeComponent}.
 *
 * @deprecated
 */
var YTreeDndEvent = /** @class */ (function () {
    function YTreeDndEvent(
    /**
     * The node being dragged
     */
    sourceNode, 
    /**
     * Array of siblings nodes to the location drop location
     */
    destinationNodes, 
    /**
     * The index at which node was dropped amongst its siblings
     */
    position, 
    /**
     * The  UI handle of the parent node of the source element
     */
    sourceParentHandle, 
    /**
     * The UI handle of the targeted parent element
     */
    targetParentHandle) {
        this.sourceNode = sourceNode;
        this.destinationNodes = destinationNodes;
        this.position = position;
        this.sourceParentHandle = sourceParentHandle;
        this.targetParentHandle = targetParentHandle;
    }
    return YTreeDndEvent;
}());

/* @internal */
var TreeDndOptionFactory = function ($timeout, treeConfig, confirmationModalService, $q, alertService) {
    'ngInject';
    return /** @class */ (function () {
        function class_1(options) {
            this.dragEnabled = false;
            this.dragDelay = treeConfig.dragDelay;
            this.callbacks = {};
            if (!options) {
                return;
            }
            if (options.onDropCallback) {
                this.dragEnabled = true;
                this.callbacks.dropped = function (event) {
                    if (event.source === null || event.dest === null) {
                        return;
                    }
                    var dndEvent = new YTreeDndEvent(event.source.nodeScope.$modelValue, event.dest.nodesScope.$modelValue, event.dest.index, event.source.nodeScope.$parentNodeScope, event.dest.nodesScope.$nodeScope);
                    $timeout(function () {
                        options.onDropCallback(dndEvent);
                    });
                };
            }
            if (options.beforeDropCallback) {
                this.dragEnabled = true;
                this.callbacks.beforeDrop = function (event) {
                    if (event.source === null || event.dest === null) {
                        return true;
                    }
                    var dndEvent = new YTreeDndEvent(event.source.nodeScope.$modelValue, event.dest.nodesScope.$modelValue, event.dest.index);
                    var condition = options.beforeDropCallback(dndEvent);
                    return $q.when(condition).then(function (result) {
                        if (typeof result === 'object') {
                            if (result.confirmDropI18nKey) {
                                var message = {
                                    description: result.confirmDropI18nKey
                                };
                                return confirmationModalService.confirm(message);
                            }
                            if (result.rejectDropI18nKey) {
                                alertService.showDanger({
                                    message: result.rejectDropI18nKey
                                });
                                return false;
                            }
                            throw new Error('Unexpected return value for beforeDropCallback does not contain confirmDropI18nKey nor rejectDropI18nKey: ' +
                                result);
                        }
                        return result;
                    });
                };
            }
            if (options.allowDropCallback) {
                this.dragEnabled = true;
                this.callbacks.accept = function (sourceNodeScope, destNodesScope, destIndex) {
                    var dndEvent = new YTreeDndEvent(sourceNodeScope.$modelValue, destNodesScope.$modelValue, destIndex);
                    return options.allowDropCallback(dndEvent);
                };
            }
        }
        return class_1;
    }());
};
TreeDndOptionFactory.$inject = ["$timeout", "treeConfig", "confirmationModalService", "$q", "alertService"];

/* @internal */
var TreeServiceFactory = function ($q, restServiceFactory, getDataFromResponse) {
    'ngInject';
    /**
     * A class to manage tree nodes through a REST API.
     * @param nodeUri the REST entry point to handle tree nodes. it must support GET, POST, PUT and DELETE verbs:
     * - GET nodeUri?parentUid={parentUid} will return a list of children `TreeNode` nodes wrapped in an object:
     *
     * ### Example
     *      {
     *      	 navigationNodes:[{
     *      		 uid: "2",
     *      		 name: "node2",
     *      		 parentUid: "root"
     *      		 hasChildren: true
     *      	 }, {
     *      		 uid: "4",
     *      		 name: "node4",
     *      		 parentUid: "1",
     *      		 hasChildren: false
     *      	 }]
     *      }
     *
     * - POST nodeUri takes a `TreeNode` payload and returns the final object.
     * - PUT nodeUri/{uid} takes a `TreeNode` payload and returns the final object.
     * - DELETE nodeUri/{uid}
     */
    return /** @class */ (function () {
        function class_1(nodeUri) {
            if (nodeUri) {
                this.nodesRestService = restServiceFactory.get(nodeUri);
            }
        }
        /**
         * Will fetch the children of a given node by querying GET nodeUri?parentUid={parentUid}
         * - Once the children retrieved, the node will be marked as "initiated" and subsequent calls will not hit the server.
         * - Each children will be given a ManyToOne reference to their parent.
         * - The parent nodes will be assigned its children through the "nodes" property.
         * @param parent the parent `TreeNode` object the nodes of which we want to fetch
         */
        class_1.prototype.fetchChildren = function (_parent) {
            _parent.nodes = _parent.nodes || [];
            if (_parent.initiated) {
                return $q.when(_parent.nodes);
            }
            else {
                return $q
                    .when(this.nodesRestService.get({
                    parentUid: _parent.uid
                }))
                    .then(function (response) {
                    _parent.initiated = true;
                    var children = getDataFromResponse(response);
                    if (!children) {
                        return [];
                    }
                    children.forEach(function (child) {
                        child.parent = _parent;
                    });
                    Array.prototype.push.apply(_parent.nodes, children);
                    return children;
                });
            }
        };
        /**
         * Will save a new node for the given parent by POSTing to nodeUri. The payload will only contain the parentUid and a generated name.
         * On the front end side the parent model will be marked as having children.
         * @param parent the parent `TreeNode` object from which to create a child
         */
        class_1.prototype.saveNode = function (_parent) {
            return $q
                .when(this.nodesRestService.save({
                parentUid: _parent.uid,
                name: (_parent.name ? _parent.name : _parent.uid) + _parent.nodes.length
            }))
                .then(function (response) {
                _parent.hasChildren = true;
                response.parent = _parent;
                return response;
            });
        };
        /**
         * Will delete a node by sending DELETE to nodeUri/{uid}.
         * On the front end side the parent model "hasChildren" will be re-evaluated.
         * @param node the `TreeNode` object to delete.
         */
        class_1.prototype.removeNode = function (node) {
            return $q
                .when(this.nodesRestService.remove({
                identifier: node.uid
            }))
                .then(function () {
                var parent = node.parent;
                parent.hasChildren = parent.nodes.length > 1;
                return;
            });
        };
        return class_1;
    }());
};
TreeServiceFactory.$inject = ["$q", "restServiceFactory", "getDataFromResponse"];

/**
 * **Deprecated since 2005, use {@link TreeComponent}.**
 *
 * This directive renders a tree of nodes and manages CRUD operations around the nodes.
 * <br/>It relies on {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} third party library
 * <br/>Its behaviour is defined by {@link YtreeComponent}.
 *
 * ### Parameters
 *
 *
 * `nodeTemplateUrl` - an HTML node template to be included besides each node to enhance rendering and behaviour of the tree. This template may use the nodeActions defined hereunder.
 *
 * `nodeUri` - the REST entry point to be used to manage the nodes (GET, POST, PUT and DELETE).
 *
 * `dragOptions` - a map of callback functions to customize the drag and drop behaviour of the tree by exposing the {@link YTreeDndEvent}.
 *
 * `nodeActions` - a map of methods to be closure-bound to the {@link YtreeComponent} instance in order to manage the tree from the parent scope or from the optional node template.
 * <br/> All nodeActions methods must take {@link TreeService} instance as first parameter.
 * <br/> {@link TreeService} instance will then prebound in the closure made available in the node template or in the parent scope.
 * <br/>
 * Example in a parent controller:
 *
 *      this.actions = {
 * 		    myMethod: function(treeService, arg1, arg2) {
 * 			    //some action expecting 'this'
 * 			    //to be the YTreeController
 * 			    this.newChild(this.root.nodes[0]);
 * 		    }
 * 	    };
 *
 * passed to the directive through:
 *
 *      <ytree data-node-uri='ctrl.nodeURI' data-node-template-url='ctrl.nodeTemplateUrl' data-node-actions='ctrl.actions'/>
 *
 * And in the HTML node template you may invoke it this way:
 *
 *      <button data-ng-click="$ctrl.myMethod('arg1', 'arg2')">my action</button>
 *
 * or from the parent controller:
 *
 *      <button data-ng-click="$ctrl.actions.myMethod('arg1', 'arg2')">my action</button>
 *
 * @deprecated
 */
var /* @ngInject */ YtreeComponent = /** @class */ (function () {
    YtreeComponent.$inject = ["$scope", "$q", "TreeService", "_TreeDndOptions"];
    function /* @ngInject */ YtreeComponent($scope, $q, TreeService, _TreeDndOptions) {
        this.$scope = $scope;
        this.$q = $q;
        this.TreeService = TreeService;
        this._TreeDndOptions = _TreeDndOptions;
    }
    /* @ngInject */ YtreeComponent.prototype.$onInit = function () {
        var _this = this;
        this.root = {
            uid: this.rootNodeUid,
            hasChildren: true,
            name: 'root',
            parent: null,
            parentUid: null,
            position: 0,
            itemType: null,
            uuid: null
        };
        this.treeOptions = new this._TreeDndOptions(this.dragOptions);
        this.treeService = new this.TreeService(this.nodeUri);
        Object.keys(this.nodeActions).forEach(function (functionName) {
            _this[functionName] = _this.nodeActions[functionName].bind(_this, _this.treeService);
            _this.nodeActions[functionName] = _this.nodeActions[functionName].bind(_this, _this.treeService);
        });
        this.fetchData(this.root);
    };
    /**
     * Causes all the nodes of the tree to collapse.
     * It does not affect their "initiated" status though.
     */
    /* @ngInject */ YtreeComponent.prototype.collapseAll = function () {
        this.$scope.$broadcast('angular-ui-tree:collapse-all');
    };
    /* @ngInject */ YtreeComponent.prototype.expandAll = function () {
        this.$scope.$broadcast('angular-ui-tree:expand-all');
    };
    /**
     * Return a boolean to determine if the node is expandable or not by checking if a given node has children
     * @param handle the native {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} handle on a given node.
     */
    /* @ngInject */ YtreeComponent.prototype.hasChildren = function (handle) {
        var nodeData = handle.$modelValue;
        return nodeData.hasChildren;
    };
    YtreeComponent.prototype.hasChildren.$inject = ["handle"];
    /* @ngInject */ YtreeComponent.prototype.fetchData = function (nodeData) {
        return this.treeService.fetchChildren(nodeData);
    };
    YtreeComponent.prototype.fetchData.$inject = ["nodeData"];
    /**
     * Will toggle a node, causing a fetch from server if expanding for the first time.
     * @param handle the native {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} handle on a given node.
     */
    /* @ngInject */ YtreeComponent.prototype.toggleAndfetch = function (handle) {
        var _this = this;
        this.isDisabled = true;
        var nodeData = handle.$modelValue;
        if (handle.collapsed) {
            return this.fetchData(nodeData).then(function () {
                handle.toggle();
                _this.isDisabled = false;
            });
        }
        handle.toggle();
        this.isDisabled = false;
        return this.$q.when();
    };
    YtreeComponent.prototype.toggleAndfetch.$inject = ["handle"];
    /**
     * Will refresh a node, causing it to expand after fetch if it was expanded before.
     */
    /* @ngInject */ YtreeComponent.prototype.refresh = function (handle) {
        var nodeData = handle.$modelValue;
        nodeData.initiated = false;
        var previousCollapsed = handle.collapsed;
        return this.fetchData(nodeData).then(function () {
            if (!previousCollapsed && handle.collapsed) {
                handle.toggle();
            }
        });
    };
    YtreeComponent.prototype.refresh.$inject = ["handle"];
    /**
     * Will refresh the parent of a node, causing it to expand after fetch if it was expanded before.
     */
    /* @ngInject */ YtreeComponent.prototype.refreshParent = function (handle) {
        if (handle.$modelValue.parent.uid === this.root.uid) {
            this.fetchData(this.root);
        }
        else {
            this.refresh(handle.$parentNodeScope);
        }
    };
    YtreeComponent.prototype.refreshParent.$inject = ["handle"];
    /**
     * Will add a new child to the node referenced by this handle.
     * <br/>The child is added only if [saveNode]{@link TreeService#saveNode} is successful.
     * @param handle the native {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} handle on a given node.
     */
    /* @ngInject */ YtreeComponent.prototype.newChild = function (handle) {
        var _this = this;
        var nodeData = handle.$modelValue ? handle.$modelValue : this.root;
        nodeData.nodes = nodeData.nodes || [];
        this.treeService.saveNode(nodeData).then(function (response) {
            (handle.collapsed ? _this.toggleAndfetch(handle) : _this.$q.when()).then(function () {
                var elm = nodeData.nodes.find(function (node) { return node.uid === response.uid; });
                if (!elm) {
                    // if children list already initiated, one needs to push to the list on the ui side
                    nodeData.nodes.push(response);
                }
            });
        });
    };
    YtreeComponent.prototype.newChild.$inject = ["handle"];
    /**
     * Will add a new sibling to the node referenced by this handle.
     * <br/>The sibling is added only if [saveNode]{@link TreeService#saveNode} is successful.
     * @param handle the native {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} handle on a given node.
     */
    /* @ngInject */ YtreeComponent.prototype.newSibling = function (handle) {
        var nodeData = handle.$modelValue;
        var parent = nodeData.parent;
        this.treeService.saveNode(parent).then(function (response) {
            parent.nodes.push(response);
        });
    };
    YtreeComponent.prototype.newSibling.$inject = ["handle"];
    /**
     * Will remove the node referenced by this handle.
     * <br/>The node is removed only if [removeNode]{@link TreeService#removeNode} is successful.
     * @param handle the native {@link https://github.com/angular-ui-tree/angular-ui-tree angular-ui-tree} handle on a given node.
     */
    /* @ngInject */ YtreeComponent.prototype.remove = function (handle) {
        var _this = this;
        var nodeData = handle.$modelValue;
        this.treeService.removeNode(nodeData).then(function () {
            var parent = nodeData.parent;
            parent.nodes.splice(parent.nodes.indexOf(nodeData), 1);
            parent.initiated = false;
            delete parent.nodes;
            _this.fetchData(parent);
        });
    };
    YtreeComponent.prototype.remove.$inject = ["handle"];
    /* @ngInject */ YtreeComponent.prototype.isRoot = function (handle) {
        var nodeData = handle.$modelValue;
        return nodeData.parent.uid === undefined;
    };
    YtreeComponent.prototype.isRoot.$inject = ["handle"];
    /* @ngInject */ YtreeComponent.prototype.displayDefaultTemplate = function () {
        return !this.removeDefaultTemplate;
    };
    /* @ngInject */ YtreeComponent.prototype.onNodeMouseEnter = function (node) {
        node.mouseHovered = true;
    };
    YtreeComponent.prototype.onNodeMouseEnter.$inject = ["node"];
    /* @ngInject */ YtreeComponent.prototype.onNodeMouseLeave = function (node) {
        node.mouseHovered = false;
    };
    YtreeComponent.prototype.onNodeMouseLeave.$inject = ["node"];
    /**
     * Will fetch from the existing tree the node whose identifier is the given nodeUid
     * @param nodeUid the identifier of the node to fetched
     */
    /* @ngInject */ YtreeComponent.prototype.getNodeById = function (nodeUid, nodeArray) {
        if (!nodeArray) {
            nodeArray = this.root.nodes;
        }
        if (nodeUid === this.rootNodeUid) {
            return this.root;
        }
        // eslint-disable-next-line @typescript-eslint/no-for-in-array
        for (var i in nodeArray) {
            if (nodeArray.hasOwnProperty(i)) {
                if (nodeArray[i].uid === nodeUid) {
                    return nodeArray[i];
                }
                if (nodeArray[i].hasChildren) {
                    nodeArray[i].nodes = nodeArray[i].nodes || [];
                    var result = this.getNodeById(nodeUid, nodeArray[i].nodes);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return null;
    };
    YtreeComponent.prototype.getNodeById.$inject = ["nodeUid", "nodeArray"];
    /* @ngInject */ YtreeComponent = __decorate([
        SeComponent({
            templateUrl: 'yTreeComponentTemplate.html',
            inputs: [
                'nodeTemplateUrl:=',
                'nodeUri:=',
                'nodeActions:=',
                'rootNodeUid:=',
                'dragOptions:=',
                'removeDefaultTemplate:=?',
                'showAsList:=?'
            ]
        }),
        __metadata("design:paramtypes", [Object, Function, Function, Function])
    ], /* @ngInject */ YtreeComponent);
    return /* @ngInject */ YtreeComponent;
}());

// eslint-disable-next-line @typescript-eslint/no-var-requires
var NgTreeModule = require('angular-ui-tree'); // Only supports CommonJS
var TREE_CONFIGURATION_PROVIDER = {
    provide: 'treeConfig',
    useValue: {
        treeClass: 'angular-ui-tree',
        hiddenClass: 'angular-ui-tree-hidden',
        nodesClass: 'angular-ui-tree-nodes',
        nodeClass: 'angular-ui-tree-node',
        handleClass: 'angular-ui-tree-handle',
        placeholderClass: 'angular-ui-tree-placeholder',
        dragClass: 'angular-ui-tree-drag',
        dragThreshold: 3,
        levelThreshold: 30,
        defaultCollapsed: true,
        dragDelay: 200
    }
};
/**
 * This module deals with rendering and management of node trees
 */
var /* @ngInject */ TreeModule = /** @class */ (function () {
    function /* @ngInject */ TreeModule() {
    }
    /* @ngInject */ TreeModule = __decorate([
        SeModule({
            imports: [
                NgTreeModule,
                'includeReplaceModule',
                'functionsModule',
                'smarteditServicesModule',
                'translationServiceModule',
                'confirmationModalServiceModule',
                'yLoDashModule'
            ],
            declarations: [YtreeComponent],
            providers: [
                TREE_CONFIGURATION_PROVIDER,
                {
                    provide: 'TreeService',
                    useFactory: TreeServiceFactory
                },
                {
                    provide: '_TreeDndOptions',
                    useFactory: TreeDndOptionFactory
                },
                TreeServiceFactory
            ]
        })
    ], /* @ngInject */ TreeModule);
    return /* @ngInject */ TreeModule;
}());

/**
 * **Deprecated since 2005, use {@link MoreTextComponent}.**
 *
 * The component for truncating strings and adding an ellipsis.
 * If the limit is less then the string length then the string is truncated and 'more'/'less' buttons
 * are displayed to expand or collapse the string.
 *
 * ### Parameters
 *
 * `text` - see [text]{@link MoreTextComponent#text}.
 * `limit` - see [limit]{@link MoreTextComponent#limit}.
 * `moreLabelI18nKey` - see [moreLabelI18nKey]{@link MoreTextComponent#moreLabelI18nKey}.
 * `lessLabelI18nKey` - see [lessLabelI18nKey]{@link MoreTextComponent#lessLabelI18nKey}.
 * `ellipsis` - see [ellipsis]{@link MoreTextComponent#ellipsis}.
 *
 * @deprecated
 */
var /* @ngInject */ YMoreTextComponent = /** @class */ (function () {
    function /* @ngInject */ YMoreTextComponent() {
    }
    /* @ngInject */ YMoreTextComponent = __decorate([
        SeComponent({
            templateUrl: 'moreTextTemplate.html',
            inputs: ['text', 'limit:?', 'moreLabelI18nKey:?', 'lessLabelI18nKey:?', 'ellipsis:?']
        })
    ], /* @ngInject */ YMoreTextComponent);
    return /* @ngInject */ YMoreTextComponent;
}());

/**
 * **Deprecated, since 2005, use {@link InifniteScrollingComponent}.**
 *
 * A component that you can use to implement infinite scrolling for an expanding content (typically with a ng-repeat) nested in it.
 * It is meant to handle paginated requests from a backend when data is expected to be large.
 * Since the expanding content is a <b>transcluded</b> element, we must specify the context to which the items will be attached:
 * If context is myContext, each pagination will push its new items to myContext.items.
 *
 * ### Parameters
 * `pageSize` - The maximum size of each page requested from the backend.
 *
 * `mask` - A string value sent to the server upon fetching a page to further restrict the search, it is sent as query string "mask".
 * <br>The directive listens for change to mask and will reset the scroll and re-fetch data.
 * <br/>It it left to the implementers to decide what it filters on.
 *
 * `distance` - A number representing how close the bottom of the element must be to the bottom of the container before the expression specified by fetchPage function is triggered. Measured in multiples of the container height; for example, if the container is 1000 pixels tall and distance is set to 2, the infinite scroll expression will be evaluated when the bottom of the element is within 2000 pixels of the bottom of the container. Defaults to 0 (e.g. the expression will be evaluated when the bottom of the element crosses the bottom of the container).
 *
 * `context` - The container object to which the items of the fetched `Page` will be added
 *
 * `fetchPage` - Function to fetch the next page when the bottom of the element approaches the bottom of the container.
 * fetchPage will be invoked with 3 arguments : <b>mask, pageSize, currentPage</b>. The currentPage is determined by the scrolling and starts with 0. The function must return a page of type `Page`.
 *
 * `dropDownContainerClass` - An optional CSS class to be added to the container of the dropdown. It would typically be used to override the default height. <b>The resolved CSS must set a height (or max-height) and overflow-y:scroll.</b>
 *
 * `dropDownClass` - An optional CSS class to be added to the dropdown. <b>Neither height nor overflow should be set on the dropdown, it must be free to fill up the space and reach the container size. Failure to do so will cause the directive to call nextPage as many times as the number of available pages on the server.</b>
 */
var /* @ngInject */ YInfiniteScrollingComponent = /** @class */ (function () {
    YInfiniteScrollingComponent.$inject = ["$timeout", "encode", "lodash", "discardablePromiseUtils", "$element", "stringUtils", "throttle", "testModeService"];
    function /* @ngInject */ YInfiniteScrollingComponent($timeout, encode, lodash, discardablePromiseUtils, $element, stringUtils, throttle, testModeService) {
        this.$timeout = $timeout;
        this.encode = encode;
        this.lodash = lodash;
        this.discardablePromiseUtils = discardablePromiseUtils;
        this.$element = $element;
        /** @internal */
        this.CONTAINER_CLASS = 'ySEInfiniteScrolling-container';
        /** @internal */
        this.initiated = false;
        this.THROTTLE_MILLISECONDS = 250;
        this.containerId = stringUtils.generateIdentifier();
        // needs to be bound for usage by underlying infinite-scroll
        this.nextPage = this.nextPage.bind(this);
        if (!testModeService.isE2EMode()) {
            this.$onChanges = throttle(this.$onChanges.bind(this), this.THROTTLE_MILLISECONDS);
        }
    }
    /** @internal */
    /* @ngInject */ YInfiniteScrollingComponent.prototype.$onChanges = function () {
        this.context = this.context || this;
        this.$postLink();
    };
    /** @internal */
    /* @ngInject */ YInfiniteScrollingComponent.prototype.nextPage = function () {
        var _this = this;
        if (this.pagingDisabled) {
            return;
        }
        this.pagingDisabled = true;
        this.currentPage++;
        this.mask = this.mask || '';
        this.discardablePromiseUtils.apply(this.containerId, this.fetchPage(this.mask, this.pageSize, this.currentPage), function (page) {
            page.results = page.results || [];
            page.results.forEach(function (element) {
                element.technicalUniqueId = _this.encode(element);
            });
            var uniqueResults = _this.lodash.differenceBy(page.results, _this.context.items, 'technicalUniqueId');
            if (_this.lodash.size(uniqueResults) > 0) {
                Array.prototype.push.apply(_this.context.items, uniqueResults);
            }
            /*
             * pagingDisabled controls the disablement of the native infinite-scroll directive therefore its
             * re-evaluation must happen on the next digest cycle, after the HTML real estate has been modified
             * by the new data set. Doing it on the same digest cycle would cause the non throttled infinite-scroll directive
             * to fetch more pages than required
             */
            _this.$timeout(function () {
                _this.pagingDisabled =
                    page.results.length === 0 ||
                        (page.pagination &&
                            _this.context.items.length === page.pagination.totalCount);
            });
        });
    };
    /** @internal */
    /* @ngInject */ YInfiniteScrollingComponent.prototype.$postLink = function () {
        var wasInitiated = this.initiated;
        this.distance = this.distance || 0;
        this.context.items = [];
        this.currentPage = -1;
        this.pagingDisabled = false;
        if (!this.container && this.$element) {
            this.container = this.$element.find('.' + this.CONTAINER_CLASS).get(0);
            this.initiated = true;
        }
        else {
            this.container.scrollTop = 0;
        }
        if (wasInitiated) {
            // not needed the first time since data-infinite-scroll-immediate-check="true"
            this.nextPage();
        }
    };
    /* @ngInject */ YInfiniteScrollingComponent = __decorate([
        SeComponent({
            templateUrl: 'LegacyInfiniteScrollingTemplate.html',
            inputs: [
                'pageSize',
                'mask:?',
                'fetchPage',
                'distance:?',
                'context:?',
                'dropDownContainerClass: @?',
                'dropDownClass: @?'
            ]
        }),
        __metadata("design:paramtypes", [Function, Function, Function, DiscardablePromiseUtils, Object, StringUtils, Function, TestModeService])
    ], /* @ngInject */ YInfiniteScrollingComponent);
    return /* @ngInject */ YInfiniteScrollingComponent;
}());

/**
 * **Deprecated since 2005, use {@link MessageComponent}.**
 *
 * The YEventMessage is a wrapper around YMessage, used to display or hide the message based on events sent through the systemEventService.
 *
 * ### Parameters
 *
 * `type` - The YMessage type
 *
 * `title` - The YMessage title
 *
 * `description` - The YMessage description
 *
 * `showEvent` - The event id where the YMessage should be shown. You can update the message or title at this time,
 * by passing a {@link IYEventMessageData} as argument to the event service.
 *
 *
 * `hideEvent` - The event id where the YMessage should be hidden
 *
 * `showToStart` - Controls whether the component is shown right away after compiling the dom
 *
 * @deprecated
 */
var /* @ngInject */ YEventMessageComponent = /** @class */ (function () {
    YEventMessageComponent.$inject = ["systemEventService"];
    function /* @ngInject */ YEventMessageComponent(systemEventService) {
        this.systemEventService = systemEventService;
        this.type = 'info';
        this.show = false;
    }
    /* @ngInject */ YEventMessageComponent.prototype.$onChanges = function (changesObj) {
        var _this = this;
        if (changesObj.showEvent) {
            this.removeShowEventHandler();
            this.unregisterShowEventHandler = this.systemEventService.subscribe(changesObj.showEvent.currentValue, function (eventId, eventData) { return _this.showEventHandler(eventId, eventData); });
        }
        if (changesObj.hideEvent) {
            this.removeHideEventHandler();
            this.unregisterHideEventHandler = this.systemEventService.subscribe(changesObj.hideEvent.currentValue, function () { return (_this.show = false); });
        }
        if (this.recompile) {
            this.recompile();
        }
    };
    YEventMessageComponent.prototype.$onChanges.$inject = ["changesObj"];
    /* @ngInject */ YEventMessageComponent.prototype.$onInit = function () {
        this.show = this.showToStart === 'true' || this.showToStart === true;
    };
    /* @ngInject */ YEventMessageComponent.prototype.$onDestroy = function () {
        this.removeShowEventHandler();
        this.removeHideEventHandler();
    };
    /* @ngInject */ YEventMessageComponent.prototype.showDescription = function () {
        return typeof this.description === 'string' && this.description.length > 0;
    };
    /* @ngInject */ YEventMessageComponent.prototype.showTitle = function () {
        return typeof this.title === 'string' && this.title.length > 0;
    };
    /* @ngInject */ YEventMessageComponent.prototype.showEventHandler = function (eventId, eventData) {
        if (eventData.description && eventData.description.length) {
            this.description = eventData.description;
        }
        if (eventData.title && eventData.title.length) {
            this.title = eventData.title;
        }
        this.show = true;
        if (this.recompile) {
            this.recompile();
        }
    };
    YEventMessageComponent.prototype.showEventHandler.$inject = ["eventId", "eventData"];
    /* @ngInject */ YEventMessageComponent.prototype.removeHideEventHandler = function () {
        if (this.unregisterHideEventHandler) {
            this.unregisterHideEventHandler();
        }
    };
    /* @ngInject */ YEventMessageComponent.prototype.removeShowEventHandler = function () {
        if (this.unregisterShowEventHandler) {
            this.unregisterShowEventHandler();
        }
    };
    /* @ngInject */ YEventMessageComponent = __decorate([
        SeComponent({
            template: "\n\t\t<div data-recompile-dom=\"$ctrl.recompile\">\n\t\t\t<se-message [type]=\"$ctrl.type\"\n\t\t\t\tdata-ng-if=\"$ctrl.show\">\n\t\t\t\t<ng-container data-ng-if=\"$ctrl.title.length\" se-message-title>\n\t\t\t\t\t{{ $ctrl.title | translate }}\n\t\t\t\t</ng-container>\n\t\t\t\t<ng-container data-ng-if=\"$ctrl.description.length\" se-message-description>\n\t\t\t\t\t{{ $ctrl.description | translate }}\n\t\t\t\t</ng-container>\n\t\t\t</se-message>\n\t\t</div>\n    ",
            inputs: [
                'type: ?',
                'title: ?',
                'description: ?',
                'showEvent: ?',
                'hideEvent: ?',
                'showToStart: ?'
            ]
        }),
        __metadata("design:paramtypes", [SystemEventService])
    ], /* @ngInject */ YEventMessageComponent);
    return /* @ngInject */ YEventMessageComponent;
}());

/**
 * # Module
 *
 * **Deprecated since 2005, use {@link MessageModule}.**
 *
 * This module provides the yMessage component, which is responsible for rendering contextual
 * feedback messages for the user actions.
 *
 * # Component
 *
 * **Deprecated, since 2005, use {@link MessageComponent}.**
 *
 * This component provides contextual feedback messages for the user actions. To provide title and description for the yMessage
 * use transcluded elements: message-title and message-description.
 *
 * ### Parameters
 *
 * `messageId` - see [messageId]{@link MessageComponent#messageId}.
 * `type` - see [type]{@link MessageComponent#type}.
 *
 * @deprecated
 */
var /* @ngInject */ YMessageComponent = /** @class */ (function () {
    YMessageComponent.$inject = ["$element", "$compile", "$scope"];
    function /* @ngInject */ YMessageComponent($element, $compile, $scope) {
        this.$element = $element;
        this.$compile = $compile;
        this.$scope = $scope;
    }
    /* @ngInject */ YMessageComponent.prototype.$postLink = function () {
        // Dynamically compile transcluded content and append as Angular content child
        // This is necessary as we are unable to project transcluded content, as AngularJS is throwing error
        // about parent directive missing transclude flag.
        var messageTitleTarget = this.$element.find('#y-message-title');
        var messageDescriptionTarget = this.$element.find('#y-message-description');
        var messageTitleSource = this.$element.find('#y-message-title-source');
        var messageDescriptionSource = this.$element.find('#y-message-description-source');
        if (messageTitleSource[0].firstChild) {
            messageTitleTarget.append(this.$compile(messageTitleSource[0].firstChild)(this.$scope)[0]);
        }
        if (messageDescriptionSource[0].firstChild) {
            messageDescriptionTarget.append(this.$compile(messageDescriptionSource[0].firstChild)(this.$scope)[0]);
        }
    };
    /* @ngInject */ YMessageComponent = __decorate([
        SeComponent({
            templateUrl: 'yMessage.html',
            transclude: {
                messageTitle: '?messageTitle',
                messageDescription: '?messageDescription'
            },
            inputs: ['messageId:@', 'type:@']
        }),
        __metadata("design:paramtypes", [Object, Function, Object])
    ], /* @ngInject */ YMessageComponent);
    return /* @ngInject */ YMessageComponent;
}());

var DROPDOWN_MENU_ITEM_DATA = new core.InjectionToken('DROPDOWN_MENU_ITEM_DATA');
window.__smartedit__.addDecoratorPayload("Component", "DropdownMenuItemDefaultComponent", {
    selector: 'se-dropdown-menu-item-default',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: "<a class=\"se-dropdown-item fd-menu__item\" [ngClass]=\"data.dropdownItem.customCss\" (click)=\"data.dropdownItem.callback(data.selectedItem, data.dropdownItem)\"><span *ngIf=\"data.dropdownItem.icon\" [ngClass]=\"data.dropdownItem.icon\"></span> <span>{{ data.dropdownItem.key | translate }}</span></a>"
});
var DropdownMenuItemDefaultComponent = /** @class */ (function () {
    function DropdownMenuItemDefaultComponent(data) {
        this.data = data;
    }
    DropdownMenuItemDefaultComponent = __decorate([
        core.Component({
            selector: 'se-dropdown-menu-item-default',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            template: "<a class=\"se-dropdown-item fd-menu__item\" [ngClass]=\"data.dropdownItem.customCss\" (click)=\"data.dropdownItem.callback(data.selectedItem, data.dropdownItem)\"><span *ngIf=\"data.dropdownItem.icon\" [ngClass]=\"data.dropdownItem.icon\"></span> <span>{{ data.dropdownItem.key | translate }}</span></a>"
        }),
        __param(0, core.Inject(DROPDOWN_MENU_ITEM_DATA)),
        __metadata("design:paramtypes", [Object])
    ], DropdownMenuItemDefaultComponent);
    return DropdownMenuItemDefaultComponent;
}());

/**
 * **Deprecated since 2005, use {@link HelpComponent}.**
 */
var /* @ngInject */ YHelpComponent = /** @class */ (function () {
    function /* @ngInject */ YHelpComponent() {
    }
    /* @ngInject */ YHelpComponent.prototype.$onChanges = function (changes) {
        if (this.template && changes.template) {
            this.template = '<div>' + this.template + '</div>';
        }
    };
    YHelpComponent.prototype.$onChanges.$inject = ["changes"];
    /* @ngInject */ YHelpComponent = __decorate([
        SeComponent({
            selector: 'y-help',
            templateUrl: 'yHelpTemplate.html',
            inputs: ['title', 'template', 'templateUrl']
        })
    ], /* @ngInject */ YHelpComponent);
    return /* @ngInject */ YHelpComponent;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/* forbiddenNameSpaces angular.module:false */
angular$1.module('resourceLocationsModule', [])
    /**
     * Constant containing the name of the site uid placeholder in URLs
     */
    .constant('CONTEXT_SITE_ID', CONTEXT_SITE_ID)
    /**
     * Constant containing the name of the catalog uid placeholder in URLs
     */
    .constant('CONTEXT_CATALOG', CONTEXT_CATALOG)
    /**
     * Constant containing the name of the catalog version placeholder in URLs
     */
    .constant('CONTEXT_CATALOG_VERSION', CONTEXT_CATALOG_VERSION)
    /**
     * Constant containing the name of the current page site uid placeholder in URLs
     */
    .constant('PAGE_CONTEXT_SITE_ID', PAGE_CONTEXT_SITE_ID)
    /**
     * Constant containing the name of the current page catalog uid placeholder in URLs
     */
    .constant('PAGE_CONTEXT_CATALOG', PAGE_CONTEXT_CATALOG)
    /**
     * Constant containing the name of the current page catalog version placeholder in URLs
     */
    .constant('PAGE_CONTEXT_CATALOG_VERSION', PAGE_CONTEXT_CATALOG_VERSION)
    /**
     * the name of the webapp root context
     */
    .constant('SMARTEDIT_ROOT', 'smartedit')
    /**
     * to calculate platform domain URI, this regular expression will be used
     */
    .constant('SMARTEDIT_RESOURCE_URI_REGEXP', SMARTEDIT_RESOURCE_URI_REGEXP)
    /**
     * the name of the SmartEdit configuration API root
     */
    .constant('CONFIGURATION_URI', CONFIGURATION_URI)
    /**
     * Constant for the cmswebservices API root
     */
    .constant('CMSWEBSERVICES_RESOURCE_URI', '/cmswebservices')
    /**
     * **Deprecated since 2005, `import DEFAULT_AUTHENTICATION_ENTRY_POINT from smarteditconstants.ts`.**
     *
     * When configuration is not available yet to provide authenticationMap, one needs a default authentication entry point to access configuration API itself
     *
     * @deprecated
     */
    .constant('DEFAULT_AUTHENTICATION_ENTRY_POINT', utils.DEFAULT_AUTHENTICATION_ENTRY_POINT)
    /**
     * The default OAuth 2 client id to use during authentication.
     */
    .constant('DEFAULT_AUTHENTICATION_CLIENT_ID', DEFAULT_AUTHENTICATION_CLIENT_ID)
    /**
     * Resource URI to fetch the i18n initialization map for a given locale.
     */
    .constant('I18N_RESOURCE_URI', '/smarteditwebservices/v1/i18n/translations')
    /**
     * Resource URI to fetch the supported i18n languages.
     */
    .constant('I18N_LANGUAGES_RESOURCE_URI', I18N_LANGUAGES_RESOURCE_URI)
    .constant('PREVIEW_RESOURCE_URI', PREVIEW_RESOURCE_URI)
    /**
     * Resource URI of the languages REST service.
     */
    .constant('LANGUAGE_RESOURCE_URI', LANGUAGE_RESOURCE_URI)
    .constant('PRODUCT_RESOURCE_API', PRODUCT_RESOURCE_API)
    .constant('PRODUCT_LIST_RESOURCE_API', PRODUCT_LIST_RESOURCE_API)
    /**
     * Resource URI of the sites REST service.
     */
    .constant('SITES_RESOURCE_URI', SITES_RESOURCE_URI)
    /**
     * Path of the landing page
     */
    .constant('LANDING_PAGE_PATH', utils.LANDING_PAGE_PATH)
    /**
     * to fetch the store front context for inflection points.
     */
    .constant('STORE_FRONT_CONTEXT', STORE_FRONT_CONTEXT)
    /**
     * Path of the catalogs
     */
    .constant('CATALOGS_PATH', '/cmswebservices/v1/catalogs/')
    /**
     * Path of the media
     */
    .constant('MEDIA_PATH', MEDIA_PATH)
    /**
     * Path to fetch list of values of a given enum type
     */
    .constant('ENUM_RESOURCE_URI', '/cmswebservices/v1/enums')
    /**
     * Path of the synchronization service
     */
    .constant('SYNC_PATH', '/cmswebservices/v1/catalogs/:catalog/versions/Staged/synchronizations/versions/Online')
    /**
     * Resource URI of the media REST service.
     */
    .constant('MEDIA_RESOURCE_URI', MEDIA_RESOURCE_URI)
    /**
     * Resource URI of the component types REST service.
     */
    .constant('TYPES_RESOURCE_URI', TYPES_RESOURCE_URI)
    /**
     * Generates a regular expresssion matcher from a given resource location URL, replacing predefined keys by wildcard
     * matchers.
     *
     * ### Example
     *
     *      // Get a regex matcher for the someResource endpoint, ie: /\/smarteditwebservices\/someResource\/.*$/g
     *      var endpointRegex = resourceLocationToRegex('/smarteditwebservices/someResource/:id');
     *
     *      // Use the regex to match hits to the mocked HTTP backend. This regex will match for any ID passed in to the
     *      // someResource endpoint.
     *      httpBackendService.whenGET(endpointRegex).respond({someKey: 'someValue'});
     *
     */
    .factory('resourceLocationToRegex', function () {
    return stringUtils.resourceLocationToRegex;
});

/**
 * The seConstantsModule module contains Smartedit's global constants.
 */
var /* @ngInject */ SeConstantsModule = /** @class */ (function () {
    function /* @ngInject */ SeConstantsModule() {
    }
    /* @ngInject */ SeConstantsModule = __decorate([
        SeModule({
            providers: __spreadArrays(moduleUtils.provideValues({
                CTX_MENU_DROPDOWN_IS_OPEN: CTX_MENU_DROPDOWN_IS_OPEN,
                CLOSE_CTX_MENU: CLOSE_CTX_MENU,
                SHOW_SLOT_MENU: '_SHOW_SLOT_MENU',
                HIDE_SLOT_MENU: 'HIDE_SLOT_MENU'
            }), [
                /**
                 * the identifier of the overlay placed in front of the storefront to where all smartEdit component decorated clones are copied.
                 */
                {
                    provide: 'OVERLAY_ID',
                    useValue: OVERLAY_ID
                },
                /**
                 * the css class of the smartEdit components as per contract with the storefront
                 */
                {
                    provide: 'COMPONENT_CLASS',
                    useValue: 'smartEditComponent'
                },
                /**
                 * the css class of the smartEdit component clones copied to the storefront overlay
                 */
                {
                    provide: 'OVERLAY_COMPONENT_CLASS',
                    useValue: OVERLAY_COMPONENT_CLASS
                },
                /**
                 * If the storefront needs to expose more attributes than the minimal contract, these attributes must be prefixed with this constant value
                 */
                {
                    provide: 'SMARTEDIT_ATTRIBUTE_PREFIX',
                    useValue: 'data-smartedit-'
                },
                /**
                 * the id attribute of the smartEdit components as per contract with the storefront
                 */
                {
                    provide: 'ID_ATTRIBUTE',
                    useValue: ID_ATTRIBUTE
                },
                /**
                 * the uuid attribute of the smartEdit components as per contract with the storefront
                 */
                {
                    provide: 'UUID_ATTRIBUTE',
                    useValue: UUID_ATTRIBUTE
                },
                /**
                 * the front-end randomly generated uuid of the smartEdit components and their equivalent in the overlay
                 */
                {
                    provide: 'ELEMENT_UUID_ATTRIBUTE',
                    useValue: ELEMENT_UUID_ATTRIBUTE
                },
                /**
                 * the uuid attribute of the smartEdit components as per contract with the storefront
                 */
                {
                    provide: 'CATALOG_VERSION_UUID_ATTRIBUTE',
                    useValue: CATALOG_VERSION_UUID_ATTRIBUTE
                },
                /**
                 * the type attribute of the smartEdit components as per contract with the storefront
                 */
                {
                    provide: 'TYPE_ATTRIBUTE',
                    useValue: TYPE_ATTRIBUTE
                },
                /**
                 * the id attribute of the smartEdit container, when applicable, as per contract with the storefront
                 */
                {
                    provide: 'CONTAINER_ID_ATTRIBUTE',
                    useValue: 'data-smartedit-container-id'
                },
                /**
                 * the type attribute of the smartEdit container, when applicable, as per contract with the storefront
                 */
                {
                    provide: 'CONTAINER_TYPE_ATTRIBUTE',
                    useValue: CONTAINER_TYPE_ATTRIBUTE
                },
                /**
                 * the type value of the smartEdit slots as per contract with the storefront
                 */
                {
                    provide: 'CONTENT_SLOT_TYPE',
                    useValue: CONTENT_SLOT_TYPE
                },
                {
                    provide: 'SMARTEDIT_IFRAME_WRAPPER_ID',
                    useValue: SMARTEDIT_IFRAME_WRAPPER_ID
                },
                {
                    provide: 'SMARTEDIT_IFRAME_DRAG_AREA',
                    useValue: SMARTEDIT_IFRAME_DRAG_AREA
                },
                {
                    provide: 'EVENT_TOGGLE_SMARTEDIT_IFRAME_DRAG_AREA',
                    useValue: 'EVENT_TOGGLE_SMARTEDIT_IFRAME_DRAG_AREA'
                },
                {
                    provide: 'SCROLL_AREA_CLASS',
                    useValue: SCROLL_AREA_CLASS
                },
                {
                    provide: 'SMARTEDIT_ELEMENT_HOVERED',
                    useValue: SMARTEDIT_ELEMENT_HOVERED
                },
                {
                    provide: 'SMARTEDIT_DRAG_AND_DROP_EVENTS',
                    useValue: SMARTEDIT_DRAG_AND_DROP_EVENTS
                },
                {
                    provide: 'DATE_CONSTANTS',
                    useValue: DATE_CONSTANTS
                },
                /**
                 * The ID of the event that is triggered when the content of a catalog is
                 * updated (by page edit or page deletion).
                 */
                {
                    provide: EVENT_CONTENT_CATALOG_UPDATE,
                    useValue: EVENT_CONTENT_CATALOG_UPDATE
                },
                /**
                 * The ID of the event that is triggered when the perspective (known as mode for users) is changed.
                 */
                {
                    provide: EVENT_PERSPECTIVE_CHANGED,
                    useValue: EVENT_PERSPECTIVE_CHANGED
                },
                /**
                 * The ID of the event that is triggered when a new perspective (known as mode for users) is registered.
                 */
                {
                    provide: EVENT_PERSPECTIVE_ADDED,
                    useValue: EVENT_PERSPECTIVE_ADDED
                },
                /**
                 * The ID of the event that is triggered when a perspective (known as mode for users) is updated.
                 * The perspective is updated when features, permissions or perspectives attributes are changed.
                 */
                {
                    provide: EVENT_PERSPECTIVE_UPDATED,
                    useValue: EVENT_PERSPECTIVE_UPDATED
                },
                /**
                 * The ID of the event that is triggered when a perspective is about to be unloaded.
                 * This event is triggered immediately before the features are disabled.
                 */
                {
                    provide: EVENT_PERSPECTIVE_UNLOADING,
                    useValue: EVENT_PERSPECTIVE_UNLOADING
                },
                /**
                 * The ID of the event that is triggered when the perspective (known as mode for users) is refreshed.
                 */
                {
                    provide: EVENT_PERSPECTIVE_REFRESHED,
                    useValue: EVENT_PERSPECTIVE_REFRESHED
                },
                /**
                 * The key of the default All Perspective.
                 */
                {
                    provide: 'ALL_PERSPECTIVE',
                    useValue: ALL_PERSPECTIVE
                },
                /**
                 * The key of the default None Perspective.
                 */
                {
                    provide: 'NONE_PERSPECTIVE',
                    useValue: NONE_PERSPECTIVE
                },
                {
                    provide: 'PERSPECTIVE_SELECTOR_WIDGET_KEY',
                    useValue: PERSPECTIVE_SELECTOR_WIDGET_KEY
                },
                /**
                 * Validation message types
                 *
                 * **Deprecated since 2105, `import { VALIDATION_MESSAGE_TYPES } from 'smarteditcommons'`.**
                 */
                {
                    provide: 'VALIDATION_MESSAGE_TYPES',
                    useValue: {
                        /**
                         * Validation error type.
                         */
                        VALIDATION_ERROR: 'ValidationError',
                        /**
                         * Validation warning type.
                         */
                        WARNING: 'Warning'
                    }
                },
                {
                    provide: 'CONTRACT_CHANGE_LISTENER_PROCESS_EVENTS',
                    useValue: CONTRACT_CHANGE_LISTENER_PROCESS_EVENTS
                },
                {
                    provide: 'SMARTEDIT_COMPONENT_PROCESS_STATUS',
                    useValue: 'smartEditComponentProcessStatus'
                },
                {
                    provide: 'CONTRACT_CHANGE_LISTENER_COMPONENT_PROCESS_STATUS',
                    useValue: CONTRACT_CHANGE_LISTENER_COMPONENT_PROCESS_STATUS
                },
                /**
                 * Sort directions
                 */
                {
                    provide: 'SORT_DIRECTIONS',
                    useValue: {
                        /**
                         * Sort direction - Ascending
                         */
                        ASC: exports.SortDirections.Ascending,
                        /**
                         * Sort direction - Descending
                         */
                        DESC: exports.SortDirections.Descending
                    }
                },
                /**
                 * The event that triggeres when user clicks on the outer frame.
                 */
                {
                    provide: EVENT_OUTER_FRAME_CLICKED,
                    useValue: EVENT_OUTER_FRAME_CLICKED
                },
                /**
                 * Name of the event triggered whenever SmartEdit decides to update items in contextual menus.
                 */
                {
                    provide: REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT,
                    useValue: REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT
                },
                /**
                 * The event that is used to show the toolbar item context.
                 */
                {
                    provide: 'SHOW_TOOLBAR_ITEM_CONTEXT',
                    useValue: SHOW_TOOLBAR_ITEM_CONTEXT
                },
                /**
                 * The event that is used to hide the toolbar item context.
                 */
                {
                    provide: 'HIDE_TOOLBAR_ITEM_CONTEXT',
                    useValue: HIDE_TOOLBAR_ITEM_CONTEXT
                },
                /**
                 * The ID of the event that is triggered when a notification is pushed or removed.
                 */
                {
                    provide: 'EVENT_NOTIFICATION_CHANGED',
                    useValue: 'EVENT_NOTIFICATION_CHANGED'
                },
                {
                    provide: 'OVERLAY_RERENDERED_EVENT',
                    useValue: OVERLAY_RERENDERED_EVENT
                },
                {
                    provide: 'WHO_AM_I_RESOURCE_URI',
                    useValue: WHO_AM_I_RESOURCE_URI
                },
                /**
                 * **Deprecated since 2005, `import EVENTS from smarteditconstants.ts`.**
                 *
                 * Events that are fired/handled in the SmartEdit application.
                 * @deprecated
                 */
                {
                    provide: 'EVENTS',
                    useValue: utils.EVENTS
                },
                /**
                 * A constant that is used as key to store the selected language in the storageService
                 */
                {
                    provide: 'SELECTED_LANGUAGE',
                    useValue: 'SELECTED_LANGUAGE'
                },
                /**
                 * A constant that is used as key to publish and receive events when a language is changed.
                 */
                {
                    provide: 'SWITCH_LANGUAGE_EVENT',
                    useValue: 'SWITCH_LANGUAGE_EVENT'
                },
                /**
                 * A constant that is used as key to publish and receive events when a component is updated.
                 */
                {
                    provide: 'EVENT_SMARTEDIT_COMPONENT_UPDATED',
                    useValue: EVENT_SMARTEDIT_COMPONENT_UPDATED
                },
                /**
                 * Injectable angular constant<br/>
                 * This object provides an enumeration of operation context for the application.
                 */
                {
                    provide: 'OPERATION_CONTEXT',
                    useValue: OPERATION_CONTEXT
                },
                /**
                 * Array containing files to be loaded in the inner frame before the main smartedit JS file.
                 * Only used for E2E modules, and is ignored in production code
                 */
                {
                    provide: 'SMARTEDIT_INNER_FILES',
                    useValue: 'SMARTEDIT_INNER_FILES'
                },
                /**
                 * Array containing files to be loaded in the inner frame after the main smartedit JS file.
                 * Only used for E2E modules, and is ignored in production code
                 */
                {
                    provide: 'SMARTEDIT_INNER_FILES_POST',
                    useValue: 'SMARTEDIT_INNER_FILES_POST'
                }
            ])
        })
    ], /* @ngInject */ SeConstantsModule);
    return /* @ngInject */ SeConstantsModule;
}());

var YPopoverTrigger;
(function (YPopoverTrigger) {
    YPopoverTrigger["Hover"] = "hover";
    YPopoverTrigger["Click"] = "click";
    YPopoverTrigger["Focus"] = "focus";
    YPopoverTrigger["OutsideClick"] = "outsideClick";
    YPopoverTrigger["None"] = "none";
})(YPopoverTrigger || (YPopoverTrigger = {}));
var YPopoverOnClickOutside;
(function (YPopoverOnClickOutside) {
    YPopoverOnClickOutside["Close"] = "close";
    YPopoverOnClickOutside["None"] = "none";
})(YPopoverOnClickOutside || (YPopoverOnClickOutside = {}));
/**
 * This directive attaches a customizable popover on a DOM element.
 *
 * ### Parameters
 *
 * `template` - the HTML body to be used in the popover body, it will automatically be trusted by the directive. Optional but exactly one of either template or templateUrl must be defined.
 *
 * `templateUrl` - the location of the HTML template to be used in the popover body. Optional but exactly one of either template or templateUrl must be defined.
 *
 * `title` - the title to be used in the popover title section. Optional.
 *
 * `placement` - the placement of the popover around the target element. Possible values are <b>top, left, right, bottom</b>, as well as any
 * concatenation of them with the following format: placement1-placement2 such as bottom-right. Optional, default value is top.
 *
 * `trigger` - the event type that will trigger the popover. Possibles values are <b>hover, click, outsideClick, none</b>. Optional, default value is 'click'.
 */
var /* @ngInject */ YPopoverDirective = /** @class */ (function () {
    YPopoverDirective.$inject = ["$scope", "$timeout", "$element", "yjQuery", "$templateCache", "yPopupEngineService", "$transclude"];
    function /* @ngInject */ YPopoverDirective($scope, $timeout, $element, yjQuery, $templateCache, yPopupEngineService, $transclude) {
        var _this = this;
        this.$scope = $scope;
        this.$timeout = $timeout;
        this.$element = $element;
        this.yjQuery = yjQuery;
        this.$templateCache = $templateCache;
        this.yPopupEngineService = yPopupEngineService;
        this.$transclude = $transclude;
        this.title = '';
        this.placement = 'top';
        this.transcludedContent = null;
        this.transclusionScope = null;
        this.engine = null;
        this.config = null;
        this.trigger = YPopoverTrigger.Click;
        this.isOpen = false;
        this.previousIsOpen = false;
        this.$transclude(function (clone, scope) {
            _this.$element.append(clone);
            _this.transcludedContent = clone;
            _this.transclusionScope = scope;
        });
    }
    /* @ngInject */ YPopoverDirective.prototype.$onInit = function () {
        var _this = this;
        var anchor = this.$element[0];
        var overlay = utils.windowUtils.isIframe() ? this.yjQuery('#' + OVERLAY_ID) : null;
        this.$scope.placement = this.placement;
        this.$scope.template = this.template;
        this.$scope.title = this.title;
        this.config = {
            placement: this.placement || 'top',
            trigger: this.trigger || YPopoverTrigger.Click,
            container: overlay && overlay.length ? overlay[0] : 'body',
            onShow: function () {
                _this.isOpen = true;
            },
            onHide: function () {
                _this.isOpen = false;
            },
            onChanges: function (element, data) {
                _this.$timeout(function () {
                    if (_this.placement !== data.placement) {
                        _this.placement = data.placement;
                    }
                });
            }
        };
        this.engine = new this.yPopupEngineService(anchor, this.getTemplate(), this.$scope, this.config);
        this.isOpen = !utils.stringUtils.isBlank(this.isOpen) ? this.isOpen : this.engine.isOpen;
    };
    /* @ngInject */ YPopoverDirective.prototype.$doCheck = function () {
        if (this.previousIsOpen !== this.isOpen) {
            if (this.isOpen) {
                this.engine.show();
            }
            else {
                this.engine.hide();
            }
            this.previousIsOpen = this.isOpen;
        }
    };
    /* @ngInject */ YPopoverDirective.prototype.$onChanges = function () {
        if (this.templateUrl) {
            this.template = this.$templateCache.get(this.templateUrl);
            delete this.templateUrl;
        }
        if (this.engine) {
            this.config.placement = this.placement || 'top';
            this.config.trigger = this.trigger || YPopoverTrigger.Click;
            this.engine.configure(this.config);
        }
    };
    /* @ngInject */ YPopoverDirective.prototype.$onDestroy = function () {
        this.engine.dispose();
        this.transcludedContent.remove();
        this.transclusionScope.$destroy();
    };
    /* @ngInject */ YPopoverDirective.prototype.getTemplate = function () {
        return "<y-popover-popup class=\"se-popover-popup\" data-placement=\"ypop.placement\" data-template=\"ypop.template\" data-title=\"ypop.title\"></y-popover-popup>";
    };
    /* @ngInject */ YPopoverDirective = __decorate([
        SeDirective({
            selector: '[y-popover]',
            transclude: true,
            replace: false,
            controllerAs: 'ypop',
            inputs: ['templateUrl:?', 'template:?', 'title:?', 'placement:?', 'trigger:?', 'isOpen:?']
        }),
        __metadata("design:paramtypes", [Object, Function, Object, Function, Object, Object, Function])
    ], /* @ngInject */ YPopoverDirective);
    return /* @ngInject */ YPopoverDirective;
}());

/**
 * Service that positions a template relative to an anchor element.
 */
var /* @ngInject */ YPopupEngineService = /** @class */ (function () {
    YPopupEngineService.$inject = ["$document", "$compile", "$timeout"];
    function /* @ngInject */ YPopupEngineService($document, $compile, $timeout) {
        var YPopupEngine = /** @class */ (function () {
            function YPopupEngine(anchorElement, template, scope, config) {
                var _this = this;
                this.anchorElement = anchorElement;
                this.template = template;
                this.scope = scope;
                this.eventListeners = [];
                this.isOpen = false;
                this.oldTrigger = null;
                this.resizeObserver = new ResizeObserver(function (entries) {
                    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                        var entry = entries_1[_i];
                        var element = entry.target;
                        if (element === _this.popupElement) {
                            _this.update();
                        }
                    }
                });
                this.popperConfig = {
                    modifiers: {
                        preventOverflow: {
                            padding: 0,
                            boundariesElement: 'viewport'
                        }
                    }
                };
                this.configure(config);
            }
            /**
             * Configures the popup engine.
             *
             * @param config.placement Default `'bottom'`.
             * @param config.trigger Default `'hover'`.
             * @param config.container Default `document.body`.
             * @param config.onClickOutside Default `'close'`.
             */
            YPopupEngine.prototype.configure = function (conf) {
                var _this = this;
                var config = conf || {};
                this.onChanges = config.onChanges;
                this.container = config.container || $document[0].body;
                this.onShow = config.onShow;
                this.onHide = config.onHide;
                this.disposing = false;
                this.config = {
                    placement: config.placement || 'bottom',
                    modifiers: config.modifiers,
                    trigger: config.trigger || YPopoverTrigger.Hover,
                    onClickOutside: config.onClickOutside || YPopoverOnClickOutside.Close,
                    onCreate: function (object) { return _this._onChanges(object); },
                    onUpdate: function (object) { return _this._onChanges(object); }
                };
                this.setTrigger(this.config.trigger);
            };
            YPopupEngine.prototype.show = function () {
                if (this.isOpen || this.disposing) {
                    return;
                }
                this.isOpen = true;
                this.popupScope = this.scope.$new(false);
                this.popupElement = $compile(this.template)(this.popupScope)[0];
                // FIXME: CMSX-6084
                this.popupInstance = new Popper(this.anchorElement, this.popupElement, lodash.merge(this.config, this.popperConfig));
                if (typeof this.container === 'string') {
                    angular$1.element(this.container)[0].appendChild(this.popupElement);
                }
                else {
                    this.container.appendChild(this.popupElement);
                }
                this.resizeObserver.observe(this.popupElement);
                if (this.onShow) {
                    this.onShow();
                }
                this.update();
            };
            YPopupEngine.prototype.hide = function () {
                if (!this.isOpen) {
                    return;
                }
                this.resizeObserver.unobserve(this.popupElement);
                this.popupScope.$destroy();
                this.popupInstance.destroy();
                this.popupElement.parentNode.removeChild(this.popupElement);
                if (this.onHide) {
                    this.onHide();
                }
                this.isOpen = false;
            };
            /**
             * Updates the position of the popup.
             */
            YPopupEngine.prototype.update = function () {
                if (this.isOpen) {
                    this.popupInstance.scheduleUpdate();
                }
            };
            YPopupEngine.prototype.setTrigger = function (newTrigger) {
                var _this = this;
                if (this.oldTrigger === newTrigger) {
                    return;
                }
                this.config.trigger = newTrigger;
                this.oldTrigger = newTrigger;
                this._removeTriggers();
                this._composeEvents(newTrigger).forEach(function (event) {
                    return _this._setEventListener(event);
                });
                if (this.config.onClickOutside === YPopoverOnClickOutside.Close &&
                    this.config.trigger === YPopoverTrigger.Click) {
                    var bodyClick_1 = function ($event) {
                        return $event.target !== _this.anchorElement &&
                            !_this.anchorElement.contains($event.target) &&
                            _this.hide();
                    };
                    $document[0].body.addEventListener('click', function ($event) {
                        $timeout(function () {
                            bodyClick_1($event);
                        });
                    });
                    this.eventListeners.push(function () {
                        $document[0].body.removeEventListener('click', bodyClick_1);
                    });
                }
            };
            YPopupEngine.prototype.dispose = function () {
                this.disposing = true;
                this.hide();
                this._removeTriggers();
            };
            /**
             * Removes event listeners from the anchor element.
             */
            YPopupEngine.prototype._removeTriggers = function () {
                this.eventListeners.forEach(function (unRegisterEvent) {
                    unRegisterEvent();
                });
                this.eventListeners = [];
            };
            YPopupEngine.prototype._onChanges = function (dataObject) {
                if (this.onChanges) {
                    this.onChanges(this.popupElement, dataObject);
                }
            };
            YPopupEngine.prototype._handleShow = function ($event) {
                $event.stopPropagation();
                $event.preventDefault();
                this.show();
            };
            YPopupEngine.prototype._handleHide = function ($event) {
                $event.stopPropagation();
                $event.preventDefault();
                this.hide();
            };
            YPopupEngine.prototype._setEventListener = function (event) {
                var _this = this;
                this.anchorElement.addEventListener(event.event, function ($event) {
                    $timeout(function () {
                        event.handle($event);
                    });
                });
                this.eventListeners.push(function () {
                    _this.anchorElement.removeEventListener(event.event, event.handle);
                });
            };
            YPopupEngine.prototype._composeEvents = function (trigger) {
                var _this = this;
                switch (trigger) {
                    case YPopoverTrigger.Click:
                        return [
                            {
                                event: 'click',
                                handle: function () { return (_this.isOpen ? _this.hide() : _this.show()); }
                            }
                        ];
                    case YPopoverTrigger.Hover:
                        return [
                            {
                                event: 'mouseenter',
                                handle: function (event) { return _this._handleShow(event); }
                            },
                            {
                                event: 'mouseleave',
                                handle: function (event) { return _this._handleHide(event); }
                            }
                        ];
                    case YPopoverTrigger.Focus:
                        return [
                            {
                                event: 'focus',
                                handle: function (event) { return _this._handleShow(event); }
                            },
                            {
                                event: 'blur',
                                handle: function (event) { return _this._handleHide(event); }
                            }
                        ];
                    case 'show':
                    case 'true':
                    case true:
                        this.show();
                        return [];
                    case 'hide':
                    case 'false':
                    case false:
                        this.hide();
                        return [];
                    default:
                        return [];
                }
            };
            return YPopupEngine;
        }());
        return YPopupEngine;
    }
    /* @ngInject */ YPopupEngineService = __decorate([
        SeInjectable(),
        __metadata("design:paramtypes", [Object, Function, Function])
    ], /* @ngInject */ YPopupEngineService);
    return /* @ngInject */ YPopupEngineService;
}());

/**
 * Contains some {@link YPopupOverlayDirective} helper functions for calculating positions and sizes on the DOM.
 */
var /* @ngInject */ YPopupOverlayUtilsClickOrderService = /** @class */ (function () {
    YPopupOverlayUtilsClickOrderService.$inject = ["$document", "$log"];
    function /* @ngInject */ YPopupOverlayUtilsClickOrderService($document, $log) {
        this.$document = $document;
        this.$log = $log;
        this.controllerRegistry = [];
    }
    /* @ngInject */ YPopupOverlayUtilsClickOrderService.prototype.register = function (instance) {
        var _this = this;
        var index = this.getIndex(instance);
        if (index === -1) {
            if (this.controllerRegistry.length === 0) {
                angular$1.element(this.$document[0].body)
                    .on('click', function (event) { return _this.clickHandler(event); });
            }
            this.controllerRegistry = __spreadArrays([instance], this.controllerRegistry);
        }
        else {
            this.$log.warn('yPopupOverlayUtilsClickOrderService.onHide() - instance already registered');
        }
    };
    YPopupOverlayUtilsClickOrderService.prototype.register.$inject = ["instance"];
    /* @ngInject */ YPopupOverlayUtilsClickOrderService.prototype.unregister = function (instance) {
        var _this = this;
        var index = this.getIndex(instance);
        if (index !== -1) {
            this.controllerRegistry.splice(index, 1);
        }
        if (this.controllerRegistry.length === 0) {
            angular$1.element(this.$document[0].body)
                .off('click', function (event) { return _this.clickHandler(event); });
        }
    };
    YPopupOverlayUtilsClickOrderService.prototype.unregister.$inject = ["instance"];
    /* @ngInject */ YPopupOverlayUtilsClickOrderService.prototype.clickHandler = function ($event) {
        if (this.controllerRegistry.length > 0) {
            this.controllerRegistry[0].onBodyElementClicked($event);
        }
    };
    YPopupOverlayUtilsClickOrderService.prototype.clickHandler.$inject = ["$event"];
    /* @ngInject */ YPopupOverlayUtilsClickOrderService.prototype.getIndex = function (instance) {
        return this.controllerRegistry.findIndex(function (entry) { return entry.uuid === instance.uuid; });
    };
    YPopupOverlayUtilsClickOrderService.prototype.getIndex.$inject = ["instance"];
    /* @ngInject */ YPopupOverlayUtilsClickOrderService = __decorate([
        SeInjectable(),
        __metadata("design:paramtypes", [Object, Object])
    ], /* @ngInject */ YPopupOverlayUtilsClickOrderService);
    return /* @ngInject */ YPopupOverlayUtilsClickOrderService;
}());

/**
 * Contains some {@link YPopupOverlayDirective} helper functions for calculating positions and sizes on the DOM
 */
var /* @ngInject */ YPopupOverlayUtilsDOMCalculations = /** @class */ (function () {
    YPopupOverlayUtilsDOMCalculations.$inject = ["$window", "$document"];
    function /* @ngInject */ YPopupOverlayUtilsDOMCalculations($window, $document) {
        this.$window = $window;
        this.$document = $document;
    }
    /**
     * Modifies the input rectangle to be absolutely positioned horizontally in the viewport.<br />
     * Does not modify vertical positioning.
     */
    /* @ngInject */ YPopupOverlayUtilsDOMCalculations.prototype.adjustHorizontalToBeInViewport = function (absPosition) {
        // HORIZONTAL POSITION / SIZE
        // if width of popup is wider then viewport, set it full width
        if (absPosition.width >= this.$window.innerWidth) {
            absPosition.left = 0;
            absPosition.width = this.$window.innerWidth;
        }
        else {
            var scrollWidth = this.getScrollBarWidth(); // maybe replace this with proper calculated value but im not sure if its worth the cpu cost
            // var scrollWidth = getScrollBarWidth();
            // if right edge of popup would be off the viewport on the right, then
            // move it left until right edge of popup is on right side of viewport
            if (absPosition.left - this.$window.pageXOffset + absPosition.width >=
                this.$window.innerWidth - scrollWidth) {
                absPosition.left = this.$window.innerWidth - absPosition.width - scrollWidth;
            }
            // if left edge is off the viewport to left, move to left edge
            if (absPosition.left - this.$window.pageXOffset <= 0) {
                absPosition.left = this.$window.pageXOffset;
            }
        }
    };
    YPopupOverlayUtilsDOMCalculations.prototype.adjustHorizontalToBeInViewport.$inject = ["absPosition"];
    /**
     * Calculates the preferred position of the overlay, based on the size and position of the anchor
     * and the size of the overlay element
     *
     * ### Parameters
     *
     * `anchorBoundingClientRect` - A bounding rectangle representing the overlay's anchor
     *
     * `anchorBoundingClientRect.top` - The top of the anchor, absolutely positioned
     *
     * `anchorBoundingClientRect.right` - The right of the anchor, absolutely positioned
     *
     * `anchorBoundingClientRect.bottom` - The bottom of the anchor, absolutely positioned
     *
     * `anchorBoundingClientRect.left` - The left of the anchor, absolutely positioned
     *
     * `targetWidth` - The width of the overlay element
     *
     * `targetHeight` - The height of the overlay element
     *
     * `[targetValign='bottom']` - The preferred vertical alignment, either 'top' or 'bottom'
     *
     * `[targetHalign='right']` - The preferred horizontal alignment, either 'left' or 'right'
     *
     * @returns A new size and position for the overlay
     */
    /* @ngInject */ YPopupOverlayUtilsDOMCalculations.prototype.calculatePreferredPosition = function (anchorBoundingClientRect, targetWidth, targetHeight, targetValign, targetHalign) {
        var scrollX = this.$window.pageXOffset;
        var scrollY = this.$window.pageYOffset;
        var position = {
            width: targetWidth,
            height: targetHeight,
            top: 0,
            left: 0
        };
        switch (targetValign) {
            case 'top':
                position.top = anchorBoundingClientRect.top + scrollY - targetHeight;
                break;
            case 'bottom':
            /* falls through */
            default:
                position.top = anchorBoundingClientRect.bottom + scrollY;
        }
        switch (targetHalign) {
            case 'left':
                position.left = anchorBoundingClientRect.right + scrollX - targetWidth;
                break;
            case 'right':
            /* falls through */
            default:
                position.left = anchorBoundingClientRect.left + scrollX;
        }
        return position;
    };
    YPopupOverlayUtilsDOMCalculations.prototype.calculatePreferredPosition.$inject = ["anchorBoundingClientRect", "targetWidth", "targetHeight", "targetValign", "targetHalign"];
    /* @ngInject */ YPopupOverlayUtilsDOMCalculations.prototype.getScrollBarWidth = function () {
        var isScrollHeightExceedingClientHeight = this.$document[0].body.scrollHeight > this.$document[0].body.clientHeight;
        if (!isScrollHeightExceedingClientHeight) {
            return 0;
        }
        var inner = this.$document[0].createElement('p');
        var outer = this.$document[0].createElement('div');
        inner.style.width = '100%';
        inner.style.height = '200px';
        outer.style.position = 'absolute';
        outer.style.top = '0px';
        outer.style.left = '0px';
        outer.style.visibility = 'hidden';
        outer.style.width = '200px';
        outer.style.height = '150px';
        outer.style.overflow = 'hidden';
        outer.appendChild(inner);
        this.$document[0].body.appendChild(outer);
        var w1 = inner.offsetWidth;
        var w2 = outer.clientWidth;
        outer.style.overflow = 'scroll';
        this.$document[0].body.removeChild(outer);
        return w1 - w2;
    };
    /* @ngInject */ YPopupOverlayUtilsDOMCalculations = __decorate([
        SeInjectable(),
        __metadata("design:paramtypes", [Object, Object])
    ], /* @ngInject */ YPopupOverlayUtilsDOMCalculations);
    return /* @ngInject */ YPopupOverlayUtilsDOMCalculations;
}());

var yPopupOverlayUuidPrefix = 'ypo-uuid-_';
/**
 *
 * **Deprecated since 2005, use {@link PopupOverlayComponent}.**
 *
 * The yPopupOverlay is meant to be a directive that allows popups/overlays to be displayed attached to any element.
 * The element that the directive is applied to is called the anchor element. Once the popup is displayed, it is
 * positioned relative to the anchor, depending on the configuration provided.<br />
 * <br />
 * <h3>Scrolling Limitation</h3>
 * In this initial implementation, it appends the popup element to the body, and positions itself relative to body.
 * This means that it can handle default window/body scrolling, but if the anchor is contained within an inner
 * scrollable DOM element then the positions will not work correctly.
 *
 * ### Parameters
 *
 * `yPopupOverlay` - see {@link YPopupDirectiveConfig}.
 *
 * `yPopupOverlay.halign` - Default `'right'`.
 *
 * `yPopupOverlay.valign` - Default `'left'`.
 *
 * `yPopupOverlayTrigger` - see {@link YPopupOverlayTrigger}.
 *
 * `yPopupOverlayOnShow` - An angular expression executed whenever this overlay is displayed
 *
 * `yPopupOverlayOnHide` - An angular expression executed whenever this overlay is hidden
 *
 * @deprecated
 */
var /* @ngInject */ YPopupOverlayDirective = /** @class */ (function () {
    YPopupOverlayDirective.$inject = ["$scope", "$element", "$compile", "$attrs", "$timeout", "yjQuery", "yPopupOverlayUtilsDOMCalculations", "yPopupOverlayUtilsClickOrderService"];
    function /* @ngInject */ YPopupOverlayDirective($scope, $element, $compile, $attrs, $timeout, yjQuery, yPopupOverlayUtilsDOMCalculations, yPopupOverlayUtilsClickOrderService) {
        var _this = this;
        this.$scope = $scope;
        this.$element = $element;
        this.$compile = $compile;
        this.$attrs = $attrs;
        this.$timeout = $timeout;
        this.yjQuery = yjQuery;
        this.yPopupOverlayUtilsDOMCalculations = yPopupOverlayUtilsDOMCalculations;
        this.yPopupOverlayUtilsClickOrderService = yPopupOverlayUtilsClickOrderService;
        this.togglePoppup = function ($event) {
            $event.stopPropagation();
            $event.preventDefault();
            return _this.popupDisplayed ? _this.hide() : _this.show();
        };
        this.$scope.closePopupOverlay = function () {
            _this.hide();
        };
    }
    /* @ngInject */ YPopupOverlayDirective.prototype.$onInit = function () {
        this.uuid = lodash.uniqueId(yPopupOverlayUuidPrefix);
        this.popupDisplayed = false;
        this.resetPopupSize();
        this.updateTriggers(YPopoverTrigger.Click);
        // only activate
        this.active = !!this.yPopupOverlay;
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.$doCheck = function () {
        if (!this.active) {
            return;
        }
        this.checkPopupSizeChanged();
        if (this.yPopupOverlayTrigger !== this.doCheckTrigger) {
            this.doCheckTrigger = this.yPopupOverlayTrigger;
            this.updateTriggers(this.yPopupOverlayTrigger);
        }
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.$onDestroy = function () {
        if (this.untrigger) {
            this.untrigger();
        }
        this.hide();
    };
    /**
     * Handles click event, triggered by the
     */
    /* @ngInject */ YPopupOverlayDirective.prototype.onBodyElementClicked = function ($event) {
        if (!this.popupElement) {
            return false;
        }
        var isPopupClicked = this.isChildOfElement(this.popupElement, $event.target);
        var isAnchorClicked = this.isChildOfElement(this.$element, $event.target);
        if (!isPopupClicked && !isAnchorClicked) {
            this.hide();
            $event.stopPropagation();
            $event.preventDefault();
            return true;
        }
        return false;
    };
    YPopupOverlayDirective.prototype.onBodyElementClicked.$inject = ["$event"];
    /**
     * Check if a this.yjQuery element contains a child element.
     * @param parentElement
     * @param childElement Click event target
     * @returns {boolean|*} True if parent contains child
     */
    /* @ngInject */ YPopupOverlayDirective.prototype.isChildOfElement = function (parentElement, childElement) {
        return (parentElement[0] === childElement ||
            this.yjQuery.contains(parentElement[0], childElement));
    };
    YPopupOverlayDirective.prototype.isChildOfElement.$inject = ["parentElement", "childElement"];
    /**
     * Calculates the size of the popup content and stores it.
     * Returns true if the size has changed since the previous call.
     */
    /* @ngInject */ YPopupOverlayDirective.prototype.checkPopupSizeChanged = function () {
        if (this.popupElement) {
            var firstChildOfRootPopupElement = this.popupElement.children().first();
            if (!firstChildOfRootPopupElement[0]) {
                return;
            }
            var popupBounds = firstChildOfRootPopupElement[0].getBoundingClientRect();
            var changed = popupBounds.width !== this.popupSize.width ||
                popupBounds.height !== this.popupSize.height;
            this.popupSize = {
                width: popupBounds.width,
                height: popupBounds.height
            };
            if (changed) {
                this.updatePopupElementPositionAndSize();
            }
        }
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.updatePopupElementPositionAndSize = function () {
        if (!this.popupElement) {
            return;
        }
        try {
            // Always calculate based on first child of popup, but apply css to root of popup
            // otherwise any applied css may harm the content by enforcing size
            var anchorBounds = this.$element[0].getBoundingClientRect();
            var position = this.yPopupOverlayUtilsDOMCalculations.calculatePreferredPosition(anchorBounds, this.popupSize.width, this.popupSize.height, this.yPopupOverlay.valign, this.yPopupOverlay.halign);
            this.yPopupOverlayUtilsDOMCalculations.adjustHorizontalToBeInViewport(position);
            this.popupElement.css(position);
        }
        catch (e) {
            // There are racing conditions where some of the elements are not ready yet...
            // Since we're constantly recalculating, this is just an easy way to avoid all these conditions
        }
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.getTemplateString = function () {
        var outerElement = this.yjQuery('<div>');
        outerElement.attr('data-uuid', this.uuid);
        outerElement.addClass('se-popover-outer');
        var innerElement;
        if (this.yPopupOverlay.template) {
            innerElement = this.yjQuery('<div>');
            innerElement.html(this.yPopupOverlay.template);
        }
        else if (this.yPopupOverlay.templateUrl) {
            innerElement = this.yjQuery('<data-ng-include>');
            innerElement.attr('src', "'" + this.yPopupOverlay.templateUrl + "'");
        }
        else {
            throw new Error('yPositiongetTemplateString() - Missing template');
        }
        innerElement.addClass('se-popover-inner');
        outerElement.append(innerElement);
        return outerElement[0].outerHTML;
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.hide = function () {
        var _this = this;
        if (!this.popupDisplayed) {
            return;
        }
        this.yPopupOverlayUtilsClickOrderService.unregister(this);
        if (this.popupElementScope) {
            this.popupElementScope.$destroy();
            this.popupElementScope = null;
        }
        if (this.popupElement) {
            this.popupElement.remove();
            this.popupElement = null;
        }
        if (this.$attrs.yPopupOverlayOnHide) {
            // We want to evaluate this angular expression inside of a digest cycle
            this.$timeout(function () { return _this.yPopupOverlayOnHide(); });
        }
        this.resetPopupSize();
        this.popupDisplayed = false;
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.show = function () {
        var _this = this;
        if (this.popupDisplayed) {
            return;
        }
        var popupElement = this.getTemplateString();
        this.popupElementScope = this.$scope.$new(false);
        this.popupElement = this.$compile(popupElement)(this.popupElementScope);
        var containerElement = windowUtils.isIframe()
            ? this.yjQuery('#' + OVERLAY_ID)
            : this.yjQuery('body');
        this.updatePopupElementPositionAndSize();
        this.popupElement.appendTo(containerElement);
        angular$1.element(function () {
            _this.updatePopupElementPositionAndSize();
            _this.yPopupOverlayUtilsClickOrderService.register(_this);
            if (_this.$attrs.yPopupOverlayOnShow) {
                // We want to evaluate this angular expression inside of a digest cycle
                _this.$timeout(function () {
                    _this.yPopupOverlayOnShow();
                });
            }
        });
        this.popupDisplayed = true;
    };
    /* @ngInject */ YPopupOverlayDirective.prototype.updateTriggers = function (trigger) {
        var _this = this;
        if (this.oldTrigger === trigger) {
            return;
        }
        this.oldTrigger = trigger;
        if (this.untrigger) {
            this.untrigger();
        }
        if (trigger === YPopoverTrigger.Click) {
            angular$1.element(this.$element).on('click', this.togglePoppup);
            this.untrigger = function () {
                angular$1.element(_this.$element).off('click', _this.togglePoppup);
            };
            return;
        }
        if (trigger === 'true' || trigger === true) {
            this.show();
        }
        else {
            this.hide();
        }
    };
    YPopupOverlayDirective.prototype.updateTriggers.$inject = ["trigger"];
    /* @ngInject */ YPopupOverlayDirective.prototype.resetPopupSize = function () {
        this.popupSize = {
            width: 0,
            height: 0
        };
    };
    /* @ngInject */ YPopupOverlayDirective = __decorate([
        SeDirective({
            selector: '[y-popup-overlay]',
            scope: false,
            inputs: [
                'yPopupOverlay:=',
                'yPopupOverlayTrigger:=',
                'yPopupOverlayOnShow:&',
                'yPopupOverlayOnHide:&'
            ]
        }),
        __metadata("design:paramtypes", [Object, Object, Function, Object, Function, Function, YPopupOverlayUtilsDOMCalculations,
            YPopupOverlayUtilsClickOrderService])
    ], /* @ngInject */ YPopupOverlayDirective);
    return /* @ngInject */ YPopupOverlayDirective;
}());

var /* @ngInject */ YPopupOverlayModule = /** @class */ (function () {
    function /* @ngInject */ YPopupOverlayModule() {
    }
    /* @ngInject */ YPopupOverlayModule = __decorate([
        SeModule({
            imports: [FunctionsModule, SeConstantsModule],
            providers: [
                YPopupEngineService,
                YPopupOverlayUtilsClickOrderService,
                YPopupOverlayUtilsDOMCalculations
            ],
            declarations: [YPopupOverlayDirective]
        })
    ], /* @ngInject */ YPopupOverlayModule);
    return /* @ngInject */ YPopupOverlayModule;
}());

/**
 * Internal component for the yPopover to hold the bindings for the template, placement, and title.
 */
var /* @ngInject */ YPopoverPopupComponent = /** @class */ (function () {
    function /* @ngInject */ YPopoverPopupComponent() {
    }
    /* @ngInject */ YPopoverPopupComponent = __decorate([
        SeComponent({
            selector: 'y-popover-popup',
            templateUrl: 'yPopoverPopupTemplate.html',
            inputs: ['title:?', 'template:?', 'placement:?']
        })
    ], /* @ngInject */ YPopoverPopupComponent);
    return /* @ngInject */ YPopoverPopupComponent;
}());

var /* @ngInject */ YPopoverModule = /** @class */ (function () {
    function /* @ngInject */ YPopoverModule() {
    }
    /* @ngInject */ YPopoverModule = __decorate([
        SeModule({
            imports: ['coretemplates', YPopupOverlayModule, FunctionsModule, SeConstantsModule],
            declarations: [YPopoverDirective, YPopoverPopupComponent]
        })
    ], /* @ngInject */ YPopoverModule);
    return /* @ngInject */ YPopoverModule;
}());

var /* @ngInject */ YHelpModule = /** @class */ (function () {
    function /* @ngInject */ YHelpModule() {
    }
    /* @ngInject */ YHelpModule = __decorate([
        SeModule({
            imports: [YPopoverModule],
            declarations: [YHelpComponent]
        })
    ], /* @ngInject */ YHelpModule);
    return /* @ngInject */ YHelpModule;
}());

// import { UriDropdownPopulator } from './uri';
// import { OptionsDropdownPopulator } from './options';
/**
 * Interface describing the contract of a DropdownPopulator resolved by
 * {@link GenericEditorFactoryService} to populate the dropdowns of {@link GenericEditorDropdownComponent}.
 */
var DropdownPopulatorInterface = /** @class */ (function () {
    function DropdownPopulatorInterface(lodash, languageService, translateService) {
        this.lodash = lodash;
        this.languageService = languageService;
        this.translateService = translateService;
    }
    DropdownPopulatorInterface.prototype.getItem = function (payload) {
        return null;
    };
    /**
     * Returns a promise resolving to a list of items.
     * The items must all contain a property `id`.
     */
    DropdownPopulatorInterface.prototype.fetchAll = function (payload) {
        'proxyFunction';
        return null;
    };
    /**
     * Returns a promise resolving to a page of items.
     * The items must all contain a property `id`.
     */
    DropdownPopulatorInterface.prototype.fetchPage = function (payload) {
        'proxyFunction';
        return null;
    };
    /**
     * Specifies whether this populator is meant to work in paged mode as opposed to retrieve lists. Optional, default is false.
     */
    DropdownPopulatorInterface.prototype.isPaged = function () {
        return false;
    };
    /**
     * Populates the id and label property for each item in the list. If the label property is not already set,
     * then we use an ordered list of attributes to use when determining the label for each item.
     * @param items The array of items to set the id and label attributes on
     * @param idAttribute The name of the id attribute
     * @param orderedLabelAttributes The ordered list of label attributes
     * @returns The modified list of items
     */
    DropdownPopulatorInterface.prototype.populateAttributes = function (items, idAttribute, orderedLabelAttributes) {
        var _this = this;
        return this.lodash.map(items, function (item) {
            if (idAttribute && _this.lodash.isEmpty(item.id)) {
                item.id = item[idAttribute];
            }
            if (orderedLabelAttributes && _this.lodash.isEmpty(item.label)) {
                // Find the first attribute that the item object contains
                var labelAttribute = _this.lodash.find(orderedLabelAttributes, function (attr) { return !_this.lodash.isEmpty(item[attr]); });
                // If we found an attribute, set the label
                if (labelAttribute) {
                    item.label = item[labelAttribute];
                }
            }
            return item;
        });
    };
    /**
     * Searches a list and returns a promise resolving to only items with a label attribute that matches the search term.
     * @param items The list of items to search
     * @param searchTerm The search term to filter items by
     * @returns The filtered list of items
     */
    DropdownPopulatorInterface.prototype.search = function (items, searchTerm) {
        var _this = this;
        return this.languageService.getResolveLocale().then(function (isocode) {
            return _this.lodash.filter(items, function (item) {
                var labelValue;
                if (_this.lodash.isObject(item.label)) {
                    isocode = item.label[isocode] ? isocode : Object.keys(item.label)[0];
                    labelValue = item.label[isocode];
                }
                else {
                    labelValue = _this.translateService
                        ? _this.translateService.instant(item.label)
                        : item.label;
                }
                return (labelValue && labelValue.toUpperCase().indexOf(searchTerm.toUpperCase()) > -1);
            });
        });
    };
    return DropdownPopulatorInterface;
}());

/**
 * Implementation of {@link DropdownPopulatorInterface} for "EditableDropdown" cmsStructureType
 * containing options attribute.
 */
var /* @ngInject */ OptionsDropdownPopulator = /** @class */ (function (_super) {
    __extends(/* @ngInject */ OptionsDropdownPopulator, _super);
    OptionsDropdownPopulator.$inject = ["languageService", "translateService"];
    function /* @ngInject */ OptionsDropdownPopulator(languageService, translateService) {
        var _this = _super.call(this, lodash, languageService, translateService) || this;
        _this.languageService = languageService;
        _this.translateService = translateService;
        return _this;
    }
    /**
     * Implementation of the [fetchAll]{@link DropdownPopulatorInterface#fetchAll} method.
     */
    /* @ngInject */ OptionsDropdownPopulator.prototype.fetchAll = function (payload) {
        var options = this.populateAttributes(payload.field.options, payload.field.idAttribute, payload.field.labelAttributes);
        if (payload.search) {
            return this.search(options, payload.search);
        }
        return Promise.resolve(options);
    };
    OptionsDropdownPopulator.prototype.fetchAll.$inject = ["payload"];
    /* @ngInject */ OptionsDropdownPopulator = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [LanguageService,
            core$1.TranslateService])
    ], /* @ngInject */ OptionsDropdownPopulator);
    return /* @ngInject */ OptionsDropdownPopulator;
}(DropdownPopulatorInterface));

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Used to register Custom Populators that will be available for `GenericEditorDropdownServiceFactory`.
 *
 * A custom populator can be registered by providing the name of that populator without "DropdownPopulator" suffix
 * in the following properties of {@link GenericEditorField}.
 *
 * - propertType - e.g. `MyCustomDropdownPopulator` -> { propertyType: 'myCustom' }
 *
 * - cmsStrutureType - e.g. `MyCustomDropdownPopulator` -> { cmsStructureType: 'myCustom' }
 *
 * - smarteditComponentType - e.g. `MyCustomDropdownPopulator` -> { smarteditComponentType: 'myCustom' }
 *
 * - smarteditComponentType + qualifier - e.g. `MyCustomProductDropdownPopulator` { smarteditComponentType: 'myCustom', qualifier: 'product' }
 *
 * Note: The value of those properties is case insensitive.
 *
 * ### Example
 *
 *      \@NgModule({
 *          imports: [],
 *          providers: [
 *              {
 *                  provide: CustomDropdownPopulatorsToken,
 *                  useClass: MyCustomDropdownPopulator,
 *                  multi: true
 *               }
 *          ]
 *      })
 *      export class ExtensionModule {};
 */
var CustomDropdownPopulatorsToken = new core.InjectionToken('CustomDropdownPopulatorsToken');
var IDropdownPopulatorInterface = new core.InjectionToken('IDropdownPopulatorInterface');

/**
 * Implementation of {@link DropdownPopulatorInterface} for "EditableDropdown" `cmsStructureType` containing `uri` attribute.
 */
var /* @ngInject */ UriDropdownPopulator = /** @class */ (function (_super) {
    __extends(/* @ngInject */ UriDropdownPopulator, _super);
    UriDropdownPopulator.$inject = ["restServiceFactory", "languageService", "translateService"];
    function /* @ngInject */ UriDropdownPopulator(restServiceFactory, languageService, translateService) {
        var _this = _super.call(this, lodash, languageService, translateService) || this;
        _this.restServiceFactory = restServiceFactory;
        _this.languageService = languageService;
        _this.translateService = translateService;
        return _this;
    }
    /**
     * Implementation of the [fetchAll]{@link DropdownPopulatorInterface#fetchAll} method.
     */
    /* @ngInject */ UriDropdownPopulator.prototype.fetchAll = function (payload) {
        var _this = this;
        var params;
        if (payload.field.dependsOn) {
            params = this._buildQueryParams(payload.field.dependsOn, payload.model);
        }
        return this.restServiceFactory
            .get(payload.field.uri)
            .get(params)
            .then(function (response) {
            var dataFromResponse = apiUtils.getDataFromResponse(response);
            var options = _this.populateAttributes(dataFromResponse, payload.field.idAttribute, payload.field.labelAttributes);
            if (payload.search) {
                return _this.search(options, payload.search);
            }
            return Promise.resolve(options);
        });
    };
    UriDropdownPopulator.prototype.fetchAll.$inject = ["payload"];
    /**
     * Implementation of the [fetchPage]{@link DropdownPopulatorInterface#fetchPage} method.
     */
    /* @ngInject */ UriDropdownPopulator.prototype.fetchPage = function (payload) {
        var _this = this;
        var params = {};
        if (payload.field.dependsOn) {
            params = this._buildQueryParams(payload.field.dependsOn, payload.model);
        }
        params.pageSize = payload.pageSize;
        params.currentPage = payload.currentPage;
        params.mask = payload.search;
        if (payload.field.params) {
            this.lodash.extend(params, payload.field.params);
        }
        return this.restServiceFactory
            .get(payload.field.uri)
            .get(params)
            .then(function (response) {
            var key = apiUtils.getKeyHoldingDataFromResponse(response);
            response[key] = _this.populateAttributes(response[key], payload.field.idAttribute, payload.field.labelAttributes);
            return Promise.resolve(response);
        });
    };
    UriDropdownPopulator.prototype.fetchPage.$inject = ["payload"];
    /**
     * Implementation of the [getItem]{@link DropdownPopulatorInterface#getItem} method.
     * @returns A promise that resolves to the option that was fetched
     */
    /* @ngInject */ UriDropdownPopulator.prototype.getItem = function (payload) {
        var _this = this;
        return this.restServiceFactory
            .get(payload.field.uri)
            .getById(payload.id)
            .then(function (item) {
            item = _this.populateAttributes([item], payload.field.idAttribute, payload.field.labelAttributes)[0];
            return Promise.resolve(item);
        });
    };
    UriDropdownPopulator.prototype.getItem.$inject = ["payload"];
    /* @ngInject */ UriDropdownPopulator.prototype._buildQueryParams = function (dependsOn, model) {
        var queryParams = dependsOn.split(',').reduce(function (obj, current) {
            obj[current] = model[current];
            return obj;
        }, {});
        return queryParams;
    };
    UriDropdownPopulator.prototype._buildQueryParams.$inject = ["dependsOn", "model"];
    /* @ngInject */ UriDropdownPopulator = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [utils.RestServiceFactory,
            LanguageService,
            core$1.TranslateService])
    ], /* @ngInject */ UriDropdownPopulator);
    return /* @ngInject */ UriDropdownPopulator;
}(DropdownPopulatorInterface));

/**
 * For AngularJS, Custom Dropdown Populator classes extend the DropdownPopulatorInterface,
 * so here we return constructor function with pre-set dependencies.
 */
var dropdownPopulatorInterfaceConstructorFactory = function (languageService, translateService) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super.call(this, lodash, languageService, translateService) || this;
        }
        return class_1;
    }(DropdownPopulatorInterface));
};
var DropdownPopulatorModule = /** @class */ (function () {
    function DropdownPopulatorModule() {
    }
    DropdownPopulatorModule = __decorate([
        core.NgModule({
            providers: [
                OptionsDropdownPopulator,
                UriDropdownPopulator,
                {
                    // required for AngularJS
                    provide: IDropdownPopulatorInterface,
                    useFactory: dropdownPopulatorInterfaceConstructorFactory,
                    deps: [LanguageService, core$1.TranslateService]
                },
                moduleUtils.initialize(function () {
                    // make IDropdownPopulatorInterface provider (DropdownPopulatorInterface) available in AngularJS by 'DropdownPopulatorInterface'
                    diBridgeUtils.downgradeService('DropdownPopulatorInterface', null, IDropdownPopulatorInterface);
                })
            ]
        })
    ], DropdownPopulatorModule);
    return DropdownPopulatorModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "ActionableSearchItemComponent", {
    selector: 'se-actionable-search-item',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-actionable-search-item]': 'true'
    },
    template: "<div *ngIf=\"search\" class=\"se-actionable-search-item\"><div class=\"se-actionable-search-item__name\">{{ search }}</div><button type=\"button\" class=\"fd-button--light se-actionable-search-item__action-btn\" (click)=\"onButtonClick()\">{{ getActionText() | translate }}</button></div>"
});
var ActionableSearchItemComponent = /** @class */ (function () {
    function ActionableSearchItemComponent(systemEventService) {
        this.systemEventService = systemEventService;
        this.actionButtonClick = new core.EventEmitter();
        this.defaultEventId = 'yActionableSearchItem_ACTION_CREATE';
        this.defaultActionText = 'se.yationablesearchitem.action.create';
    }
    ActionableSearchItemComponent.prototype.getActionText = function () {
        return this.actionText || this.defaultActionText;
    };
    ActionableSearchItemComponent.prototype.onButtonClick = function () {
        var evtId = this.eventId || this.defaultEventId;
        this.systemEventService.publishAsync(evtId, this.search || '');
        this.actionButtonClick.emit();
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], ActionableSearchItemComponent.prototype, "search", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ActionableSearchItemComponent.prototype, "eventId", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ActionableSearchItemComponent.prototype, "actionText", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], ActionableSearchItemComponent.prototype, "actionButtonClick", void 0);
    ActionableSearchItemComponent = __decorate([
        core.Component({
            selector: 'se-actionable-search-item',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-actionable-search-item]': 'true'
            },
            template: "<div *ngIf=\"search\" class=\"se-actionable-search-item\"><div class=\"se-actionable-search-item__name\">{{ search }}</div><button type=\"button\" class=\"fd-button--light se-actionable-search-item__action-btn\" (click)=\"onButtonClick()\">{{ getActionText() | translate }}</button></div>"
        }),
        __metadata("design:paramtypes", [SystemEventService])
    ], ActionableSearchItemComponent);
    return ActionableSearchItemComponent;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var ITEM_COMPONENT_DATA_TOKEN = new core.InjectionToken('ITEM_COMPONENT_DATA');

var L10nPipeModule = /** @class */ (function () {
    function L10nPipeModule() {
    }
    L10nPipeModule = __decorate([
        core.NgModule({
            declarations: [L10nPipe],
            exports: [L10nPipe]
        })
    ], L10nPipeModule);
    return L10nPipeModule;
}());

/**
 * Returns an array containing the items from the specified collection in reverse order.
 */
var ReversePipe = /** @class */ (function () {
    function ReversePipe() {
    }
    ReversePipe.prototype.transform = function (value) {
        if (!value) {
            return undefined;
        }
        return value.slice().reverse();
    };
    ReversePipe = __decorate([
        core.Pipe({ name: 'seReverse' })
    ], ReversePipe);
    return ReversePipe;
}());

var ReversePipeModule = /** @class */ (function () {
    function ReversePipeModule() {
    }
    ReversePipeModule = __decorate([
        core.NgModule({
            declarations: [ReversePipe],
            exports: [ReversePipe]
        })
    ], ReversePipeModule);
    return ReversePipeModule;
}());

/**
 * Pipe used to filter array of objects by object passed as an argument.
 *
 * The pipe will return array of objects that contains the exact keys and values of passed object.
 *
 * ### Example
 *
 *      <div *ngFor='let item of items | seProperty:{ isEnabled: true }'></div>
 */
var PropertyPipe = /** @class */ (function () {
    function PropertyPipe() {
    }
    PropertyPipe.prototype.transform = function (array, propObject) {
        if (!array) {
            return undefined;
        }
        if (!propObject) {
            return __spreadArrays(array);
        }
        return array.filter(function (item) {
            return Object.keys(propObject).every(function (key) { return item[key] === propObject[key]; });
        });
    };
    PropertyPipe = __decorate([
        core.Pipe({ name: 'seProperty' })
    ], PropertyPipe);
    return PropertyPipe;
}());

var PropertyPipeModule = /** @class */ (function () {
    function PropertyPipeModule() {
    }
    PropertyPipeModule = __decorate([
        core.NgModule({
            declarations: [PropertyPipe],
            exports: [PropertyPipe]
        })
    ], PropertyPipeModule);
    return PropertyPipeModule;
}());

/**
 * Used to slice the array of items starting from index passed as an argument.
 */
var StartFromPipe = /** @class */ (function () {
    function StartFromPipe() {
    }
    StartFromPipe_1 = StartFromPipe;
    StartFromPipe.transform = function (input, start) {
        return input ? input.slice(Number(start)) : [];
    };
    StartFromPipe.prototype.transform = function (input, start) {
        return StartFromPipe_1.transform(input, start);
    };
    var StartFromPipe_1;
    StartFromPipe = StartFromPipe_1 = __decorate([
        core.Pipe({
            name: 'seStartFrom'
        })
    ], StartFromPipe);
    return StartFromPipe;
}());

var StartFromPipeModule = /** @class */ (function () {
    function StartFromPipeModule() {
    }
    StartFromPipeModule = __decorate([
        core.NgModule({
            declarations: [StartFromPipe],
            exports: [StartFromPipe]
        })
    ], StartFromPipeModule);
    return StartFromPipeModule;
}());

/**
 * A pipe for an array of objects, that will search all the first level fields of an object,
 * or optionally allows you to specify which fields to include in the search.
 *
 * Only fields that correspond to string
 * values will be considered in the filtering. The filter implements the AND strategy, thus the filter will return search results
 * regardless of the search string order. IE search string "Add Mobile" will return strings such "Mobile Address" and "Address Mobile".
 */
var FilterByFieldPipe = /** @class */ (function () {
    function FilterByFieldPipe() {
    }
    FilterByFieldPipe_1 = FilterByFieldPipe;
    /** @ignore */
    FilterByFieldPipe.transform = function (items, query, keys, callbackFn) {
        var callback = callbackFn || lodash.noop;
        var filterResult = [];
        if (!query) {
            callback(items);
            return items;
        }
        var queryList = query.toLowerCase().split(' ');
        (items || []).forEach(function (item) {
            keys = keys || Object.keys(item);
            var terms = keys
                .map(function (key) { return item[key]; })
                .filter(function (value) {
                // eslint-disable-next-line @typescript-eslint/ban-types
                return typeof value === 'string' || value instanceof String;
            })
                .map(function (value) { return value.toLowerCase(); });
            var matchList = queryList
                .map(function (queryItem) {
                return !!terms.find(function (term) { return term.indexOf(queryItem) >= 0; });
            })
                .filter(function (exists) { return !exists; });
            if (matchList.length === 0) {
                filterResult.push(item);
            }
        });
        callback(filterResult);
        return filterResult;
    };
    /**
     * @param query The search string in which the values will be filtered by. If no search string is given
     * the original array of objects is be returned.
     * @param keys An array of object fields which determines which key values that the filter will parse through.
     * If no array is specified the filter will check each field value in the array of objects.
     * @param callbackFn A function that will be executed after each iteration of the filter.
     */
    FilterByFieldPipe.prototype.transform = function (items, query, keys, callbackFn) {
        return FilterByFieldPipe_1.transform(items, query, keys, callbackFn);
    };
    var FilterByFieldPipe_1;
    FilterByFieldPipe = FilterByFieldPipe_1 = __decorate([
        core.Pipe({ name: 'seFilterByField' })
    ], FilterByFieldPipe);
    return FilterByFieldPipe;
}());

var FilterByFieldPipeModule = /** @class */ (function () {
    function FilterByFieldPipeModule() {
    }
    FilterByFieldPipeModule = __decorate([
        core.NgModule({
            declarations: [FilterByFieldPipe],
            exports: [FilterByFieldPipe]
        })
    ], FilterByFieldPipeModule);
    return FilterByFieldPipeModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "SpinnerComponent", {
    selector: 'se-spinner',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: "\n        <div\n            *ngIf=\"isSpinning\"\n            class=\"se-spinner panel-body\"\n            [ngClass]=\"{ 'se-spinner--fluid': isFluid }\"\n        >\n            <div class=\"spinner\">\n                <div class=\"spinner-container spinner-container1\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n                <div class=\"spinner-container spinner-container2\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n                <div class=\"spinner-container spinner-container3\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n            </div>\n        </div>\n    "
});
var /* @ngInject */ SpinnerComponent = /** @class */ (function () {
    function /* @ngInject */ SpinnerComponent() {
        this.isFluid = true;
    }
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], /* @ngInject */ SpinnerComponent.prototype, "isSpinning", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SpinnerComponent.prototype, "isFluid", void 0);
    /* @ngInject */ SpinnerComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-spinner',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            template: "\n        <div\n            *ngIf=\"isSpinning\"\n            class=\"se-spinner panel-body\"\n            [ngClass]=\"{ 'se-spinner--fluid': isFluid }\"\n        >\n            <div class=\"spinner\">\n                <div class=\"spinner-container spinner-container1\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n                <div class=\"spinner-container spinner-container2\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n                <div class=\"spinner-container spinner-container3\">\n                    <div class=\"spinner-circle1\"></div>\n                    <div class=\"spinner-circle2\"></div>\n                    <div class=\"spinner-circle3\"></div>\n                    <div class=\"circle4\"></div>\n                </div>\n            </div>\n        </div>\n    "
        })
    ], /* @ngInject */ SpinnerComponent);
    return /* @ngInject */ SpinnerComponent;
}());

var SpinnerModule = /** @class */ (function () {
    function SpinnerModule() {
    }
    SpinnerModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule],
            declarations: [SpinnerComponent],
            entryComponents: [SpinnerComponent],
            exports: [SpinnerComponent]
        })
    ], SpinnerModule);
    return SpinnerModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "InfiniteScrollingComponent", {
    selector: 'se-infinite-scrolling',
    template: "<div #container class=\"se-infinite-scrolling__container\" [ngClass]=\"dropDownContainerClass\" fdInfiniteScroll (onScrollAction)=\"nextPage()\" [scrollPercent]=\"distance\" *ngIf=\"initiated\"><div class=\"se-infinite-scrolling__holder\" [ngClass]=\"dropDownClass\"><div #content><ng-content></ng-content></div><div class=\"spinner-container\"><se-spinner [isSpinning]=\"isLoading\" [isFluid]=\"false\"></se-spinner></div></div></div>",
    styles: ["se-infinite-scrolling.se-infinite-scrolling--narrowed .se-infinite-scrolling__holder{padding:0 20px}se-infinite-scrolling .se-infinite-scrolling__container{overflow-y:auto;max-height:200px}se-infinite-scrolling .se-infinite-scrolling__holder{overflow-y:hidden}"],
    encapsulation: core.ViewEncapsulation.None
});
var /* @ngInject */ InfiniteScrollingComponent = /** @class */ (function () {
    InfiniteScrollingComponent.$inject = ["discardablePromiseUtils", "cdr"];
    function /* @ngInject */ InfiniteScrollingComponent(discardablePromiseUtils, cdr) {
        this.discardablePromiseUtils = discardablePromiseUtils;
        this.cdr = cdr;
        this.distance = 80;
        this.itemsChange = new core.EventEmitter();
        this.containerId = stringUtils.generateIdentifier();
        this.initiated = false;
        this.isLoading = false;
    }
    /* @ngInject */ InfiniteScrollingComponent.prototype.ngOnInit = function () {
        this.init();
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.ngOnChanges = function () {
        this.context = this.context || this;
        this.init();
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.ngAfterViewInit = function () {
        this.initContentResizeObserver();
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.ngOnDestroy = function () {
        this.discardablePromiseUtils.clear(this.containerId);
        this.contentResizeObserver.disconnect();
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.nextPage = function () {
        var _this = this;
        if (this.pagingDisabled) {
            return;
        }
        this.pagingDisabled = true;
        this.currentPage = this.currentPage + 1;
        this.mask = this.mask || '';
        this.isLoading = true;
        this.discardablePromiseUtils.apply(this.containerId, this.fetchPage(this.mask, this.pageSize, this.currentPage), function (page) {
            page.results = page.results || [];
            page.results.forEach(function (element) {
                element.technicalUniqueId = stringUtils.encode(element);
            });
            var uniqueResults = lodash.differenceBy(page.results, _this.context.items, 'technicalUniqueId');
            if (uniqueResults.length > 0) {
                _this.context.items = __spreadArrays(_this.context.items, (uniqueResults || []));
            }
            _this.itemsChange.emit(_this.context.items);
            _this.pagingDisabled =
                page.pagination === undefined ||
                    page.results.length === 0 ||
                    (page.pagination && _this.context.items.length === page.pagination.totalCount);
            if (page.pagination !== undefined &&
                _this.context.items.length === 0 &&
                page.pagination.page < page.pagination.totalPages) {
                _this.pagingDisabled = false;
                _this.nextPage();
            }
            if (_this.pagingDisabled) {
                _this.isLoading = false;
                _this.cdr.detectChanges();
                return;
            }
        });
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.scrollToTop = function () {
        if (this.containerElement) {
            this.containerElement.nativeElement.scrollTop = 0;
        }
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.scrollToBottom = function () {
        if (this.containerElement) {
            this.containerElement.nativeElement.scrollTop = this.containerElement.nativeElement.scrollHeight;
        }
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.init = function () {
        var wasInitiated = this.initiated;
        this.context.items = [];
        this.currentPage = -1;
        this.pagingDisabled = false;
        this.initiated = true;
        if (wasInitiated) {
            this.scrollToTop();
            this.nextPage();
        }
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.initContentResizeObserver = function () {
        var _this = this;
        this.contentResizeObserver = new ResizeObserver(function (entries) {
            var contentRect = entries[0].contentRect;
            var isInitialChange = contentRect.height === 0;
            if (!_this.pagingDisabled && _this.isLoading && !isInitialChange) {
                if (_this.shouldLoadNextPage()) {
                    _this.nextPage();
                }
                else {
                    _this.isLoading = false;
                    _this.cdr.detectChanges();
                }
                _this.contentResizeObserver.disconnect();
            }
        });
        this.contentResizeObserver.observe(this.contentElement.nativeElement);
    };
    /* @ngInject */ InfiniteScrollingComponent.prototype.shouldLoadNextPage = function () {
        var contentHeight = this.contentElement.nativeElement.offsetHeight;
        var containerHeight = this.containerElement.nativeElement.offsetHeight;
        var shouldLoad = contentHeight <= containerHeight;
        return shouldLoad;
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "pageSize", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "mask", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "dropDownContainerClass", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "dropDownClass", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "distance", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "context", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "fetchPage", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "itemsChange", void 0);
    __decorate([
        core.ViewChild('container', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "containerElement", void 0);
    __decorate([
        core.ViewChild('content', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ InfiniteScrollingComponent.prototype, "contentElement", void 0);
    /* @ngInject */ InfiniteScrollingComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-infinite-scrolling',
            template: "<div #container class=\"se-infinite-scrolling__container\" [ngClass]=\"dropDownContainerClass\" fdInfiniteScroll (onScrollAction)=\"nextPage()\" [scrollPercent]=\"distance\" *ngIf=\"initiated\"><div class=\"se-infinite-scrolling__holder\" [ngClass]=\"dropDownClass\"><div #content><ng-content></ng-content></div><div class=\"spinner-container\"><se-spinner [isSpinning]=\"isLoading\" [isFluid]=\"false\"></se-spinner></div></div></div>",
            styles: ["se-infinite-scrolling.se-infinite-scrolling--narrowed .se-infinite-scrolling__holder{padding:0 20px}se-infinite-scrolling .se-infinite-scrolling__container{overflow-y:auto;max-height:200px}se-infinite-scrolling .se-infinite-scrolling__holder{overflow-y:hidden}"],
            encapsulation: core.ViewEncapsulation.None
        }),
        __metadata("design:paramtypes", [DiscardablePromiseUtils,
            core.ChangeDetectorRef])
    ], /* @ngInject */ InfiniteScrollingComponent);
    return /* @ngInject */ InfiniteScrollingComponent;
}());

var InfiniteScrollingModule = /** @class */ (function () {
    function InfiniteScrollingModule() {
    }
    InfiniteScrollingModule = __decorate([
        core.NgModule({
            imports: [core$2.InfiniteScrollModule, SpinnerModule, common.CommonModule],
            declarations: [InfiniteScrollingComponent],
            entryComponents: [InfiniteScrollingComponent],
            exports: [InfiniteScrollingComponent]
        })
    ], InfiniteScrollingModule);
    return InfiniteScrollingModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "DefaultItemPrinterComponent", {
    selector: 'se-default-item-printer',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    styles: [".se-item-printer-text{vertical-align:middle;position:relative;max-width:100%;font-family:\"72\";color:#51555a;display:inline-block}"],
    template: "<span [attr.title]=\"((data.item.label || data.item.name) | seL10n | async) | translate\" class=\"se-item-printer-text se-nowrap-ellipsis\">{{ ((data.item.label || data.item.name) | seL10n | async) | translate }}</span>"
});
var DefaultItemPrinterComponent = /** @class */ (function () {
    function DefaultItemPrinterComponent(data) {
        this.data = data;
    }
    DefaultItemPrinterComponent = __decorate([
        core.Component({
            selector: 'se-default-item-printer',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            styles: [".se-item-printer-text{vertical-align:middle;position:relative;max-width:100%;font-family:\"72\";color:#51555a;display:inline-block}"],
            template: "<span [attr.title]=\"((data.item.label || data.item.name) | seL10n | async) | translate\" class=\"se-item-printer-text se-nowrap-ellipsis\">{{ ((data.item.label || data.item.name) | seL10n | async) | translate }}</span>"
        }),
        __param(0, core.Inject(ITEM_COMPONENT_DATA_TOKEN)),
        __metadata("design:paramtypes", [Object])
    ], DefaultItemPrinterComponent);
    return DefaultItemPrinterComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "SearchInputComponent", {
    selector: 'se-select-search-input',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-select-search-input]': 'true'
    },
    template: "<div class=\"search\"><input #searchInput type=\"search\" class=\"search__input\" [disabled]=\"isDisabled\" [readOnly]=\"isReadOnly\" [placeholder]=\"placeholder\" [ngModel]=\"search\" (ngModelChange)=\"onChange($event)\" (keyup)=\"onKeyup($event)\"/></div>"
});
var SearchInputComponent = /** @class */ (function () {
    function SearchInputComponent(elementRef, sharedDataService) {
        this.elementRef = elementRef;
        this.sharedDataService = sharedDataService;
        this.searchKeyup = new core.EventEmitter();
        this.searchChange = new core.EventEmitter();
    }
    SearchInputComponent.prototype.ngOnInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.sharedDataService.get('configuration')];
                    case 1:
                        _a.configurations = (_b.sent());
                        this.initSearchInputFilter();
                        return [2 /*return*/];
                }
            });
        });
    };
    SearchInputComponent.prototype.ngOnDestroy = function () {
        this.searchTermSubscription.unsubscribe();
    };
    Object.defineProperty(SearchInputComponent.prototype, "nativeElement", {
        get: function () {
            return this.elementRef.nativeElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SearchInputComponent.prototype, "inputElement", {
        get: function () {
            return this.searchInput.nativeElement;
        },
        enumerable: false,
        configurable: true
    });
    SearchInputComponent.prototype.focus = function () {
        this.inputElement.focus();
    };
    SearchInputComponent.prototype.onChange = function (value) {
        this.isTypeAheadEnabled
            ? this.searchTermSubject.next(value)
            : this.searchChange.emit(value);
    };
    SearchInputComponent.prototype.onKeyup = function (event) {
        this.keyUpEvent = event;
        var value = event.target.value;
        this.isTypeAheadEnabled
            ? this.searchTermSubject.next(value)
            : this.searchKeyup.emit({ event: this.keyUpEvent, value: value });
    };
    SearchInputComponent.prototype.initSearchInputFilter = function () {
        var _this = this;
        this.searchTermSubject = new rxjs.Subject();
        this.searchTerm$ = this.searchTermSubject.asObservable().pipe(operators.filter(function (text) {
            return _this.configurations && _this.configurations.typeAheadMiniSearchTermLength
                ? text.length > 0 &&
                    text.length > _this.configurations.typeAheadMiniSearchTermLength
                : true;
        }), operators.debounceTime((this.configurations && this.configurations.typeAheadDebounce) || 500), operators.distinctUntilChanged());
        this.searchTermSubscription = this.searchTerm$.subscribe(function (value) {
            _this.searchKeyup.emit({ event: _this.keyUpEvent, value: value });
            _this.searchChange.emit(value);
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], SearchInputComponent.prototype, "isDisabled", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], SearchInputComponent.prototype, "isReadOnly", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], SearchInputComponent.prototype, "isTypeAheadEnabled", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], SearchInputComponent.prototype, "placeholder", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], SearchInputComponent.prototype, "search", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], SearchInputComponent.prototype, "searchKeyup", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], SearchInputComponent.prototype, "searchChange", void 0);
    __decorate([
        core.ViewChild('searchInput', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], SearchInputComponent.prototype, "searchInput", void 0);
    SearchInputComponent = __decorate([
        core.Component({
            selector: 'se-select-search-input',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-select-search-input]': 'true'
            },
            template: "<div class=\"search\"><input #searchInput type=\"search\" class=\"search__input\" [disabled]=\"isDisabled\" [readOnly]=\"isReadOnly\" [placeholder]=\"placeholder\" [ngModel]=\"search\" (ngModelChange)=\"onChange($event)\" (keyup)=\"onKeyup($event)\"/></div>"
        }),
        __metadata("design:paramtypes", [core.ElementRef, utils.ISharedDataService])
    ], SearchInputComponent);
    return SearchInputComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "SelectComponent", {
    selector: 'se-select',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-select]': 'true'
    },
    template: "<fd-select [style.display]=\"'none'\"></fd-select><div [attr.id]=\"id + '-selector'\" class=\"select-container\" [ngClass]=\"{\n        'has-warning': hasWarning(),\n        'has-error': hasError()\n    }\"><ng-container *ngIf=\"multiSelect; then multi; else singleSelect\"></ng-container><ng-template #singleSelect><fd-popover [triggers]=\"['click']\" [(isOpen)]=\"isOpen\" [placement]=\"'bottom'\" (isOpenChange)=\"onSingleSelectIsOpenChange($event)\"><fd-popover-control><div class=\"selected-container fd-select-custom\" [attr.has-selected-option]=\"!!selected || null\"><button fd-button class=\"fd-select-button-custom toggle-button\" [disabled]=\"isReadOnly\"><span *ngIf=\"!selected; else selectedItem\" class=\"selected-placeholder\">{{ placeholder | translate }}</span><ng-template #selectedItem><div class=\"selected-item\"><span *ngIf=\"controls\" class=\"glyphicon glyphicon-search\"></span><se-item-printer *ngIf=\"selected\" [attr.id]=\"id + '-selected'\" [item]=\"selected\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span *ngIf=\"controls || showRemoveButton\" class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, selected)\"></span></div></ng-template></button></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngIf=\"searchEnabled && isOpen\"><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></ng-container><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #multi><fd-popover class=\"se-multi-select\" [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"'bottom'\"><fd-popover-control><div class=\"selected-container\"><ng-container *ngIf=\"selected && selected.length > 0\"><ol class=\"selected-list\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\"><li *ngFor=\"let item of selected; trackBy: itemTrackBy\" cdkDrag class=\"selected-list__item selected-item\"><se-item-printer [item]=\"item\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, item)\"></span></li></ol></ng-container><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #resultsHeader><se-select-results-header [search]=\"search\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [resultsHeaderLabel]=\"resultsHeaderLabel\" [displayResultsHeaderLabel]=\"showResultsHeaderLabel()\" [actionableSearchItem]=\"actionableSearchItem\" (actionButtonClick)=\"closeAndReset()\"></se-select-results-header></ng-template><ng-template #searchInputTemplate><se-select-search-input [isDisabled]=\"isReadOnly\" [isReadOnly]=\"multiSelect && !searchEnabled\" [isTypeAheadEnabled]=\"!multiSelect\" [placeholder]=\"showPlaceholder() ? (placeholder | translate) : ''\" [search]=\"search\" (searchKeyup)=\"onSearchInputKeyup($event.event, $event.value)\" (searchChange)=\"onSearchInputChange($event)\"></se-select-search-input></ng-template><ng-template #selectListTemplate><se-select-list [id]=\"id\" [isPagedDropdown]=\"isPagedDropdown()\" [fetchPage]=\"fetchStrategy.fetchPage\" [search]=\"search\" [items]=\"items\" [selected]=\"selected\" [excludeSelected]=\"multiSelect\" [disableChoiceFn]=\"disableChoiceFn\" [itemComponent]=\"itemComponent\" [selectComponentCtx]=\"this\" (optionClick)=\"onOptionClick($event)\" (infiniteScrollItemsChange)=\"onInfiniteScrollItemsChange()\"></se-select-list></ng-template></div>"
});
var /* @ngInject */ SelectComponent = /** @class */ (function () {
    SelectComponent.$inject = ["l10nService", "logService", "cdr"];
    function /* @ngInject */ SelectComponent(l10nService, logService, cdr) {
        this.l10nService = l10nService;
        this.logService = logService;
        this.cdr = cdr;
        this.modelChange = new core.EventEmitter();
        this.controls = false;
        this.multiSelect = false;
        this.keepModelOnReset = false;
        this.isReadOnly = false;
        this.searchEnabled = true;
        this.resetSearchInput = true;
        this.showRemoveButton = false;
        this.getApi = new core.EventEmitter();
        this.resetChange = new core.EventEmitter();
        this.isOpen = false;
        this.items = [];
        this.search = '';
        this.api = {
            setValidationState: this.setValidationState.bind(this),
            resetValidationState: this.resetValidationState.bind(this)
        };
    }
    Object.defineProperty(/* @ngInject */ SelectComponent.prototype, "isSingleCss", {
        get: function () {
            return !this.multiSelect;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(/* @ngInject */ SelectComponent.prototype, "isMultiCss", {
        get: function () {
            return this.multiSelect;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(/* @ngInject */ SelectComponent.prototype, "isPagedCss", {
        get: function () {
            return this.isPagedDropdown();
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ SelectComponent.prototype.clickHandler = function (event) {
        if (!this.multiSelect) {
            return;
        }
        if (event.target === this.searchInputCmp.inputElement) {
            event.stopPropagation();
            if (!this.isOpen) {
                this.onMultiSelectIsOpenChange(true);
            }
        }
        else if (this.isOpen) {
            this.onMultiSelectIsOpenChange(false);
        }
    };
    SelectComponent.prototype.clickHandler.$inject = ["event"];
    /* @ngInject */ SelectComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.placeholder) {
            this.placeholder = 'se.genericeditor.sedropdown.placeholder';
        }
        if (this.fetchStrategy.fetchAll) {
            this.initSearchInputFilter();
        }
        this.fetchData();
        setTimeout(function () {
            _this.resetChange.emit(_this.internalReset.bind(_this));
        });
        this.getApi.emit(this.api);
    };
    /* @ngInject */ SelectComponent.prototype.ngOnChanges = function (changes) {
        if (!this.itemComponent) {
            this.itemComponent = DefaultItemPrinterComponent;
        }
        this.isValidConfiguration();
        var modelChange = changes.model;
        var didModelChange = modelChange &&
            modelChange.currentValue !== this.modelChangeOld &&
            !modelChange.firstChange;
        if (didModelChange) {
            if (this.multiSelect) {
                if (this.isModelEmpty()) {
                    this.model = [];
                }
            }
            this.fetchData();
        }
    };
    SelectComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ SelectComponent.prototype.ngOnDestroy = function () {
        if (this.languageSwitchSubscription) {
            this.languageSwitchSubscription.unsubscribe();
        }
        if (this.searchInputChangeSubject) {
            this.searchInputChangeSubject.unsubscribe();
        }
    };
    /* @ngInject */ SelectComponent.prototype.onSingleSelectIsOpenChange = function (isOpen) {
        var _this = this;
        if (isOpen) {
            setTimeout(function () {
                if (_this.searchInputCmp) {
                    _this.searchInputCmp.focus();
                }
                if (_this.fetchStrategy.fetchAll) {
                    _this.refreshOptions(_this.search);
                }
            });
        }
        else {
            this.resetOnClose();
        }
    };
    SelectComponent.prototype.onSingleSelectIsOpenChange.$inject = ["isOpen"];
    /* @ngInject */ SelectComponent.prototype.onSearchInputKeyup = function (event, value) {
        this.internalKeyup(event, value);
    };
    SelectComponent.prototype.onSearchInputKeyup.$inject = ["event", "value"];
    /* @ngInject */ SelectComponent.prototype.onSearchInputChange = function (value) {
        this.onSearchChange(value);
        if (this.searchInputChangeSubject) {
            this.searchInputChangeSubject.next(value);
        }
    };
    SelectComponent.prototype.onSearchInputChange.$inject = ["value"];
    /* @ngInject */ SelectComponent.prototype.onOptionClick = function (item) {
        var selectedHasChanged = false;
        if (this.multiSelect) {
            var selected = __spreadArrays((this.selected || []), [item]);
            this.setSelected(selected);
            selectedHasChanged = true;
        }
        else if (!this.isItemSelected(item)) {
            this.setSelected(item);
            selectedHasChanged = true;
        }
        this.internalOnSelect(item, item.id);
        if (selectedHasChanged) {
            this.internalOnChange();
        }
        this.closeAndReset();
    };
    SelectComponent.prototype.onOptionClick.$inject = ["item"];
    /* @ngInject */ SelectComponent.prototype.onSearchChange = function (value) {
        this.search = value;
    };
    SelectComponent.prototype.onSearchChange.$inject = ["value"];
    /* @ngInject */ SelectComponent.prototype.onDrop = function (event) {
        dragDrop.moveItemInArray(this.selected, event.previousIndex, event.currentIndex);
        this.setSelected(this.selected);
        var orderHasChanged = event.previousIndex !== event.currentIndex;
        if (orderHasChanged) {
            this.internalOnChange();
        }
    };
    SelectComponent.prototype.onDrop.$inject = ["event"];
    /* @ngInject */ SelectComponent.prototype.removeSelectedOption = function (_, item) {
        var selectedNew = this.multiSelect
            ? this.selected.filter(function (selectedItem) { return selectedItem !== item; })
            : undefined;
        this.setSelected(selectedNew);
        this.internalOnRemove(item, item.id);
        if (this.isOpen) {
            this.closeAndReset();
        }
    };
    SelectComponent.prototype.removeSelectedOption.$inject = ["_", "item"];
    /* @ngInject */ SelectComponent.prototype.closeAndReset = function () {
        this.close();
        this.resetOnClose();
    };
    /* @ngInject */ SelectComponent.prototype.showResultsHeaderLabel = function () {
        return this.items.length > 0 && !!this.resultsHeaderLabel;
    };
    /* @ngInject */ SelectComponent.prototype.onInfiniteScrollItemsChange = function () {
    };
    /* @ngInject */ SelectComponent.prototype.showPlaceholder = function () {
        return this.multiSelect || (!this.multiSelect && !!this.selected);
    };
    /* @ngInject */ SelectComponent.prototype.itemTrackBy = function (_, item) {
        return item.id;
    };
    SelectComponent.prototype.itemTrackBy.$inject = ["_", "item"];
    /* @ngInject */ SelectComponent.prototype.setValidationState = function (validationState) {
        this.validationState = validationState;
        this.cdr.detectChanges();
    };
    SelectComponent.prototype.setValidationState.$inject = ["validationState"];
    /* @ngInject */ SelectComponent.prototype.resetValidationState = function () {
        this.validationState = undefined;
        this.cdr.detectChanges();
    };
    /* @ngInject */ SelectComponent.prototype.hasError = function () {
        return VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR === this.validationState;
    };
    /* @ngInject */ SelectComponent.prototype.hasWarning = function () {
        return VALIDATION_MESSAGE_TYPES.WARNING === this.validationState;
    };
    /* @ngInject */ SelectComponent.prototype.fetchEntity = function (modelId) {
        var _this = this;
        return this.fetchStrategy.fetchEntity(modelId).then(function (item) {
            if (!item) {
                _this.logService.debug('fetchEntity was used to fetch the option identified by ' +
                    item +
                    ' but failed to find a match');
            }
            return item;
        });
    };
    SelectComponent.prototype.fetchEntity.$inject = ["modelId"];
    /* @ngInject */ SelectComponent.prototype.updateModelIfNotFoundInItems = function (items) {
        var _this = this;
        if (!this.keepModelOnReset) {
            if (this.multiSelect) {
                if (this.isModelEmpty()) {
                    this.setSelected([], false);
                    return;
                }
                var modelFromNewItems = this.model.filter(function (id) {
                    return _this.getItemByModel(items, id);
                });
                var multiSelectMatch = lodash.isEqual(this.model, modelFromNewItems);
                if (!multiSelectMatch) {
                    this.updateModel(modelFromNewItems);
                    this.resolveAndSetSelected(items);
                }
                else {
                    this.resolveAndSetSelected(items);
                }
                return;
            }
            if (this.isModelEmpty()) {
                this.setSelected(undefined, false);
                return;
            }
            var singleSelectMatch = this.getItemByModel(items);
            if (!singleSelectMatch) {
                this.setSelected(undefined);
            }
            else {
                this.resolveAndSetSelected(items);
            }
        }
    };
    SelectComponent.prototype.updateModelIfNotFoundInItems.$inject = ["items"];
    /* @ngInject */ SelectComponent.prototype.refreshOptions = function (mask) {
        var _this = this;
        this.internalFetchAll(mask).then(function (items) {
            _this.items = items;
            _this.cdr.detectChanges();
        });
    };
    SelectComponent.prototype.refreshOptions.$inject = ["mask"];
    /* @ngInject */ SelectComponent.prototype.isValidConfiguration = function () {
        if (this.resultsHeaderComponent && this.resultsHeaderLabel) {
            throw new Error("Only one of \"resultsHeaderComponent\" or \"resultsHeaderLabel\" must be specified");
        }
        if (!this.fetchStrategy.fetchAll && !this.fetchStrategy.fetchPage) {
            throw new Error('Neither fetchAll nor fetchPage have been specified in fetchStrategy');
        }
        if (this.fetchStrategy.fetchAll && this.fetchStrategy.fetchPage) {
            throw new Error('Only one of either fetchAll or fetchPage must be specified in fetchStrategy');
        }
        if (this.fetchStrategy.fetchPage &&
            this.model &&
            !this.fetchStrategy.fetchEntity &&
            !this.fetchStrategy.fetchEntities) {
            throw new Error("fetchPage has been specified in fetchStrategy but neither fetchEntity nor fetchEntities are available to load item identified by " + this.model);
        }
        if (this.isPagedDropdown() && !this.keepModelOnReset) {
            this.logService.debug('current Select is paged, so keepModelOnReset flag is ignored (it will always keep the model on reset).');
        }
    };
    /* @ngInject */ SelectComponent.prototype.internalKeyup = function (event, search) {
        if (this.keyup) {
            this.keyup(event, search);
        }
    };
    SelectComponent.prototype.internalKeyup.$inject = ["event", "search"];
    /* @ngInject */ SelectComponent.prototype.internalOnRemove = function (item, model) {
        if (this.onRemove) {
            this.onRemove(item, model);
        }
        this.internalOnChange();
    };
    SelectComponent.prototype.internalOnRemove.$inject = ["item", "model"];
    /* @ngInject */ SelectComponent.prototype.internalOnChange = function () {
        if (this.onChange) {
            this.onChange();
        }
    };
    /* @ngInject */ SelectComponent.prototype.internalOnSelect = function (item, model) {
        if (this.onSelect) {
            this.onSelect(item, model);
        }
    };
    SelectComponent.prototype.internalOnSelect.$inject = ["item", "model"];
    /* @ngInject */ SelectComponent.prototype.internalFetchAll = function (mask) {
        var _this = this;
        if (mask === void 0) { mask = ''; }
        return this.fetchStrategy.fetchAll(mask).then(function (items) {
            _this.fetchAllItems = items;
            return __spreadArrays(items);
        });
    };
    SelectComponent.prototype.internalFetchAll.$inject = ["mask"];
    /* @ngInject */ SelectComponent.prototype.internalFetchEntities = function () {
        var _this = this;
        var promise;
        if (!this.multiSelect) {
            promise = this.fetchEntity(this.model).then(function (item) { return [item]; });
        }
        else {
            if (this.fetchStrategy.fetchEntities) {
                promise = this.fetchStrategy.fetchEntities(this.model).then(function (items) {
                    if (items.length !== _this.model.length) {
                        _this.logService.debug("!fetchEntities was used to fetch the options identified by " + JSON.stringify(_this.model) + " but failed to find all matches");
                    }
                    return items;
                });
            }
            else {
                var promiseArray = this.model.map(function (id) { return _this.fetchEntity(id); });
                promise = Promise.all(promiseArray);
            }
        }
        return promise.then(function (result) {
            var items = result
                .filter(function (item) { return item !== null; })
                .map(function (item) {
                delete item.$promise;
                delete item.$resolved;
                item.technicalUniqueId = stringUtils.encode(item);
                return item;
            });
            _this.updateModelIfNotFoundInItems(items);
            _this.internalOnChange();
            _this.cdr.detectChanges();
        });
    };
    /* @ngInject */ SelectComponent.prototype.onMultiSelectIsOpenChange = function (isOpen) {
        this.isOpen = isOpen;
        if (isOpen) {
            if (this.isPagedDropdown()) {
                this.cdr.detectChanges();
                return;
            }
            this.refreshOptions(this.search);
        }
        else {
            this.resetOnClose();
        }
    };
    SelectComponent.prototype.onMultiSelectIsOpenChange.$inject = ["isOpen"];
    /* @ngInject */ SelectComponent.prototype.initSearchInputFilter = function () {
        var _this = this;
        this.searchInputChangeSubject = new rxjs.Subject();
        this.searchInputChange$ = this.searchInputChangeSubject.asObservable();
        this.languageSwitchSubscription = this.l10nService.languageSwitch$.subscribe(function (lang) {
            _this.filterFn = getLocalizedFilterFn(lang);
        });
        this.searchInputChange$
            .pipe(operators.filter(function () { return typeof _this.fetchStrategy.fetchAll !== 'undefined'; }), operators.tap(function (value) {
            _this.items = _this.filterItemsBySearch(_this.fetchAllItems, value);
            _this.cdr.detectChanges();
        }), operators.debounceTime(500), operators.switchMap(function (value) { return _this.internalFetchAll(value); }))
            .subscribe(function (items) {
            _this.items = _this.filterItemsBySearch(items, _this.search);
            _this.cdr.detectChanges();
        });
    };
    /* @ngInject */ SelectComponent.prototype.filterItemsBySearch = function (fetchedItems, search) {
        var _this = this;
        return fetchedItems.filter(function (item) {
            return _this.filterFn(item.label || item.name)
                .trim()
                .toUpperCase()
                .includes(search.trim().toUpperCase());
        });
    };
    SelectComponent.prototype.filterItemsBySearch.$inject = ["fetchedItems", "search"];
    /* @ngInject */ SelectComponent.prototype.close = function () {
        this.isOpen = false;
    };
    /* @ngInject */ SelectComponent.prototype.resetOnClose = function () {
        if (this.search && this.resetSearchInput) {
            this.search = '';
            this.cdr.detectChanges();
            if (this.fetchStrategy.fetchAll) {
                this.refreshOptions(this.search);
            }
        }
    };
    /* @ngInject */ SelectComponent.prototype.fetchData = function () {
        if (!this.isPagedDropdown()) {
            this.internalFetchAllAndCheckModel();
        }
        else if (!this.isModelEmpty()) {
            this.internalFetchEntities();
        }
    };
    /* @ngInject */ SelectComponent.prototype.internalFetchAllAndCheckModel = function () {
        var _this = this;
        return this.internalFetchAll().then(function (items) {
            _this.updateModelIfNotFoundInItems(items);
            _this.internalOnChange();
            _this.cdr.detectChanges();
        });
    };
    /* @ngInject */ SelectComponent.prototype.getItemByModel = function (items, model) {
        if (model === void 0) { model = this.model; }
        return items.find(function (item) { return item.id === model; });
    };
    SelectComponent.prototype.getItemByModel.$inject = ["items", "model"];
    /* @ngInject */ SelectComponent.prototype.getItemsByModel = function (items, model) {
        var _this = this;
        if (model === void 0) { model = this.model; }
        return model.map(function (id) { return _this.getItemByModel(items, id); }).filter(function (item) { return !!item; });
    };
    SelectComponent.prototype.getItemsByModel.$inject = ["items", "model"];
    /* @ngInject */ SelectComponent.prototype.mapSelectedToModel = function () {
        return this.multiSelect
            ? this.selected.map(function (item) { return item.id; })
            : this.selected.id;
    };
    /* @ngInject */ SelectComponent.prototype.setSelected = function (items, updateModel) {
        if (updateModel === void 0) { updateModel = true; }
        this.selected = items;
        if (updateModel) {
            var model = void 0;
            if (this.selected) {
                model = this.mapSelectedToModel();
            }
            this.updateModel(model);
        }
    };
    SelectComponent.prototype.setSelected.$inject = ["items", "updateModel"];
    /* @ngInject */ SelectComponent.prototype.isItemSelected = function (item) {
        if (!this.selected) {
            return false;
        }
        return item.id === this.selected.id;
    };
    SelectComponent.prototype.isItemSelected.$inject = ["item"];
    /* @ngInject */ SelectComponent.prototype.internalReset = function (forceReset) {
        if (forceReset === void 0) { forceReset = false; }
        this.items.length = 0;
        if (forceReset) {
            this.selected = undefined;
            this.resetModel();
            return;
        }
        if (!this.keepModelOnReset) {
            this.fetchData();
        }
    };
    SelectComponent.prototype.internalReset.$inject = ["forceReset"];
    /* @ngInject */ SelectComponent.prototype.resetModel = function () {
        var model = this.multiSelect ? [] : undefined;
        this.updateModel(model);
    };
    /* @ngInject */ SelectComponent.prototype.updateModel = function (model) {
        this.model = model;
        this.modelChangeOld = this.model;
        this.modelChange.emit(model);
    };
    SelectComponent.prototype.updateModel.$inject = ["model"];
    /* @ngInject */ SelectComponent.prototype.isPagedDropdown = function () {
        return !!this.fetchStrategy.fetchPage;
    };
    /* @ngInject */ SelectComponent.prototype.isModelEmpty = function () {
        if (this.multiSelect) {
            return !this.model || (this.model && this.model.length === 0);
        }
        else {
            return !this.model;
        }
    };
    /* @ngInject */ SelectComponent.prototype.resolveAndSetSelected = function (items) {
        var selected = this.multiSelect
            ? this.getItemsByModel(items)
            : this.getItemByModel(items);
        this.setSelected(selected, false);
    };
    SelectComponent.prototype.resolveAndSetSelected.$inject = ["items"];
    __decorate([
        core.HostBinding('class.se-select--single'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], /* @ngInject */ SelectComponent.prototype, "isSingleCss", null);
    __decorate([
        core.HostBinding('class.se-select--multi'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], /* @ngInject */ SelectComponent.prototype, "isMultiCss", null);
    __decorate([
        core.HostBinding('class.se-select--paged'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], /* @ngInject */ SelectComponent.prototype, "isPagedCss", null);
    __decorate([
        core.Input(),
        core.HostBinding('attr.id'),
        __metadata("design:type", String)
    ], /* @ngInject */ SelectComponent.prototype, "id", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "model", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "modelChange", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "fetchStrategy", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "controls", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "multiSelect", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "keepModelOnReset", void 0);
    __decorate([
        core.Input(),
        core.HostBinding('class.is-disabled'),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "isReadOnly", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "actionableSearchItem", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ SelectComponent.prototype, "resultsHeaderComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ SelectComponent.prototype, "resultsHeaderLabel", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "disableChoiceFn", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ SelectComponent.prototype, "placeholder", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ SelectComponent.prototype, "itemComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "searchEnabled", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "resetSearchInput", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "onChange", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "onRemove", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "onSelect", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "keyup", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "showRemoveButton", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "getApi", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SelectComponent.prototype, "reset", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SelectComponent.prototype, "resetChange", void 0);
    __decorate([
        core.ViewChild(SearchInputComponent, { static: false }),
        __metadata("design:type", SearchInputComponent)
    ], /* @ngInject */ SelectComponent.prototype, "searchInputCmp", void 0);
    __decorate([
        core.HostListener('document:click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [MouseEvent]),
        __metadata("design:returntype", void 0)
    ], /* @ngInject */ SelectComponent.prototype, "clickHandler", null);
    /* @ngInject */ SelectComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-select',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-select]': 'true'
            },
            template: "<fd-select [style.display]=\"'none'\"></fd-select><div [attr.id]=\"id + '-selector'\" class=\"select-container\" [ngClass]=\"{\n        'has-warning': hasWarning(),\n        'has-error': hasError()\n    }\"><ng-container *ngIf=\"multiSelect; then multi; else singleSelect\"></ng-container><ng-template #singleSelect><fd-popover [triggers]=\"['click']\" [(isOpen)]=\"isOpen\" [placement]=\"'bottom'\" (isOpenChange)=\"onSingleSelectIsOpenChange($event)\"><fd-popover-control><div class=\"selected-container fd-select-custom\" [attr.has-selected-option]=\"!!selected || null\"><button fd-button class=\"fd-select-button-custom toggle-button\" [disabled]=\"isReadOnly\"><span *ngIf=\"!selected; else selectedItem\" class=\"selected-placeholder\">{{ placeholder | translate }}</span><ng-template #selectedItem><div class=\"selected-item\"><span *ngIf=\"controls\" class=\"glyphicon glyphicon-search\"></span><se-item-printer *ngIf=\"selected\" [attr.id]=\"id + '-selected'\" [item]=\"selected\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span *ngIf=\"controls || showRemoveButton\" class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, selected)\"></span></div></ng-template></button></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngIf=\"searchEnabled && isOpen\"><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></ng-container><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #multi><fd-popover class=\"se-multi-select\" [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"'bottom'\"><fd-popover-control><div class=\"selected-container\"><ng-container *ngIf=\"selected && selected.length > 0\"><ol class=\"selected-list\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\"><li *ngFor=\"let item of selected; trackBy: itemTrackBy\" cdkDrag class=\"selected-list__item selected-item\"><se-item-printer [item]=\"item\" [component]=\"itemComponent\" [selectComponentCtx]=\"this\"></se-item-printer><span class=\"sap-icon--sys-cancel selected-item__remove-button\" (click)=\"removeSelectedOption($event, item)\"></span></li></ol></ng-container><ng-container *ngTemplateOutlet=\"searchInputTemplate\"></ng-container></div></fd-popover-control><fd-popover-body><fd-menu class=\"se-select-list-container\"><ng-container *ngTemplateOutlet=\"resultsHeader\"></ng-container><ng-container *ngIf=\"isOpen\"><ng-container *ngTemplateOutlet=\"selectListTemplate\"></ng-container></ng-container></fd-menu></fd-popover-body></fd-popover></ng-template><ng-template #resultsHeader><se-select-results-header [search]=\"search\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [resultsHeaderLabel]=\"resultsHeaderLabel\" [displayResultsHeaderLabel]=\"showResultsHeaderLabel()\" [actionableSearchItem]=\"actionableSearchItem\" (actionButtonClick)=\"closeAndReset()\"></se-select-results-header></ng-template><ng-template #searchInputTemplate><se-select-search-input [isDisabled]=\"isReadOnly\" [isReadOnly]=\"multiSelect && !searchEnabled\" [isTypeAheadEnabled]=\"!multiSelect\" [placeholder]=\"showPlaceholder() ? (placeholder | translate) : ''\" [search]=\"search\" (searchKeyup)=\"onSearchInputKeyup($event.event, $event.value)\" (searchChange)=\"onSearchInputChange($event)\"></se-select-search-input></ng-template><ng-template #selectListTemplate><se-select-list [id]=\"id\" [isPagedDropdown]=\"isPagedDropdown()\" [fetchPage]=\"fetchStrategy.fetchPage\" [search]=\"search\" [items]=\"items\" [selected]=\"selected\" [excludeSelected]=\"multiSelect\" [disableChoiceFn]=\"disableChoiceFn\" [itemComponent]=\"itemComponent\" [selectComponentCtx]=\"this\" (optionClick)=\"onOptionClick($event)\" (infiniteScrollItemsChange)=\"onInfiniteScrollItemsChange()\"></se-select-list></ng-template></div>"
        }),
        __metadata("design:paramtypes", [L10nService,
            utils.LogService,
            core.ChangeDetectorRef])
    ], /* @ngInject */ SelectComponent);
    return /* @ngInject */ SelectComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "ItemPrinterComponent", {
    selector: 'se-item-printer',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-item-printer]': 'true'
    },
    template: "<ng-container *ngComponentOutlet=\"component; injector: componentInjector\"></ng-container>"
});
var ItemPrinterComponent = /** @class */ (function () {
    function ItemPrinterComponent(injector) {
        this.injector = injector;
        this.isSelected = true;
    }
    ItemPrinterComponent.prototype.ngOnChanges = function (changes) {
        if (changes.item) {
            this.itemComponentData = this.createItemComponentData();
            if (this.component) {
                this.componentInjector = this.createItemComponentInjector();
            }
        }
    };
    ItemPrinterComponent.prototype.createItemComponentData = function () {
        return {
            item: this.item,
            selected: this.isSelected,
            select: this.selectComponentCtx
        };
    };
    ItemPrinterComponent.prototype.createItemComponentInjector = function () {
        return core.Injector.create({
            parent: this.injector,
            providers: [
                {
                    provide: ITEM_COMPONENT_DATA_TOKEN,
                    useValue: this.itemComponentData
                }
            ]
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ItemPrinterComponent.prototype, "item", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], ItemPrinterComponent.prototype, "component", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", SelectComponent)
    ], ItemPrinterComponent.prototype, "selectComponentCtx", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ItemPrinterComponent.prototype, "isSelected", void 0);
    ItemPrinterComponent = __decorate([
        core.Component({
            selector: 'se-item-printer',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-item-printer]': 'true'
            },
            template: "<ng-container *ngComponentOutlet=\"component; injector: componentInjector\"></ng-container>"
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], ItemPrinterComponent);
    return ItemPrinterComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "ResultsHeaderComponent", {
    selector: 'se-select-results-header',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-select-results-header]': 'true'
    },
    template: "<div *ngIf=\"showResultsHeaderItem() || resultsHeaderLabel || actionableSearchItem\" class=\"results-header\"><div *ngIf=\"showResultsHeaderItem()\"><ng-container *ngComponentOutlet=\"resultsHeaderComponent\"></ng-container></div><se-actionable-search-item *ngIf=\"actionableSearchItem\" [search]=\"search\" [eventId]=\"actionableSearchItem.eventId\" [actionText]=\"actionableSearchItem.actionText\" (actionButtonClick)=\"onActionButtonClick()\"></se-actionable-search-item><li class=\"fd-menu__list-header\" *ngIf=\"displayResultsHeaderLabel\">{{ resultsHeaderLabel | translate }}</li></div>"
});
var ResultsHeaderComponent = /** @class */ (function () {
    function ResultsHeaderComponent() {
        this.actionButtonClick = new core.EventEmitter();
    }
    ResultsHeaderComponent.prototype.onActionButtonClick = function () {
        this.actionButtonClick.emit();
    };
    ResultsHeaderComponent.prototype.showResultsHeaderItem = function () {
        return typeof this.resultsHeaderComponent !== 'undefined';
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], ResultsHeaderComponent.prototype, "search", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], ResultsHeaderComponent.prototype, "resultsHeaderComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], ResultsHeaderComponent.prototype, "resultsHeaderLabel", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], ResultsHeaderComponent.prototype, "displayResultsHeaderLabel", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], ResultsHeaderComponent.prototype, "actionableSearchItem", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], ResultsHeaderComponent.prototype, "actionButtonClick", void 0);
    ResultsHeaderComponent = __decorate([
        core.Component({
            selector: 'se-select-results-header',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-select-results-header]': 'true'
            },
            template: "<div *ngIf=\"showResultsHeaderItem() || resultsHeaderLabel || actionableSearchItem\" class=\"results-header\"><div *ngIf=\"showResultsHeaderItem()\"><ng-container *ngComponentOutlet=\"resultsHeaderComponent\"></ng-container></div><se-actionable-search-item *ngIf=\"actionableSearchItem\" [search]=\"search\" [eventId]=\"actionableSearchItem.eventId\" [actionText]=\"actionableSearchItem.actionText\" (actionButtonClick)=\"onActionButtonClick()\"></se-actionable-search-item><li class=\"fd-menu__list-header\" *ngIf=\"displayResultsHeaderLabel\">{{ resultsHeaderLabel | translate }}</li></div>"
        })
    ], ResultsHeaderComponent);
    return ResultsHeaderComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "SelectListComponent", {
    selector: 'se-select-list',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    host: {
        '[class.se-select-list]': 'true'
    },
    template: "<se-infinite-scrolling *ngIf=\"isPagedDropdown; else selectList\" [pageSize]=\"infiniteScrollingPageSize\" [mask]=\"search\" [fetchPage]=\"fetchPage\" [context]=\"selectComponentCtx\" (itemsChange)=\"onInfiniteScrollItemsChange()\"><ng-container *ngTemplateOutlet=\"selectList\"></ng-container></se-infinite-scrolling><ng-template #selectList><ol [attr.id]=\"id +'-list'\" fd-menu-list suListKeyboardControl [suListKeyboardControlDisabledPredicate]=\"keyboardControlDisabledPredicate\" (suListKeyboardControlEnterKeydown)=\"onEnterKeydown($event)\" [ngClass]=\"{ 'fd-menu__list--basic': !isPagedDropdown }\"><ng-container *ngFor=\"let item of items; trackBy: itemTrackBy\"><li *ngIf=\"(excludeSelected && !isItemSelected(item)) || !excludeSelected\" suListItemKeyboardControl class=\"se-select-list__item\" [ngClass]=\"{'is-selected': (!excludeSelected && isItemSelected(item)), 'is-disabled': isItemDisabled(item)}\"><fd-option (click)=\"onOptionClick($event, item)\" class=\"menu-option\"><se-item-printer [item]=\"item\" [isSelected]=\"false\" [component]=\"itemComponent\" [selectComponentCtx]=\"selectComponentCtx\"></se-item-printer></fd-option></li></ng-container></ol></ng-template>"
});
var SelectListComponent = /** @class */ (function () {
    function SelectListComponent() {
        this.isPagedDropdown = false;
        this.excludeSelected = false;
        this.optionClick = new core.EventEmitter();
        this.infiniteScrollItemsChange = new core.EventEmitter();
        this.infiniteScrollingPageSize = 10;
    }
    SelectListComponent.prototype.keyboardControlDisabledPredicate = function (item) {
        return item.getElement().classList.contains('is-disabled');
    };
    SelectListComponent.prototype.itemTrackBy = function (_, item) {
        return item.id;
    };
    SelectListComponent.prototype.isItemSelected = function (item) {
        var isMultiSelect = Array.isArray(this.selected);
        if (!this.selected || (isMultiSelect && this.selected.length === 0)) {
            return false;
        }
        return isMultiSelect
            ? !!this.selected.find(function (selectedItem) { return selectedItem.id === item.id; })
            : item.id === this.selected.id;
    };
    SelectListComponent.prototype.onOptionClick = function (event, item) {
        if (this.isItemDisabled(item)) {
            event.stopPropagation();
            return;
        }
        this.optionClick.emit(item);
    };
    SelectListComponent.prototype.onEnterKeydown = function (itemIndex) {
        var items = this.getItems();
        var item = items[itemIndex];
        this.optionClick.emit(item);
    };
    SelectListComponent.prototype.isItemDisabled = function (item) {
        return this.disableChoiceFn ? this.disableChoiceFn(item) : false;
    };
    SelectListComponent.prototype.onInfiniteScrollItemsChange = function () {
        this.infiniteScrollItemsChange.emit();
    };
    SelectListComponent.prototype.getItems = function () {
        var _this = this;
        if (this.excludeSelected) {
            return this.items.filter(function (item) { return !_this.isItemSelected(item); });
        }
        else {
            return this.items;
        }
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], SelectListComponent.prototype, "id", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], SelectListComponent.prototype, "isPagedDropdown", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], SelectListComponent.prototype, "fetchPage", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], SelectListComponent.prototype, "search", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], SelectListComponent.prototype, "items", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], SelectListComponent.prototype, "selected", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], SelectListComponent.prototype, "excludeSelected", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], SelectListComponent.prototype, "disableChoiceFn", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], SelectListComponent.prototype, "itemComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", SelectComponent)
    ], SelectListComponent.prototype, "selectComponentCtx", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], SelectListComponent.prototype, "optionClick", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], SelectListComponent.prototype, "infiniteScrollItemsChange", void 0);
    SelectListComponent = __decorate([
        core.Component({
            selector: 'se-select-list',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            host: {
                '[class.se-select-list]': 'true'
            },
            template: "<se-infinite-scrolling *ngIf=\"isPagedDropdown; else selectList\" [pageSize]=\"infiniteScrollingPageSize\" [mask]=\"search\" [fetchPage]=\"fetchPage\" [context]=\"selectComponentCtx\" (itemsChange)=\"onInfiniteScrollItemsChange()\"><ng-container *ngTemplateOutlet=\"selectList\"></ng-container></se-infinite-scrolling><ng-template #selectList><ol [attr.id]=\"id +'-list'\" fd-menu-list suListKeyboardControl [suListKeyboardControlDisabledPredicate]=\"keyboardControlDisabledPredicate\" (suListKeyboardControlEnterKeydown)=\"onEnterKeydown($event)\" [ngClass]=\"{ 'fd-menu__list--basic': !isPagedDropdown }\"><ng-container *ngFor=\"let item of items; trackBy: itemTrackBy\"><li *ngIf=\"(excludeSelected && !isItemSelected(item)) || !excludeSelected\" suListItemKeyboardControl class=\"se-select-list__item\" [ngClass]=\"{'is-selected': (!excludeSelected && isItemSelected(item)), 'is-disabled': isItemDisabled(item)}\"><fd-option (click)=\"onOptionClick($event, item)\" class=\"menu-option\"><se-item-printer [item]=\"item\" [isSelected]=\"false\" [component]=\"itemComponent\" [selectComponentCtx]=\"selectComponentCtx\"></se-item-printer></fd-option></li></ng-container></ol></ng-template>"
        })
    ], SelectListComponent);
    return SelectListComponent;
}());

var SelectModule = /** @class */ (function () {
    function SelectModule() {
    }
    SelectModule = __decorate([
        core.NgModule({
            imports: [
                common.CommonModule,
                forms.FormsModule,
                dragDrop.DragDropModule,
                core$2.PopoverModule,
                core$2.ButtonModule,
                core$2.MenuModule,
                core$2.SelectModule,
                core$2.FormModule,
                InfiniteScrollingModule,
                CompileHtmlModule,
                L10nPipeModule,
                utils.ListKeyboardControlModule,
                utils.TranslationModule.forChild()
            ],
            declarations: [
                SelectComponent,
                DefaultItemPrinterComponent,
                ItemPrinterComponent,
                ActionableSearchItemComponent,
                SelectListComponent,
                SearchInputComponent,
                ResultsHeaderComponent
            ],
            entryComponents: [
                SelectComponent,
                DefaultItemPrinterComponent,
                ItemPrinterComponent,
                ActionableSearchItemComponent,
                SelectListComponent,
                SearchInputComponent,
                ResultsHeaderComponent
            ],
            exports: [SelectComponent]
        })
    ], SelectModule);
    return SelectModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var LINKED_DROPDOWN_TOKEN = new core.InjectionToken(LINKED_DROPDOWN);
var DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN = new core.InjectionToken('DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN');
var CLICK_DROPDOWN_TOKEN = new core.InjectionToken(CLICK_DROPDOWN);
/**
 * @internal
 * @ignore
 */
var IGenericEditorDropdownServiceConstructor = /** @class */ (function () {
    function IGenericEditorDropdownServiceConstructor(conf) {
        //
    }
    return IGenericEditorDropdownServiceConstructor;
}());

function genericEditorDropdownComponentOnInit() {
    this.field.params = this.field.params || {};
    this.field.params.catalogId = this.field.params.catalogId || CONTEXT_CATALOG;
    this.field.params.catalogVersion = this.field.params.catalogVersion || CONTEXT_CATALOG_VERSION;
    var dropdownServiceConstructor = this.GenericEditorDropdownService || this.SEDropdownService;
    this.dropdown = new dropdownServiceConstructor({
        field: this.field,
        qualifier: this.qualifier,
        model: this.model,
        id: this.id,
        onClickOtherDropdown: this.onClickOtherDropdown.bind(this),
        getApi: this.getApi
    });
    this.dropdown.init();
}
window.__smartedit__.addDecoratorPayload("Component", "GenericEditorDropdownComponent", {
    selector: 'se-generic-editor-dropdown',
    host: {
        '[class.se-generic-editor-dropdown]': 'true'
    },
    template: "<se-select *ngIf=\"dropdown.initialized\" [id]=\"dropdown.qualifier\" (click)=\"dropdown.onClick()\" [placeholder]=\"field.placeholder\" [(model)]=\"model[qualifier]\" [onChange]=\"dropdown.triggerAction\" [fetchStrategy]=\"dropdown.fetchStrategy\" [(reset)]=\"dropdown.reset\" [multiSelect]=\"dropdown.isMultiDropdown\" [controls]=\"dropdown.isMultiDropdown\" [showRemoveButton]=\"showRemoveButton\" [isReadOnly]=\"!field.editable\" [itemComponent]=\"itemComponent\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [actionableSearchItem]=\"actionableSearchItem\" (getApi)=\"dropdown.setSelectAPI($event)\" (resetChange)=\"onResetChange($event)\"></se-select>"
});
var /* @ngInject */ GenericEditorDropdownComponent = /** @class */ (function () {
    GenericEditorDropdownComponent.$inject = ["GenericEditorDropdownService"];
    function /* @ngInject */ GenericEditorDropdownComponent(GenericEditorDropdownService) {
        this.GenericEditorDropdownService = GenericEditorDropdownService;
        this.resetChange = new core.EventEmitter();
    }
    /* @ngInject */ GenericEditorDropdownComponent.prototype.ngOnInit = function () {
        genericEditorDropdownComponentOnInit.call(this);
    };
    /* @ngInject */ GenericEditorDropdownComponent.prototype.onClickOtherDropdown = function () {
        this.selectComponent.closeAndReset();
    };
    /* @ngInject */ GenericEditorDropdownComponent.prototype.onResetChange = function (reset) {
        this.resetChange.emit(reset);
    };
    GenericEditorDropdownComponent.prototype.onResetChange.$inject = ["reset"];
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "id", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "field", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "qualifier", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "model", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "showRemoveButton", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "itemComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "resultsHeaderComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "actionableSearchItem", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "reset", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "resetChange", void 0);
    __decorate([
        core.ViewChild(SelectComponent, { static: false }),
        __metadata("design:type", SelectComponent)
    ], /* @ngInject */ GenericEditorDropdownComponent.prototype, "selectComponent", void 0);
    /* @ngInject */ GenericEditorDropdownComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-generic-editor-dropdown',
            host: {
                '[class.se-generic-editor-dropdown]': 'true'
            },
            template: "<se-select *ngIf=\"dropdown.initialized\" [id]=\"dropdown.qualifier\" (click)=\"dropdown.onClick()\" [placeholder]=\"field.placeholder\" [(model)]=\"model[qualifier]\" [onChange]=\"dropdown.triggerAction\" [fetchStrategy]=\"dropdown.fetchStrategy\" [(reset)]=\"dropdown.reset\" [multiSelect]=\"dropdown.isMultiDropdown\" [controls]=\"dropdown.isMultiDropdown\" [showRemoveButton]=\"showRemoveButton\" [isReadOnly]=\"!field.editable\" [itemComponent]=\"itemComponent\" [resultsHeaderComponent]=\"resultsHeaderComponent\" [actionableSearchItem]=\"actionableSearchItem\" (getApi)=\"dropdown.setSelectAPI($event)\" (resetChange)=\"onResetChange($event)\"></se-select>"
        }),
        __metadata("design:paramtypes", [IGenericEditorDropdownServiceConstructor])
    ], /* @ngInject */ GenericEditorDropdownComponent);
    return /* @ngInject */ GenericEditorDropdownComponent;
}());

/**
 * The SEDropdownService handles the initialization and the rendering of the {@link SeDropdownComponent}.
 *
 * Resolves Custom Dropdown Populators in two ways:
 * - Angular - `CustomDropdownPopulatorsToken` Injection Token
 * - AngularJS - `$injector`
 */
var GenericEditorDropdownServiceFactory = function (lazyDependenciesService, logService, LINKED_DROPDOWN, CLICK_DROPDOWN, DROPDOWN_IMPLEMENTATION_SUFFIX, systemEventService, optionsDropdownPopulator, uriDropdownPopulator, customDropdownPopulators) {
    var $injector = lazyDependenciesService.$injector();
    return /** @class */ (function () {
        function class_1(conf) {
            var _this = this;
            this.field = conf.field;
            this.qualifier = conf.qualifier;
            this.model = conf.model;
            this.id = conf.id;
            this.onClickOtherDropdown = conf.onClickOtherDropdown;
            this.items = [];
            this.getApi = conf.getApi;
            /** Called when <se-dropdown> is initialized. */
            this.setYSelectAPI = function ($api) {
                _this.ySelectAPI = $api;
            };
            /** Called when <se-generic-editor-dropdown> is initialized. */
            this.setSelectAPI = function (api) {
                _this.selectAPI = api;
            };
            /**
             * **Deprecated since 2105.**
             *
             * The ySelector's API object exposing public functionality.
             *
             */
            this.$api = {
                /**
                 * A method that sets the URL of the template used to display results the dropdown.
                 *
                 * @param resultHeadersTemplateUrl The URL of the template used to display the dropdown result headers section.
                 */
                setResultsHeaderTemplateUrl: function (resultsHeaderTemplateUrl) {
                    _this.resultsHeaderTemplateUrl = resultsHeaderTemplateUrl;
                },
                /**
                 * A method that sets the template used to display results the dropdown.
                 *
                 * @param resultsHeaderTemplate The template used to display the dropdown result headers section.
                 */
                setResultsHeaderTemplate: function (resultsHeaderTemplate) {
                    _this.resultsHeaderTemplate = resultsHeaderTemplate;
                }
            };
        }
        /**
         * Initializes the GenericEditorDropdownComponent with a Dropdown Populator instance,
         * based on the "field" attribute given in constructor.
         */
        class_1.prototype.init = function () {
            this.initializeAngularJSAPI();
            this._setPopulatorName();
            this.isMultiDropdown = this.field.collection ? this.field.collection : false;
            this.triggerAction = this.triggerAction.bind(this);
            this.eventId = (this.id || '') + LINKED_DROPDOWN;
            this.clickEventKey = (this.id || '') + CLICK_DROPDOWN;
            if (this.field.dependsOn) {
                systemEventService.subscribe(this.eventId, this._respondToChange.bind(this));
            }
            systemEventService.subscribe(this.clickEventKey, this._respondToOtherClicks.bind(this));
            var populator = this._resolvePopulator();
            if (!populator) {
                throw new Error('se.dropdown.no.populator.found');
            }
            (this.populator = populator.instance, this.isPaged = populator.isPaged);
            this.fetchStrategy = {
                fetchEntity: this.fetchEntity.bind(this)
            };
            if (this.isPaged) {
                this.fetchStrategy.fetchPage = this.fetchPage.bind(this);
            }
            else {
                this.fetchStrategy.fetchAll = this.fetchAll.bind(this);
            }
            this.initialized = true;
        };
        /**
         * **Deprecated since 2105.**
         *
         * @deprecated
         */
        class_1.prototype.initializeAngularJSAPI = function () {
            if (typeof this.getApi === 'function') {
                this.getApi({
                    $api: this.$api
                });
            }
        };
        /**
         * Publishes an asynchronous event for the currently selected option.
         */
        class_1.prototype.triggerAction = function () {
            var _this = this;
            var selectedObj = this.items.filter(function (option) { return option.id === _this.model[_this.qualifier]; })[0];
            var handle = {
                qualifier: this.qualifier,
                optionObject: selectedObj
            };
            this._setValidationState(this.getState(this.field));
            systemEventService.publishAsync(this.eventId, handle);
        };
        class_1.prototype.onClick = function () {
            systemEventService.publishAsync(this.clickEventKey, this.field.qualifier);
        };
        /**
         * Uses the configured implementation of {@link DropdownPopulatorInterface}
         * to populate the GenericEditorDropdownComponent items using [fetchAll]{@link DropdownPopulatorInterface#fetchAll}
         *
         * @returns A promise that resolves to a list of options to be populated.
         */
        class_1.prototype.fetchAll = function (search) {
            var _this = this;
            return this.populator
                .fetchAll({
                field: this.field,
                model: this.model,
                selection: this.selection,
                search: search
            })
                .then(function (options) {
                _this.items = options;
                return _this.items;
            });
        };
        /**
         * Uses the configured implementation of {@link DropdownPopulatorInterface}
         * to populate a single item [getItem]{@link DropdownPopulatorInterface#getItem}
         *
         * @returns A promise that resolves to the option that was fetched
         */
        class_1.prototype.fetchEntity = function (id) {
            return this.populator.getItem({
                field: this.field,
                id: id,
                model: this.model
            });
        };
        /**
         * @param search The search to filter options by
         * @param pageSize The number of items to be returned
         * @param currentPage The page to be returned
         *
         * Uses the configured implementation of {@link DropdownPopulatorInterface}
         * to populate the seDropdown items using [fetchPage]{@link DropdownPopulatorInterface#fetchPage}
         *
         * @returns A promise that resolves to an object containing the array of items and paging information
         */
        class_1.prototype.fetchPage = function (search, pageSize, currentPage) {
            var _this = this;
            return this.populator
                .fetchPage({
                field: this.field,
                model: this.model,
                selection: this.selection,
                search: search,
                pageSize: pageSize,
                currentPage: currentPage
            })
                .then(function (page) {
                var holderProperty = apiUtils.getKeyHoldingDataFromResponse(page);
                page.results = page[holderProperty];
                delete page[holderProperty];
                _this.items = __spreadArrays(_this.items, page.results);
                return page;
            })
                .catch(function (error) {
                logService.error("Failed to fetch items and paging information. " + error);
            });
        };
        class_1.prototype.getState = function (field) {
            return field.hasErrors
                ? VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR
                : field.hasWarnings
                    ? VALIDATION_MESSAGE_TYPES.WARNING
                    : undefined;
        };
        class_1.prototype.isPopulatorPaged = function (populator) {
            return populator.isPaged && populator.isPaged();
        };
        class_1.prototype._setPopulatorName = function () {
            this.populatorName = {
                options: optionsDropdownPopulator.constructor.name,
                uri: uriDropdownPopulator.constructor.name,
                propertyType: this.field.propertyType + DROPDOWN_IMPLEMENTATION_SUFFIX,
                cmsStructureType: this.field.cmsStructureType + DROPDOWN_IMPLEMENTATION_SUFFIX,
                smarteditComponentType: {
                    withQualifier: this.field.smarteditComponentType +
                        this.field.qualifier +
                        DROPDOWN_IMPLEMENTATION_SUFFIX,
                    withQualifierForDowngradedService: lodash.camelCase(this.field.smarteditComponentType +
                        this.field.qualifier +
                        DROPDOWN_IMPLEMENTATION_SUFFIX),
                    withoutQualifier: this.field.smarteditComponentType + DROPDOWN_IMPLEMENTATION_SUFFIX
                }
            };
        };
        /**
         * Sets Select Component validation state.
         */
        class_1.prototype._setValidationState = function (state) {
            var api = this.ySelectAPI || this.selectAPI; // <y-select> or <se-select>
            if (api) {
                api.setValidationState(state);
            }
        };
        class_1.prototype._respondToChange = function (_key, handle) {
            if (this.field.dependsOn &&
                this.field.dependsOn.split(',').indexOf(handle.qualifier) > -1) {
                this.selection = handle.optionObject;
                if (this.reset) {
                    this.reset();
                }
            }
        };
        /** Responds to other dropdowns clicks */
        class_1.prototype._respondToOtherClicks = function (key, qualifier) {
            if (this.field.qualifier !== qualifier &&
                typeof this.onClickOtherDropdown === 'function') {
                this.onClickOtherDropdown(key, qualifier);
            }
        };
        class_1.prototype._resolvePopulator = function () {
            if (this.field.options && this.field.uri) {
                throw new Error('se.dropdown.contains.both.uri.and.options');
            }
            // OptionsDropdownPopulator
            // e.g. EditableDropdown
            if (this.field.options) {
                return {
                    instance: this._resolvePopulatorByName(this.populatorName.options),
                    isPaged: false
                };
            }
            // UriDropdownPopulator
            if (this.field.uri) {
                return {
                    instance: this._resolvePopulatorByName(this.populatorName.uri),
                    isPaged: this._isFieldPaged(this.field)
                };
            }
            // e.g. productDropdownPopulator, categoryDropdownPopulator
            if (this.field.propertyType) {
                var populator = this._resolvePopulatorByName(this.populatorName.propertyType);
                return {
                    instance: populator,
                    isPaged: this.isPopulatorPaged(populator)
                };
            }
            // e.g. CMSItemDropdownDropdownPopulator
            var cmsStructureTypePopulator = this._resolvePopulatorByName(this.populatorName.cmsStructureType);
            if (cmsStructureTypePopulator) {
                return {
                    instance: cmsStructureTypePopulator,
                    isPaged: this._isFieldPaged(this.field)
                };
            }
            // For downstream teams
            // e.g. SmarteditComponentType + qualifier + DropdownPopulator
            var smarteditComponentTypeWithQualifierPopulator = this._resolvePopulatorByName(this.populatorName.smarteditComponentType.withQualifier);
            if (smarteditComponentTypeWithQualifierPopulator) {
                return {
                    instance: smarteditComponentTypeWithQualifierPopulator,
                    isPaged: this.isPopulatorPaged(smarteditComponentTypeWithQualifierPopulator)
                };
            }
            // For downstream teams
            // TODO: PreviewDatapreviewCatalogDropdownPopulator provide with the token
            // e.g. smarteditComponentType + qualifier + DropdownPopulator
            var smarteditComponentTypeWithQualifierForDowngradedServicePopulator = this._resolvePopulatorByName(this.populatorName.smarteditComponentType.withQualifierForDowngradedService);
            if (smarteditComponentTypeWithQualifierForDowngradedServicePopulator) {
                return {
                    instance: smarteditComponentTypeWithQualifierForDowngradedServicePopulator,
                    isPaged: this.isPopulatorPaged(smarteditComponentTypeWithQualifierForDowngradedServicePopulator)
                };
            }
            // For downstream teams
            // e.g. SmarteditComponentType + DropdownPopulator
            var smarteditComponentTypeWithoutQualifierPopulator = this._resolvePopulatorByName(this.populatorName.smarteditComponentType.withoutQualifier);
            if (smarteditComponentTypeWithoutQualifierPopulator) {
                return {
                    instance: smarteditComponentTypeWithoutQualifierPopulator,
                    isPaged: this.isPopulatorPaged(smarteditComponentTypeWithoutQualifierPopulator)
                };
            }
            return undefined;
        };
        /**
         * Lookup for Populator with given name and returns its instance.
         *
         * It first looks for the service in AngularJS $injector,
         * if not found then it will look for Angular service in `customDropdownPopulators`.
         */
        class_1.prototype._resolvePopulatorByName = function (name) {
            if (name === optionsDropdownPopulator.constructor.name) {
                return optionsDropdownPopulator;
            }
            if (name === uriDropdownPopulator.constructor.name) {
                return uriDropdownPopulator;
            }
            if ($injector.has(name)) {
                return $injector.get(name);
            }
            if (customDropdownPopulators && customDropdownPopulators.length > 0) {
                return customDropdownPopulators.find(function (populator) { return populator.constructor.name.toUpperCase() === name.toUpperCase(); });
            }
            return undefined;
        };
        class_1.prototype._isFieldPaged = function (field) {
            return this.field.paged ? this.field.paged : false;
        };
        return class_1;
    }());
};

var GenericEditorDropdownModule = /** @class */ (function () {
    function GenericEditorDropdownModule() {
    }
    GenericEditorDropdownModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, SelectModule, DropdownPopulatorModule],
            declarations: [GenericEditorDropdownComponent],
            entryComponents: [GenericEditorDropdownComponent],
            exports: [GenericEditorDropdownComponent],
            providers: [
                {
                    provide: DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN,
                    useValue: 'DropdownPopulator'
                },
                {
                    provide: LINKED_DROPDOWN_TOKEN,
                    useValue: LINKED_DROPDOWN
                },
                {
                    provide: CLICK_DROPDOWN_TOKEN,
                    useValue: CLICK_DROPDOWN
                },
                // Injected by <se-generic-editor-dropdown>. It doesn't create a new instance (as it supposed to do because it's a factory function).
                // Instead, it returns a constructor function that is instantiated in `GenericEditorDropdownComponent#ngOnInit`.
                {
                    provide: IGenericEditorDropdownServiceConstructor,
                    useFactory: GenericEditorDropdownServiceFactory,
                    deps: [
                        AngularJSLazyDependenciesService,
                        utils.LogService,
                        LINKED_DROPDOWN_TOKEN,
                        CLICK_DROPDOWN_TOKEN,
                        DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN,
                        SystemEventService,
                        OptionsDropdownPopulator,
                        UriDropdownPopulator,
                        [new core.Optional(), CustomDropdownPopulatorsToken] // Only available when Custom Populator has been provided.
                    ]
                },
                moduleUtils.initialize(function () {
                    // **Deprecated, since 2105**
                    //
                    // Makes IGenericEditorDropdownServiceConstructor provider (GenericEditorDropdownServiceFactory) available in AngularJS by 'SEDropdownService'.
                    diBridgeUtils.downgradeService('SEDropdownService', IGenericEditorDropdownServiceConstructor);
                    diBridgeUtils.downgradeService('DROPDOWN_IMPLEMENTATION_SUFFIX', null, DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN);
                    diBridgeUtils.downgradeService('LINKED_DROPDOWN', null, LINKED_DROPDOWN_TOKEN);
                    diBridgeUtils.downgradeService('CLICK_DROPDOWN', null, CLICK_DROPDOWN_TOKEN);
                })
            ]
        })
    ], GenericEditorDropdownModule);
    return GenericEditorDropdownModule;
}());

/**
 * **Deprecated since 2105, use {@link GenericEditorDropdownComponent}.**
 *
 * ### Parameters
 *
 * `field` - The field description of the field being edited as defined by the structure API described in {@link GenericEditorFactoryService}.
 *
 * `field.options` - An array of options to be populated.
 *
 * `field.uri` - The uri to fetch the list of options from a REST call, especially if the dropdown is dependent on another one.
 *
 * `field.propertyType` - If a propertyType is defined, the seDropdown will use the populator associated to it with the following AngularJS recipe name : `propertyType + "DropdownPopulator"`.
 *
 * `field.dependsOn` - The qualifier of the parent dropdown that this dropdown depends on.
 *
 * `field.idAttribute` - The name of the id attribute to use when populating dropdown items.
 *
 * `field.labelAttributes` - An array of attributes to use when determining the label for each item in the dropdown
 *
 * `field.paged` - A boolean to determine if we are in paged mode as opposed to retrieving all items at once.
 *
 * `qualifier` - If the field is not localized, this is the actual field.qualifier, if it is localized, it is the language identifier such as en, de...
 *
 * `model` - If the field is not localized, this is the actual full parent model object, if it is localized, it is the language map: model[field.qualifier].
 *
 * `id` - An identifier of the generated DOM element.
 *
 * `itemTemplateUrl` - The path to the template that will be used to display items in both the dropdown menu and the selection.
 *
 * `getApi` - Exposes API used for setting resultsHeaderTemplateUrl or resultsHeaderTemplate.
 *
 * @deprecated
 */
var /* @ngInject */ SeDropdownComponent = /** @class */ (function () {
    SeDropdownComponent.$inject = ["SEDropdownService", "CONTEXT_CATALOG", "CONTEXT_CATALOG_VERSION", "yjQuery"];
    function /* @ngInject */ SeDropdownComponent(SEDropdownService, CONTEXT_CATALOG, CONTEXT_CATALOG_VERSION, yjQuery) {
        this.SEDropdownService = SEDropdownService;
        this.CONTEXT_CATALOG = CONTEXT_CATALOG;
        this.CONTEXT_CATALOG_VERSION = CONTEXT_CATALOG_VERSION;
        this.yjQuery = yjQuery;
    }
    /* @ngInject */ SeDropdownComponent.prototype.$onInit = function () {
        genericEditorDropdownComponentOnInit.call(this);
    };
    /* @ngInject */ SeDropdownComponent.prototype.onClickOtherDropdown = function () {
        this.closeSelect();
    };
    /* @ngInject */ SeDropdownComponent.prototype.closeSelect = function () {
        var uiSelectCtrl = this.getUiSelectCtrl();
        if (uiSelectCtrl) {
            uiSelectCtrl.open = false;
        }
    };
    /* @ngInject */ SeDropdownComponent.prototype.getUiSelectCtrl = function () {
        var uiSelectId = '#' + this.field.qualifier + '-selector';
        return this.yjQuery(uiSelectId).controller('uiSelect');
    };
    /* @ngInject */ SeDropdownComponent = __decorate([
        SeComponent({
            templateUrl: 'seDropdownTemplate.html',
            inputs: [
                'field:=',
                'qualifier:=',
                'model:=',
                'id:=',
                'getApi:&?',
                'itemTemplateUrl',
                'showRemoveButton'
            ]
        }),
        __metadata("design:paramtypes", [Object, String, String, Function])
    ], /* @ngInject */ SeDropdownComponent);
    return /* @ngInject */ SeDropdownComponent;
}());

/**
 * **Deprecated since 2105, use {@link GenericEditorDropdownModule}.**
 *
 * @deprecated
 */
var /* @ngInject */ SeDropdownModule = /** @class */ (function () {
    function /* @ngInject */ SeDropdownModule() {
    }
    /* @ngInject */ SeDropdownModule = __decorate([
        SeModule({
            imports: ['smarteditServicesModule', 'functionsModule', 'seConstantsModule'],
            declarations: [SeDropdownComponent]
        })
    ], /* @ngInject */ SeDropdownModule);
    return /* @ngInject */ SeDropdownModule;
}());

/**
 * **Deprecated since 2005, use {@link GenericEditorComponent}.**
 *
 * Component responsible for generating custom HTML CRUD form for any smarteditComponent type.
 *
 * The controller has a method that creates a new instance for the {@link GenericEditorFactoryService}
 * and sets the scope of smarteditComponentId and smarteditComponentType to a value that has been extracted from the original DOM element in the storefront.
 *
 * ### Parameters
 *
 * `id` - Id of the current generic editor.
 *
 * `smarteditComponentType` - The SmartEdit component type that is to be created, read, updated, or deleted.
 *
 * `smarteditComponentId` - The identifier of the SmartEdit component that is to be created, read, updated, or deleted.
 *
 * `structureApi` - The data binding to a REST Structure API that fulfills the contract described in the  {@link GenericEditorFactoryService} service. Only the Structure API or the local structure must be set.
 *
 * `structure` - The data binding to a REST Structure JSON that fulfills the contract described in the {@link GenericEditorFactoryService} service. Only the Structure API or the local structure must be set.
 *
 * `contentApi` - The REST API used to create, read, update, or delete content.
 *
 * `content` - The model for the generic editor (the initial content when the component is being edited).
 *
 * `uriContext` - is an optional parameter and is used to pass the uri Params which can be used in making
 *
 * api calls in custom widgets. It is an optional parameter and if not found, generic editor will find an experience in
 * sharedDataService and set this uriContext.
 * `submit` - It exposes the inner submit function to the invoker scope. If this parameter is set, the directive will not display an inner submit button.
 *
 * `reset` - It exposes the inner reset function to the invoker scope. If this parameter is set, the directive will not display an inner cancel button.
 *
 * `isDirty` - Indicates if the the generic editor is in a pristine state (for example: has been modified).
 *
 * `isValid` - Indicates if all of the containing forms and controls in the generic editor are valid.
 *
 * `getApi` - Exposes the generic editor's api object
 *
 * `updateCallback` - Callback called at the end of a successful submit. It is invoked with two arguments: the pristine object and the response from the server.
 *
 * `customOnSubmit` - It exposes the inner onSubmit function to the invoker scope. If the parameter is set, the inner onSubmit function is overridden by the custom function and the custom function must return a promise in the response format expected by the generic editor.
 *
 * `editorStackId` - When working with nested components, a generic editor can be opened from within another editor. This parameter is used to specify the stack of nested editors.
 *
 * @deprecated
 */
var /* @ngInject */ GenericEditorComponent = /** @class */ (function () {
    GenericEditorComponent.$inject = ["$attrs"];
    function /* @ngInject */ GenericEditorComponent($attrs) {
        this.$attrs = $attrs;
    }
    /* @ngInject */ GenericEditorComponent.prototype.$onInit = function () {
        this.submit = this.$attrs.hasOwnProperty('submit') ? this.submit : null;
        this.reset = this.$attrs.hasOwnProperty('reset') ? this.reset : null;
        this.isDirty = this.$attrs.hasOwnProperty('isDirty') ? this.isDirty : null;
        this.isValid = this.$attrs.hasOwnProperty('isValid') ? this.isValid : null;
    };
    /* @ngInject */ GenericEditorComponent = __decorate([
        SeComponent({
            templateUrl: 'genericEditorComponentTemplate.html',
            inputs: [
                'id:=',
                'smarteditComponentId:=',
                'smarteditComponentType:=?',
                'contentApi:=',
                'content:=',
                'uriContext',
                'submit:=?',
                'reset:=?',
                'isDirty:=?',
                'isValid:=?',
                'getApi:&?',
                'customOnSubmit:=?',
                'structureApi',
                'structure',
                'updateCallback',
                'editorStackId'
            ]
        }),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ GenericEditorComponent);
    return /* @ngInject */ GenericEditorComponent;
}());

var GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT_CONSTANT = {
    provide: 'GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT',
    useValue: GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT
};
/**
 * Event to notify subscribers that GenericEditor is loaded.
 */
var GENERIC_EDITOR_LOADED_EVENT_CONSTANT = {
    provide: 'GENERIC_EDITOR_LOADED_EVENT',
    useValue: GENERIC_EDITOR_LOADED_EVENT
};
var /* @ngInject */ GenericEditorModule = /** @class */ (function () {
    function /* @ngInject */ GenericEditorModule() {
    }
    /* @ngInject */ GenericEditorModule = __decorate([
        SeModule({
            imports: [
                'smarteditServicesModule',
                'functionsModule',
                'coretemplates',
                'translationServiceModule',
                'seConstantsModule',
                'resourceLocationsModule',
                'ui.bootstrap',
                SeDropdownModule
            ],
            providers: [
                GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT_CONSTANT,
                GENERIC_EDITOR_LOADED_EVENT_CONSTANT
            ],
            declarations: [GenericEditorComponent]
        })
    ], /* @ngInject */ GenericEditorModule);
    return /* @ngInject */ GenericEditorModule;
}());

var COLLAPSIBLE_DEFAULT_CONFIGURATION = {
    expandedByDefault: false,
    iconAlignment: 'right',
    iconVisible: true
};

window.__smartedit__.addDecoratorPayload("Component", "CollapsibleContainerComponent", {
    selector: 'se-collapsible-container',
    template: "<div role=\"tab\" class=\"collapsible-container__header\" [ngClass]=\"{\n        'collapsible-container__header--icon-right': isIconRight(),\n        'collapsible-container__header--icon-left': isIconLeft()\n    }\" [attr.id]=\"headingId\" [attr.aria-selected]=\"isOpen\" (keypress)=\"handleKeypress($event)\"><button type=\"button\" tabindex=\"0\" class=\"collapsible-container__header__title\" (click)=\"toggle()\" [attr.aria-expanded]=\"isOpen\" [attr.aria-controls]=\"panelId\"><ng-content select=\"se-collapsible-container-header\"></ng-content></button> <a class=\"collapsible-container__header__button btn btn-link\" *ngIf=\"configuration.iconVisible\" [ngClass]=\"{\n            'collapsible-container__header__button--expanded': isOpen\n        }\" [title]=\"isOpen\n            ? 'se.ycollapsible.action.collapse'\n            : ('se.ycollapsible.action.expand' | translate)\n        \" [attr.aria-expanded]=\"isOpen\" (click)=\"toggle()\"><span class=\"sap-icon--navigation-down-arrow collapsible-container__header__icon\"></span></a></div><div #container class=\"collapsible-container__content panel\" [ngStyle]=\"{ 'max-height.px': isOpen ? containerHeight : 0 }\" [attr.id]=\"panelId\" [attr.aria-labelledby]=\"headingId\" [attr.aria-hidden]=\"!isOpen\" role=\"tabpanel\"><ng-content select=\"se-collapsible-container-content\"></ng-content></div>",
    styles: [".collapsible-container__content{overflow:hidden;display:block;transition:max-height .4s ease;width:100%;background-color:#fff}.collapsible-container__header{max-width:100%;background-color:#fff;display:flex;align-items:center;min-height:50px;box-shadow:0 1px 1px rgba(0,0,0,.05)}.collapsible-container__header__title{text-align:left;background:0 0;border:0;outline:0;flex:1;display:flex;align-items:center;min-height:50px;text-decoration:none;user-select:none}.collapsible-container__header__title:hover{text-decoration:none}.collapsible-container__header__button{flex:0;transition:all .4s ease;font-size:20px}.collapsible-container__header__button--expanded{transform:rotate(180deg)}.collapsible-container__header--icon-right .collapsible-container__header__title{order:1}.collapsible-container__header--icon-right .collapsible-container__header__button{order:2}.collapsible-container__header--icon-left .collapsible-container__header__title{order:2}.collapsible-container__header--icon-left .collapsible-container__header__button{order:1}:host(.se-collapsible-container--noshadow) .collapsible-container__content.panel{box-shadow:none}"],
    changeDetection: core.ChangeDetectionStrategy.OnPush
});
var /* @ngInject */ CollapsibleContainerComponent = /** @class */ (function () {
    CollapsibleContainerComponent.$inject = ["cdr"];
    function /* @ngInject */ CollapsibleContainerComponent(cdr) {
        var _this = this;
        this.cdr = cdr;
        this.getApi = new core.EventEmitter();
        this.containerHeight = 0;
        this.headingId = stringUtils.generateIdentifier();
        this.panelId = stringUtils.generateIdentifier();
        this.api = {
            isExpanded: function () { return _this.isOpen; }
        };
    }
    Object.defineProperty(/* @ngInject */ CollapsibleContainerComponent.prototype, "_container", {
        set: function (container) {
            var _this = this;
            this.container = container;
            this.containerHeight = container.nativeElement.scrollHeight;
            if (!this.mutationObserver && this.container && this.container.nativeElement) {
                this.mutationObserver = new MutationObserver(function () {
                    _this.containerHeight = _this.container.nativeElement.scrollHeight;
                    _this.cdr.detectChanges();
                });
                this.mutationObserver.observe(this.container.nativeElement, {
                    childList: true,
                    subtree: true,
                    attributes: true
                });
            }
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ CollapsibleContainerComponent.prototype.ngOnDestroy = function () {
        this.mutationObserver.disconnect();
    };
    /* @ngInject */ CollapsibleContainerComponent.prototype.ngOnChanges = function (changes) {
        if (changes.configuration) {
            this.configure();
        }
    };
    CollapsibleContainerComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ CollapsibleContainerComponent.prototype.ngOnInit = function () {
        this.configure();
        this.isOpen = this.configuration.expandedByDefault;
        this.getApi.emit(this.api);
    };
    /* @ngInject */ CollapsibleContainerComponent.prototype.toggle = function () {
        this.isOpen = !this.isOpen;
    };
    /* @ngInject */ CollapsibleContainerComponent.prototype.handleKeypress = function (event) {
        if (event.code === 'Enter') {
            this.toggle();
        }
    };
    CollapsibleContainerComponent.prototype.handleKeypress.$inject = ["event"];
    /* @ngInject */ CollapsibleContainerComponent.prototype.isIconRight = function () {
        return this.configuration.iconAlignment === 'right';
    };
    /* @ngInject */ CollapsibleContainerComponent.prototype.isIconLeft = function () {
        return this.configuration.iconAlignment === 'left';
    };
    /* @ngInject */ CollapsibleContainerComponent.prototype.configure = function () {
        this.configuration = __assign(__assign({}, COLLAPSIBLE_DEFAULT_CONFIGURATION), (this.configuration || {}));
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ CollapsibleContainerComponent.prototype, "configuration", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ CollapsibleContainerComponent.prototype, "getApi", void 0);
    __decorate([
        core.ViewChild('container', { static: true }),
        __metadata("design:type", core.ElementRef),
        __metadata("design:paramtypes", [core.ElementRef])
    ], /* @ngInject */ CollapsibleContainerComponent.prototype, "_container", null);
    /* @ngInject */ CollapsibleContainerComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-collapsible-container',
            template: "<div role=\"tab\" class=\"collapsible-container__header\" [ngClass]=\"{\n        'collapsible-container__header--icon-right': isIconRight(),\n        'collapsible-container__header--icon-left': isIconLeft()\n    }\" [attr.id]=\"headingId\" [attr.aria-selected]=\"isOpen\" (keypress)=\"handleKeypress($event)\"><button type=\"button\" tabindex=\"0\" class=\"collapsible-container__header__title\" (click)=\"toggle()\" [attr.aria-expanded]=\"isOpen\" [attr.aria-controls]=\"panelId\"><ng-content select=\"se-collapsible-container-header\"></ng-content></button> <a class=\"collapsible-container__header__button btn btn-link\" *ngIf=\"configuration.iconVisible\" [ngClass]=\"{\n            'collapsible-container__header__button--expanded': isOpen\n        }\" [title]=\"isOpen\n            ? 'se.ycollapsible.action.collapse'\n            : ('se.ycollapsible.action.expand' | translate)\n        \" [attr.aria-expanded]=\"isOpen\" (click)=\"toggle()\"><span class=\"sap-icon--navigation-down-arrow collapsible-container__header__icon\"></span></a></div><div #container class=\"collapsible-container__content panel\" [ngStyle]=\"{ 'max-height.px': isOpen ? containerHeight : 0 }\" [attr.id]=\"panelId\" [attr.aria-labelledby]=\"headingId\" [attr.aria-hidden]=\"!isOpen\" role=\"tabpanel\"><ng-content select=\"se-collapsible-container-content\"></ng-content></div>",
            styles: [".collapsible-container__content{overflow:hidden;display:block;transition:max-height .4s ease;width:100%;background-color:#fff}.collapsible-container__header{max-width:100%;background-color:#fff;display:flex;align-items:center;min-height:50px;box-shadow:0 1px 1px rgba(0,0,0,.05)}.collapsible-container__header__title{text-align:left;background:0 0;border:0;outline:0;flex:1;display:flex;align-items:center;min-height:50px;text-decoration:none;user-select:none}.collapsible-container__header__title:hover{text-decoration:none}.collapsible-container__header__button{flex:0;transition:all .4s ease;font-size:20px}.collapsible-container__header__button--expanded{transform:rotate(180deg)}.collapsible-container__header--icon-right .collapsible-container__header__title{order:1}.collapsible-container__header--icon-right .collapsible-container__header__button{order:2}.collapsible-container__header--icon-left .collapsible-container__header__title{order:2}.collapsible-container__header--icon-left .collapsible-container__header__button{order:1}:host(.se-collapsible-container--noshadow) .collapsible-container__content.panel{box-shadow:none}"],
            changeDetection: core.ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [core.ChangeDetectorRef])
    ], /* @ngInject */ CollapsibleContainerComponent);
    return /* @ngInject */ CollapsibleContainerComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "CollapsibleContainerContentComponent", {
    selector: 'se-collapsible-container-content',
    template: " <ng-content></ng-content> "
});
var /* @ngInject */ CollapsibleContainerContentComponent = /** @class */ (function () {
    function /* @ngInject */ CollapsibleContainerContentComponent() {
    }
    /* @ngInject */ CollapsibleContainerContentComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-collapsible-container-content',
            template: " <ng-content></ng-content> "
        })
    ], /* @ngInject */ CollapsibleContainerContentComponent);
    return /* @ngInject */ CollapsibleContainerContentComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "CollapsibleContainerHeaderComponent", {
    selector: 'se-collapsible-container-header',
    template: " <ng-content></ng-content> "
});
var /* @ngInject */ CollapsibleContainerHeaderComponent = /** @class */ (function () {
    function /* @ngInject */ CollapsibleContainerHeaderComponent() {
    }
    /* @ngInject */ CollapsibleContainerHeaderComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-collapsible-container-header',
            template: " <ng-content></ng-content> "
        })
    ], /* @ngInject */ CollapsibleContainerHeaderComponent);
    return /* @ngInject */ CollapsibleContainerHeaderComponent;
}());

var CollapsibleContainerModule = /** @class */ (function () {
    function CollapsibleContainerModule() {
    }
    CollapsibleContainerModule = __decorate([
        core.NgModule({
            imports: [core$1.TranslateModule.forChild(), common.CommonModule],
            declarations: [
                CollapsibleContainerComponent,
                CollapsibleContainerContentComponent,
                CollapsibleContainerHeaderComponent
            ],
            entryComponents: [
                CollapsibleContainerComponent,
                CollapsibleContainerContentComponent,
                CollapsibleContainerHeaderComponent
            ],
            exports: [
                CollapsibleContainerComponent,
                CollapsibleContainerContentComponent,
                CollapsibleContainerHeaderComponent
            ]
        })
    ], CollapsibleContainerModule);
    return CollapsibleContainerModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "WaitDialogComponent", {
    template: "\n        <div class=\"panel panel-default ySEPanelSpinner\">\n            <div class=\"panel-body\">\n                <div class=\"spinner ySESpinner\">\n                    <div class=\"spinner-container spinner-container1\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                    <div class=\"spinner-container spinner-container2\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                    <div class=\"spinner-container spinner-container3\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                </div>\n                <div class=\"ySESpinnerText\">\n                    {{\n                        modalRef.data.customLoadingMessageLocalizedKey || 'se.wait.dialog.message'\n                            | translate\n                    }}\n                </div>\n            </div>\n        </div>\n    ",
    selector: 'wait-dialog'
});
var WaitDialogComponent = /** @class */ (function () {
    function WaitDialogComponent(modalRef) {
        this.modalRef = modalRef;
    }
    WaitDialogComponent = __decorate([
        core.Component({
            template: "\n        <div class=\"panel panel-default ySEPanelSpinner\">\n            <div class=\"panel-body\">\n                <div class=\"spinner ySESpinner\">\n                    <div class=\"spinner-container spinner-container1\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                    <div class=\"spinner-container spinner-container2\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                    <div class=\"spinner-container spinner-container3\">\n                        <div class=\"spinner-circle1\"></div>\n                        <div class=\"spinner-circle2\"></div>\n                        <div class=\"spinner-circle3\"></div>\n                        <div class=\"circle4\"></div>\n                    </div>\n                </div>\n                <div class=\"ySESpinnerText\">\n                    {{\n                        modalRef.data.customLoadingMessageLocalizedKey || 'se.wait.dialog.message'\n                            | translate\n                    }}\n                </div>\n            </div>\n        </div>\n    ",
            selector: 'wait-dialog'
        }),
        __metadata("design:paramtypes", [core$2.ModalRef])
    ], WaitDialogComponent);
    return WaitDialogComponent;
}());

var TabsSelectAdapter = /** @class */ (function () {
    function TabsSelectAdapter() {
    }
    TabsSelectAdapter.transform = function (item, id) {
        return {
            id: id,
            label: item.title,
            value: item,
            listItemClassName: item.hasErrors && 'sm-tab-error'
        };
    };
    return TabsSelectAdapter;
}());

window.__smartedit__.addDecoratorPayload("Component", "TabsComponent", {
    selector: 'se-tabs',
    template: "<div class=\"se-tabset-wrapper\"><ul class=\"nav nav-tabs se-tabset\" role=\"tablist\" *ngIf=\"isInitialized\"><ng-container *ngIf=\"tabsList.length !== numTabsDisplayed\"><li *ngFor=\"let tab of (getVisibleTabs() | async); trackBy: trackTabById\" [ngClass]=\"{ 'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" (click)=\"selectTab(tab)\" class=\"se-tabset__link\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><ng-container *ngIf=\"tabsList && tabsList.length == numTabsDisplayed\"><li *ngFor=\"let tab of tabsList; trackBy: trackTabById\" [ngClass]=\"{'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><su-select class=\"se-tabset__select\" *ngIf=\"tabsList.length > numTabsDisplayed && (getDropdownTabs() | async)\" [items]=\"dropdownTabs\" [isKeyboardControlEnabled]=\"false\" [hasCustomTrigger]=\"true\" (onItemSelected)=\"selectTab($event.value)\"><li [ngClass]=\"{'active': isActiveInMoreTab()}\" su-select-custom-trigger><a [ngClass]=\"{'sm-tab-error': dropDownHasErrors()}\" class=\"dropdown-toggle\"><span *ngIf=\"!isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{ 'se.ytabset.tabs.more' | translate }} </span><span *ngIf=\"isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{selectedTab.title | translate}} </span><span class=\"caret\"></span></a></li></su-select></ul><div class=\"se-tab-set__content-wrapper\" *ngIf=\"selectedTab\"><ng-container *ngFor=\"let tab of tabsList; trackBy: trackTabById\"><se-tab [hidden]=\"tab.id !== selectedTab.id\" [attr.tab-id]=\"tab.id\" [tab]=\"tab\" [model]=\"model\"></se-tab></ng-container></div></div>"
});
var /* @ngInject */ TabsComponent = /** @class */ (function () {
    function /* @ngInject */ TabsComponent() {
        this.tabsList = [];
        this.onTabSelected = new core.EventEmitter();
        this.tabChangedStream = new rxjs.BehaviorSubject(null);
    }
    Object.defineProperty(/* @ngInject */ TabsComponent.prototype, "isInitialized", {
        get: function () {
            return !!this.tabsList && this.tabsList.length > 1 && !!this.selectedTab;
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ TabsComponent.prototype.isActiveInMoreTab = function () {
        var _this = this;
        return (this.tabsList.findIndex(function (tab) { return tab.id === _this.selectedTab.id; }) >=
            this.numTabsDisplayed - 1);
    };
    /* @ngInject */ TabsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        var hasTabsInitialized = (changes.tabsList &&
            changes.tabsList.currentValue &&
            !changes.tabsList.previousValue) ||
            (changes.tabsList && changes.tabsList.firstChange && !!changes.tabsList.currentValue);
        var hasTabsChanged = changes.tabsList && !!changes.tabsList.previousValue && !!changes.tabsList.currentValue;
        if (this.tabsList) {
            var active = this.tabsList.find(function (tab) { return tab.active; }) || this.tabsList[0];
            if (!this.selectedTab || (this.selectedTab && this.selectedTab.id !== active.id)) {
                this.selectedTab = active;
                this.selectedTab.active = true;
            }
        }
        if (hasTabsInitialized) {
            this.tabsList = this.tabsList.map(function (tab) { return (__assign(__assign({}, tab), { active: false, hasErrors: false })); });
            this.tabChangedStream.next();
        }
        if (hasTabsChanged) {
            this.tabChangedStream.next();
        }
        this.getDropdownTabs().subscribe(function (tabs) {
            _this.dropdownTabs = tabs;
        });
    };
    TabsComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ TabsComponent.prototype.selectTab = function (tabToSelect) {
        if (tabToSelect && tabToSelect.id !== this.selectedTab.id) {
            if (!this.selectedTab.active) {
                this.findSelectedTab();
            }
            this.selectedTab.active = false;
            this.selectedTab = tabToSelect;
            this.selectedTab.active = true;
            this.onTabSelected.emit(this.selectedTab.id);
        }
    };
    TabsComponent.prototype.selectTab.$inject = ["tabToSelect"];
    /* @ngInject */ TabsComponent.prototype.dropDownHasErrors = function () {
        var tabsInDropDown = this.tabsList.slice(this.numTabsDisplayed - 1);
        return tabsInDropDown.some(function (tab) { return tab.hasErrors; });
    };
    /* @ngInject */ TabsComponent.prototype.findSelectedTab = function () {
        var selectedTab = this.tabsList.find(function (tab) { return tab.active; });
        if (selectedTab) {
            this.selectedTab = selectedTab;
        }
    };
    /* @ngInject */ TabsComponent.prototype.getDropdownTabs = function () {
        var _this = this;
        return this.tabChangedStream.pipe(operators.map(function () {
            return (_this.tabsList || [])
                .slice(_this.numTabsDisplayed - 1)
                .map(TabsSelectAdapter.transform);
        }), operators.distinctUntilChanged(function (a, b) { return lodash.isEqual(a, b); }));
    };
    /* @ngInject */ TabsComponent.prototype.getVisibleTabs = function () {
        var _this = this;
        return this.tabChangedStream.pipe(operators.map(function () { return (_this.tabsList || []).slice(0, _this.numTabsDisplayed - 1); }), operators.distinctUntilChanged(function (a, b) { return lodash.isEqual(a, b); }));
    };
    /* @ngInject */ TabsComponent.prototype.trackTabById = function (index) {
        return index;
    };
    TabsComponent.prototype.trackTabById.$inject = ["index"];
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TabsComponent.prototype, "model", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ TabsComponent.prototype, "tabsList", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ TabsComponent.prototype, "numTabsDisplayed", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ TabsComponent.prototype, "onTabSelected", void 0);
    /* @ngInject */ TabsComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-tabs',
            template: "<div class=\"se-tabset-wrapper\"><ul class=\"nav nav-tabs se-tabset\" role=\"tablist\" *ngIf=\"isInitialized\"><ng-container *ngIf=\"tabsList.length !== numTabsDisplayed\"><li *ngFor=\"let tab of (getVisibleTabs() | async); trackBy: trackTabById\" [ngClass]=\"{ 'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" (click)=\"selectTab(tab)\" class=\"se-tabset__link\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><ng-container *ngIf=\"tabsList && tabsList.length == numTabsDisplayed\"><li *ngFor=\"let tab of tabsList; trackBy: trackTabById\" [ngClass]=\"{'active': tab.id === selectedTab.id }\" [attr.tab-id]=\"tab.id\" class=\"se-tabset__tab\"><a [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\" *ngIf=\"!tab.message\">{{tab.title | translate}}</a><se-tooltip [triggers]=\"['mouseover']\" *ngIf=\"tab.message\"><a se-tooltip-trigger [ngClass]=\"{'sm-tab-error': tab.hasErrors}\" class=\"se-tabset__link\" (click)=\"selectTab(tab)\">{{tab.title | translate}} </a><span se-tooltip-body>{{ tab.message }}</span></se-tooltip></li></ng-container><su-select class=\"se-tabset__select\" *ngIf=\"tabsList.length > numTabsDisplayed && (getDropdownTabs() | async)\" [items]=\"dropdownTabs\" [isKeyboardControlEnabled]=\"false\" [hasCustomTrigger]=\"true\" (onItemSelected)=\"selectTab($event.value)\"><li [ngClass]=\"{'active': isActiveInMoreTab()}\" su-select-custom-trigger><a [ngClass]=\"{'sm-tab-error': dropDownHasErrors()}\" class=\"dropdown-toggle\"><span *ngIf=\"!isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{ 'se.ytabset.tabs.more' | translate }} </span><span *ngIf=\"isActiveInMoreTab()\" class=\"multi-tabs__more-span\">{{selectedTab.title | translate}} </span><span class=\"caret\"></span></a></li></su-select></ul><div class=\"se-tab-set__content-wrapper\" *ngIf=\"selectedTab\"><ng-container *ngFor=\"let tab of tabsList; trackBy: trackTabById\"><se-tab [hidden]=\"tab.id !== selectedTab.id\" [attr.tab-id]=\"tab.id\" [tab]=\"tab\" [model]=\"model\"></se-tab></ng-container></div></div>"
        })
    ], /* @ngInject */ TabsComponent);
    return /* @ngInject */ TabsComponent;
}());

var TAB_DATA = new core.InjectionToken('tab-data');
window.__smartedit__.addDecoratorPayload("Component", "TabComponent", {
    selector: 'se-tab',
    template: "<ng-container *ngIf=\"!isLegacyTab; else legacyAngularJSTab\"><ng-container *ngComponentOutlet=\"tab.component; injector: tabInjector\"></ng-container></ng-container><ng-template #legacyAngularJSTab><div [ngInclude]=\"tab.templateUrl\" [scope]=\"scopeStream | async\"></div></ng-template>"
});
var /* @ngInject */ TabComponent = /** @class */ (function () {
    TabComponent.$inject = ["injector"];
    function /* @ngInject */ TabComponent(injector) {
        this.injector = injector;
        this.scopeStream = new rxjs.BehaviorSubject(null);
    }
    /* @ngInject */ TabComponent.prototype.ngOnChanges = function (changes) {
        var modelChanged = changes.model && !lodash.isEqual(changes.model.previousValue, changes.model.currentValue);
        var tabChanged = changes.tab && !lodash.isEqual(changes.tab.previousValue, changes.tab.currentValue);
        if (tabChanged || modelChanged) {
            this.scopeStream.next({ model: this.model, tabId: this.tab.id, tab: this.tab });
        }
    };
    TabComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ TabComponent.prototype.ngOnInit = function () {
        if (!this.isLegacyTab) {
            this.tabInjector = core.Injector.create({
                providers: [
                    {
                        provide: TAB_DATA,
                        useValue: { model: this.model, tabId: this.tab.id, tab: this.tab }
                    }
                ],
                parent: this.injector
            });
        }
    };
    Object.defineProperty(/* @ngInject */ TabComponent.prototype, "isLegacyTab", {
        get: function () {
            return !!this.tab.templateUrl;
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TabComponent.prototype, "tab", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TabComponent.prototype, "model", void 0);
    /* @ngInject */ TabComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-tab',
            template: "<ng-container *ngIf=\"!isLegacyTab; else legacyAngularJSTab\"><ng-container *ngComponentOutlet=\"tab.component; injector: tabInjector\"></ng-container></ng-container><ng-template #legacyAngularJSTab><div [ngInclude]=\"tab.templateUrl\" [scope]=\"scopeStream | async\"></div></ng-template>"
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], /* @ngInject */ TabComponent);
    return /* @ngInject */ TabComponent;
}());

var FundamentalsModule = /** @class */ (function () {
    function FundamentalsModule() {
    }
    FundamentalsModule = __decorate([
        core.NgModule({
            imports: [
                core$2.ModalModule,
                core$2.ButtonModule,
                animations.BrowserAnimationsModule,
                forms.FormsModule,
                core$2.PopoverModule,
                core$2.MenuModule,
                core$2.AlertModule,
                core$2.PaginationModule
            ],
            exports: [
                core$2.ModalModule,
                core$2.ButtonModule,
                core$2.FormModule,
                core$2.PopoverModule,
                core$2.MenuModule,
                core$2.AlertModule,
                core$2.PaginationModule
            ]
        })
    ], FundamentalsModule);
    return FundamentalsModule;
}());

/*
 * This custom implementations of $translateStaticFilesLoader needed by 'pascalprecht.translate' package leverages
 * our restServiceFactory as opposed to httpClient in order to proxy the i18n loading to the container.
 * This is required for our cross-origin compliancy
 */
function $translateStaticFilesLoader($q, translationsFetchService) {
    'ngInject';
    return function (options) {
        return $q.when(translationsFetchService.get(options.key));
    };
}

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
require('angular-translate');
/**
 * This module is used to configure the translate service, the filter, and the directives from the 'pascalprecht.translate' package. The configuration consists of:
 */
var /* @ngInject */ TranslationServiceModule = /** @class */ (function () {
    function /* @ngInject */ TranslationServiceModule() {
    }
    /* @ngInject */ TranslationServiceModule = __decorate([
        SeModule({
            imports: ['pascalprecht.translate', 'legacySmarteditCommonsModule'],
            providers: [$translateStaticFilesLoader],
            config: ["$translateProvider", function ($translateProvider) {
                'ngInject';
                $translateProvider.useStaticFilesLoader({
                    prefix: I18N_RESOURCE_URI + '/',
                    suffix: ''
                });
                // Tell the module what language to use by default
                $translateProvider.preferredLanguage(DEFAULT_LANGUAGE);
                // Using 'escapeParameters' strategy. 'sanitize' not supported in current version.
                // see https://angular-translate.github.io/docs/#/guide/19_security
                // Note that this is the only option that should be used for now.
                // The options 'sanitizeParameters' and 'escape' are causing issues (& replaced by &amp; and interpolation parameters values are not displayed correctly).
                $translateProvider.useSanitizeValueStrategy('escapeParameters');
            }],
            initialize: ["$translate", "browserService", "operationContextService", "crossFrameEventService", "storageService", "SWITCH_LANGUAGE_EVENT", "OPERATION_CONTEXT", function ($translate, browserService, operationContextService, crossFrameEventService, storageService, SWITCH_LANGUAGE_EVENT, OPERATION_CONTEXT) {
                'ngInject';
                storageService
                    .getValueFromLocalStorage('SELECTED_LANGUAGE', false)
                    .then(function (lang) {
                    return lang ? lang.isoCode : browserService.getBrowserLocale();
                }, function () { return browserService.getBrowserLocale(); })
                    .then(function (lang) {
                    $translate.use(lang);
                });
                operationContextService.register(I18N_RESOURCE_URI, OPERATION_CONTEXT.TOOLING);
                crossFrameEventService.subscribe(SWITCH_LANGUAGE_EVENT, function (id, data) {
                    $translate.use(data.isoCode);
                });
            }]
        })
    ], /* @ngInject */ TranslationServiceModule);
    return /* @ngInject */ TranslationServiceModule;
}());

/**
 * Temporary module providing AlertService for legacy token, until AlertService migration to Angular is completed.
 * Used by Outer / Inner modules to import.
 * It uses "useFactory" to return the same service but for different token.
 *
 * When it is in "web/app/smartedit/smartedit.ts" it results in the following error.
 * "ERROR: File web/app/smartedit/smartedit.ts contains forbidden namespace 'useFactory', consider using 'useFactory is part of DI and hence should only be used in Modules"
 */
var AlertServiceProvidersModule = /** @class */ (function () {
    function AlertServiceProvidersModule() {
    }
    AlertServiceProvidersModule_1 = AlertServiceProvidersModule;
    AlertServiceProvidersModule.forRoot = function (token, AlertServiceClass) {
        return {
            ngModule: AlertServiceProvidersModule_1,
            providers: [
                {
                    provide: token,
                    useClass: AlertServiceClass
                },
                {
                    provide: utils.IAlertService,
                    useFactory: function (alertService) { return alertService; },
                    deps: [token]
                }
            ]
        };
    };
    var AlertServiceProvidersModule_1;
    AlertServiceProvidersModule = AlertServiceProvidersModule_1 = __decorate([
        core.NgModule()
    ], AlertServiceProvidersModule);
    return AlertServiceProvidersModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "TooltipComponent", {
    selector: 'se-tooltip',
    template: "\n        <fd-popover\n            [triggers]=\"triggers\"\n            [placement]=\"placement\"\n            [appendTo]=\"appendTo\"\n            [noArrow]=\"!isChevronVisible\"\n            [additionalClasses]=\"['se-tooltip-container']\"\n            [ngClass]=\"additionalClasses\"\n            class=\"se-tooltip\"\n        >\n            <fd-popover-control>\n                <ng-content select=\"[se-tooltip-trigger]\"></ng-content>\n            </fd-popover-control>\n            <fd-popover-body>\n                <div class=\"popover se-popover\">\n                    <h3 class=\"se-popover__title\" *ngIf=\"title\">{{ title | translate }}</h3>\n\n                    <div class=\"se-popover__content\">\n                        <ng-content select=\"[se-tooltip-body]\"></ng-content>\n                    </div>\n                </div>\n            </fd-popover-body>\n        </fd-popover>\n    "
});
/**
 * Used to display content in a popover after trigger is applied
 *
 * ### Example
 *
 *      <se-tooltip [triggers]="mouseover">
 *          <span se-tooltip-trigger>Hover me</span>
 *          <p se-tooltip-body>Content</p>
 *      </se-tooltip>
 */
var /* @ngInject */ TooltipComponent = /** @class */ (function () {
    function /* @ngInject */ TooltipComponent() {
    }
    /* @ngInject */ TooltipComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        // Ensures the tooltip position is set properly.
        //
        // For some components (such as PageDisplayStatusComponent), there is an issue with Popper.js (used by fundamental-ngx) which causes incorrect calculation of the position.
        // This is a temporary workaround which should be rechallenged when upgrading fundamental-ngx to the newer versions.
        this.popoverIsOpenChangeSubscription = this.popover.isOpenChange.subscribe(function (isOpen) {
            if (isOpen) {
                setTimeout(function () { return _this.popover.updatePopover(); });
            }
        });
    };
    /* @ngInject */ TooltipComponent.prototype.ngOnDestroy = function () {
        this.popoverIsOpenChangeSubscription.unsubscribe();
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ TooltipComponent.prototype, "triggers", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TooltipComponent.prototype, "placement", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TooltipComponent.prototype, "title", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TooltipComponent.prototype, "appendTo", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], /* @ngInject */ TooltipComponent.prototype, "isChevronVisible", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ TooltipComponent.prototype, "additionalClasses", void 0);
    __decorate([
        core.ViewChild(core$2.PopoverComponent, { static: false }),
        __metadata("design:type", core$2.PopoverComponent)
    ], /* @ngInject */ TooltipComponent.prototype, "popover", void 0);
    /* @ngInject */ TooltipComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-tooltip',
            template: "\n        <fd-popover\n            [triggers]=\"triggers\"\n            [placement]=\"placement\"\n            [appendTo]=\"appendTo\"\n            [noArrow]=\"!isChevronVisible\"\n            [additionalClasses]=\"['se-tooltip-container']\"\n            [ngClass]=\"additionalClasses\"\n            class=\"se-tooltip\"\n        >\n            <fd-popover-control>\n                <ng-content select=\"[se-tooltip-trigger]\"></ng-content>\n            </fd-popover-control>\n            <fd-popover-body>\n                <div class=\"popover se-popover\">\n                    <h3 class=\"se-popover__title\" *ngIf=\"title\">{{ title | translate }}</h3>\n\n                    <div class=\"se-popover__content\">\n                        <ng-content select=\"[se-tooltip-body]\"></ng-content>\n                    </div>\n                </div>\n            </fd-popover-body>\n        </fd-popover>\n    "
        })
    ], /* @ngInject */ TooltipComponent);
    return /* @ngInject */ TooltipComponent;
}());

var TooltipModule = /** @class */ (function () {
    function TooltipModule() {
    }
    TooltipModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, FundamentalsModule, utils.TranslationModule.forChild()],
            declarations: [TooltipComponent],
            entryComponents: [TooltipComponent],
            exports: [TooltipComponent]
        })
    ], TooltipModule);
    return TooltipModule;
}());

var TabsModule = /** @class */ (function () {
    function TabsModule() {
    }
    TabsModule = __decorate([
        core.NgModule({
            imports: [
                common.CommonModule,
                CompileHtmlModule,
                utils.SelectModule,
                TooltipModule,
                utils.TranslationModule.forChild()
            ],
            declarations: [TabsComponent, TabComponent],
            entryComponents: [TabsComponent, TabComponent],
            exports: [TabsComponent, TabComponent]
        })
    ], TabsModule);
    return TabsModule;
}());

var DATA_TABLE_COMPONENT_DATA = new core.InjectionToken('DATA_TABLE_COMPONENT_DATA');
window.__smartedit__.addDecoratorPayload("Component", "DataTableComponent", {
    selector: 'se-data-table',
    template: "<table class=\"se-paged-list-table fd-table\"><thead><tr><th *ngFor=\"let column of columns\" (click)=\"sortColumn(column)\" [ngStyle]=\"{'width.': columnWidth + '%'}\" [ngClass]=\"'se-paged-list__header-'+column.property\" class=\"se-paged-list__header\">{{ column.i18n | translate }} <span class=\"se-data-table__arrow\" *ngIf=\"visibleSortingHeader === column.property\" [ngClass]=\"{ \n                        'se-data-table__arrow--expanded sap-icon--navigation-down-arrow': headersSortingState[column.property],\n                        'se-data-table__arrow--not-expanded sap-icon--navigation-up-arrow': !headersSortingState[column.property] }\"></span></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of items; let i = index\" class=\"se-paged-list-item\"><td *ngFor=\"let column of columns\" [ngClass]=\"'se-paged-list-item-'+column.property\"><se-data-table-renderer [column]=\"column\" [item]=\"item\" [config]=\"config\" [index]=\"i\"></se-data-table-renderer></td></tr></tbody></table>"
});
var /* @ngInject */ DataTableComponent = /** @class */ (function () {
    function /* @ngInject */ DataTableComponent() {
        this.onSortColumn = new core.EventEmitter();
        this.headersSortingState = {};
    }
    /* @ngInject */ DataTableComponent.prototype.ngOnInit = function () {
        this._validateInput();
        this._configure();
    };
    /* @ngInject */ DataTableComponent.prototype.sortColumn = function (columnKey) {
        if (columnKey.sortable) {
            this.columnToggleReversed = !this.columnToggleReversed;
            this.headersSortingState[columnKey.property] = this.columnToggleReversed;
            this.visibleSortingHeader = columnKey.property;
            this.currentPage = 1;
            this.internalSortBy = columnKey.property;
            this.columnSortMode = this.columnToggleReversed
                ? exports.SortDirections.Descending
                : exports.SortDirections.Ascending;
            this.onSortColumn.emit({
                $columnKey: columnKey,
                $columnSortMode: this.columnSortMode
            });
        }
    };
    DataTableComponent.prototype.sortColumn.$inject = ["columnKey"];
    /* @ngInject */ DataTableComponent.prototype._configure = function () {
        var numberOfWidth = 100;
        this.columnWidth = numberOfWidth / this.columns.length;
        this.columnToggleReversed = this.sortStatus.reversed;
        this.columnSortMode = this.sortStatus.reversed
            ? exports.SortDirections.Descending
            : exports.SortDirections.Ascending;
        this.headersSortingState[this.sortStatus.internalSortBy] = this.config.reversed;
        this.visibleSortingHeader = this.sortStatus.internalSortBy;
    };
    /* @ngInject */ DataTableComponent.prototype._validateInput = function () {
        if (!Array.isArray(this.columns)) {
            throw new Error('Columns must be an array');
        }
        if (this.columns.some(function (column) { return !!column.renderer && !!column.component; })) {
            throw new Error('Columns must have either renderer or a component');
        }
        if (!(this.config instanceof Object)) {
            throw new Error('Config must be an object');
        }
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ DataTableComponent.prototype, "columns", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DataTableComponent.prototype, "config", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ DataTableComponent.prototype, "items", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DataTableComponent.prototype, "sortStatus", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ DataTableComponent.prototype, "onSortColumn", void 0);
    /* @ngInject */ DataTableComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-data-table',
            template: "<table class=\"se-paged-list-table fd-table\"><thead><tr><th *ngFor=\"let column of columns\" (click)=\"sortColumn(column)\" [ngStyle]=\"{'width.': columnWidth + '%'}\" [ngClass]=\"'se-paged-list__header-'+column.property\" class=\"se-paged-list__header\">{{ column.i18n | translate }} <span class=\"se-data-table__arrow\" *ngIf=\"visibleSortingHeader === column.property\" [ngClass]=\"{ \n                        'se-data-table__arrow--expanded sap-icon--navigation-down-arrow': headersSortingState[column.property],\n                        'se-data-table__arrow--not-expanded sap-icon--navigation-up-arrow': !headersSortingState[column.property] }\"></span></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of items; let i = index\" class=\"se-paged-list-item\"><td *ngFor=\"let column of columns\" [ngClass]=\"'se-paged-list-item-'+column.property\"><se-data-table-renderer [column]=\"column\" [item]=\"item\" [config]=\"config\" [index]=\"i\"></se-data-table-renderer></td></tr></tbody></table>"
        })
    ], /* @ngInject */ DataTableComponent);
    return /* @ngInject */ DataTableComponent;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
window.__smartedit__.addDecoratorPayload("Component", "DataTableRendererComponent", {
    selector: 'se-data-table-renderer',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: "\n        <div\n            *ngIf=\"column.renderer\"\n            [seCompileHtml]=\"column.renderer(item, column)\"\n            [compileHtmlNgController]=\"legacyController\"\n            [scope]=\"{ item: item, column: column, $index: index }\"\n        ></div>\n        <div *ngIf=\"!column.renderer && column.component\">\n            <ng-container\n                *ngComponentOutlet=\"column.component; injector: rendererInjector\"\n            ></ng-container>\n        </div>\n        <span *ngIf=\"!column.renderer && !column.component\">{{ item[column.property] }}</span>\n    "
});
var /* @ngInject */ DataTableRendererComponent = /** @class */ (function () {
    DataTableRendererComponent.$inject = ["injector"];
    function /* @ngInject */ DataTableRendererComponent(injector) {
        this.injector = injector;
    }
    /* @ngInject */ DataTableRendererComponent.prototype.ngOnInit = function () {
        this.setInjector();
    };
    /* @ngInject */ DataTableRendererComponent.prototype.ngOnChanges = function (changes) {
        if (changes.column || changes.item) {
            this.setInjector();
        }
        if (changes.config) {
            this.setLegacyController();
        }
    };
    DataTableRendererComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ DataTableRendererComponent.prototype.setLegacyController = function () {
        var config = this.config;
        this.legacyController = {
            alias: '$ctrl',
            value: /** @class */ (function () {
                function class_1() {
                    this.config = config;
                }
                return class_1;
            }())
        };
    };
    /* @ngInject */ DataTableRendererComponent.prototype.setInjector = function () {
        var _a = this, column = _a.column, item = _a.item;
        this.rendererInjector = core.Injector.create({
            providers: [
                {
                    provide: DATA_TABLE_COMPONENT_DATA,
                    useValue: { column: column, item: item }
                }
            ],
            parent: this.injector
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DataTableRendererComponent.prototype, "column", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DataTableRendererComponent.prototype, "item", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DataTableRendererComponent.prototype, "config", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ DataTableRendererComponent.prototype, "index", void 0);
    /* @ngInject */ DataTableRendererComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-data-table-renderer',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            template: "\n        <div\n            *ngIf=\"column.renderer\"\n            [seCompileHtml]=\"column.renderer(item, column)\"\n            [compileHtmlNgController]=\"legacyController\"\n            [scope]=\"{ item: item, column: column, $index: index }\"\n        ></div>\n        <div *ngIf=\"!column.renderer && column.component\">\n            <ng-container\n                *ngComponentOutlet=\"column.component; injector: rendererInjector\"\n            ></ng-container>\n        </div>\n        <span *ngIf=\"!column.renderer && !column.component\">{{ item[column.property] }}</span>\n    "
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], /* @ngInject */ DataTableRendererComponent);
    return /* @ngInject */ DataTableRendererComponent;
}());

/**
 * Directive responsible for evaluating and compiling HTML markup.
 *
 * ### Parameters
 *
 * `compile-html` - HTML string to be evaluated and compiled in the parent scope.
 *
 * ### Example
 *
 *      <div compile-html="<a data-ng-click=\"injectedContext.onLink( item.path )\">{{ item[key.property] }}</a>"></div>
 *
 */
var /* @ngInject */ CompileHtmlLegacyDirective = /** @class */ (function () {
    CompileHtmlLegacyDirective.$inject = ["$compile", "$scope", "$element", "$attrs"];
    function /* @ngInject */ CompileHtmlLegacyDirective($compile, $scope, $element, $attrs) {
        this.$compile = $compile;
        this.$scope = $scope;
        this.$element = $element;
        this.$attrs = $attrs;
    }
    /* @ngInject */ CompileHtmlLegacyDirective.prototype.$postLink = function () {
        var _this = this;
        this.$scope.$parent.$watch(function (scope) { return scope.$eval(_this.$attrs.compileHtml); }, function (value) {
            _this.$element.html(value);
            _this.$compile(_this.$element.contents())(_this.$scope.$parent);
        });
    };
    /* @ngInject */ CompileHtmlLegacyDirective = __decorate([
        SeDirective({
            selector: '[compile-html]'
        }),
        __metadata("design:paramtypes", [Function, Object, Object, Object])
    ], /* @ngInject */ CompileHtmlLegacyDirective);
    return /* @ngInject */ CompileHtmlLegacyDirective;
}());

/**
 *
 * The recompile dom directive accepts a function param, and can be applied to any part of the dom.
 * Upon execution of the function, the inner contents of this dom is recompiled by Angular.
 *
 * ### Parameters
 *
 * `recompileDom` - Function invoked from the outer scope to trigger the recompiling of the transcluded content.
 */
var /* @ngInject */ RecompileDomDirective = /** @class */ (function () {
    function /* @ngInject */ RecompileDomDirective() {
        this.showContent = true;
    }
    /* @ngInject */ RecompileDomDirective.prototype.$postLink = function () {
        var _this = this;
        this.recompileDom = function () {
            _this.showContent = false;
            setTimeout(function () {
                _this.showContent = true;
            }, 0);
        };
    };
    /* @ngInject */ RecompileDomDirective = __decorate([
        SeDirective({
            selector: '[recompile-dom]',
            replace: false,
            transclude: true,
            controllerAs: 'ctrl',
            template: "<div data-ng-if='ctrl.showContent' data-ng-transclude></div>",
            inputs: ['recompileDom:=']
        })
    ], /* @ngInject */ RecompileDomDirective);
    return /* @ngInject */ RecompileDomDirective;
}());

/**
 * Will cause an AngularJS re-compilation of the node declaring this directive whenever the page identifier in smartEdit layer changes.
 */
var /* @ngInject */ PageSensitiveDirective = /** @class */ (function () {
    PageSensitiveDirective.$inject = ["crossFrameEventService"];
    function /* @ngInject */ PageSensitiveDirective(crossFrameEventService) {
        this.crossFrameEventService = crossFrameEventService;
        this.hasContent = true;
    }
    /* @ngInject */ PageSensitiveDirective.prototype.$onInit = function () {
        var _this = this;
        this.unRegisterPageChangeListener = this.crossFrameEventService.subscribe(utils.EVENTS.PAGE_CHANGE, function () {
            _this.hasContent = false;
            setTimeout(function () {
                _this.hasContent = true;
            }, 0);
        });
    };
    /* @ngInject */ PageSensitiveDirective.prototype.$onDestroy = function () {
        this.unRegisterPageChangeListener();
    };
    /* @ngInject */ PageSensitiveDirective = __decorate([
        SeDirective({
            selector: 'page-sensitive',
            replace: false,
            transclude: true,
            template: "<div class='se-page-sensitive' data-ng-if='ctrl.hasContent' data-ng-transclude></div>",
            scope: true,
            controllerAs: 'ctrl'
        }),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ PageSensitiveDirective);
    return /* @ngInject */ PageSensitiveDirective;
}());

/**
 * **Deprecated since 2005, use {@link SelectComponent}.**
 *
 * This component is a wrapper around ui-select directive and provides filtering capabilities for the dropdown menu that is customizable with an item template.
 * <br/>ySelect can work in both paged and non paged mode: providing either fetchAll or fetchPage function in the fetchStrategy will determine the flavour of the dropdown.
 *
 * ### Parameters
 *
 * `id` - will be used to identify internal elements of ySelect for styling (and testing) purposes.
 *
 * `controls` - Adds controls such as the magnifier and the remove button. Default is set to false.
 *
 * `fetchStrategy` - strategy object containing the necessary functions for ySelect to populate the dropdown:
 * <b>Only one of either fetchAll or fetchPage must be defined.</b>
 *
 * `fetchStrategy.fetchAll` - Function required to fetch all for a given optional mask.
 * fetchAll will be called without arguments upon initialization and with a mask every time the search section receives an input.
 * It must return a promise resolving to a list of items.
 * Every item must have a property "id" used for identification. If no itemTemplate is provided, these items will need to display a "label" property.
 *
 * `fetchStrategy.fetchPage` - Function required to fetch a page for a given optional mask.
 * fetchPage must fulfill the contract of fetchPage from {@link YInfiniteScrollingComponent}
 * It must return a promise resolving to a page of items as per `Page`.
 * Every item must have a property "id" used for identification. If no itemTemplate is provided, these items will need to display a "label" property.
 *
 * `fetchStrategy.fetchEntity` - Function to fetch an option by its identifier when we are in paged mode (fetchPage is defined) and the dropdown is initialized with a value.
 *
 * `disableChoiceFn` - A function to disable results in the drop-down. It is invoked for each item in the drop-down, with a single parameter, the item itself.
 *
 * `placeholder` - the placeholder label or i18nKey that will be printed in the search section.
 *
 * `itemTemplate` - the path to the template that will be used to display items in both the dropdown menu and the selection.
 * ItemTemplate has access to item, selected and the ySelect controller.
 * item is the item to print, selected is a boolean that is true when the template is used in the selection as opposed to the dropdown menu.
 * Default template will be:
 *
 *      <span data-ng-bind-html="item.label | translate"></span>
 *
 *
 * `keepModelOnReset` - A non-paged dropdown: if the value is set to false, the widget will remove the selected entities in the model that no longer match the values available on the server.
 * For a paged dropdown: After a standard reset, even if keepModelOnReset is set to false,  the widget will not be able to remove the selected entities in the model
 * that no longer match the values available on the server. to force the widget to remove any selected entities, you must call reset(true).
 *
 * `multiSelect` - The property specifies whether ySelect is multi-selectable.
 *
 * `reset` - A function that will be called when ySelect is reset.
 *
 * `isReadOnly` - Renders ySelect as disabled field.
 *
 * `resultsHeaderTemplate` - The template that will be used on top of the result list.
 *
 * `resultsHeaderTemplateUrl` - The path to the template what will be used on top of the result list.
 *
 * `resultsHeaderLabel` - The label that will be displayed on top of the result list.
 * Only one of resultsHeaderTemplate, resultsHeaderTemplateUtl, and resultsHeaderLabel shall be passed.
 *
 * `resetSearchInput` - Clears the search box after selecting an option.
 *
 * `onRemove` - A function that will be called when item was removed from selection, function is called with two arguments $item and $model
 *
 * `onSelect` - A function that will be called when item was selected, function is called with two arguments $item and $model
 *
 * `init` - A function that will be called when component is initialized, function is called with one argument $select
 *
 * `keyup` - A function that will be called on keyup event in search input, function is called with two arguments $event and $select.search
 *
 * `getApi` - Exposes the ySelect's api object. See {@link YSelectApi} for more information.
 *
 * `showRemoveButton` -  Adds remove button
 *
 * @deprecated
 */
var /* @ngInject */ YSelectComponent = /** @class */ (function () {
    YSelectComponent.$inject = ["logService", "$templateCache"];
    function /* @ngInject */ YSelectComponent(logService, $templateCache) {
        var _this = this;
        this.logService = logService;
        this.$templateCache = $templateCache;
        this.resultsHeaderLabel = 'se.yselect.options.inactiveoption.label';
        this.api = {
            setValidationState: function (validationState) {
                _this.validationState = validationState;
            },
            resetValidationState: function () {
                _this.validationState = undefined;
            }
        };
    }
    // Initialization
    /* @ngInject */ YSelectComponent.prototype.$onInit = function () {
        var _this = this;
        // this.items represent the options available in the control to choose from.
        // this.model represents the item(s) currently selected in the control. If the control is using the multiSelect
        // flag then the model is an array; otherwise it's a single object.
        this.items = [];
        this.searchEnabled = this.searchEnabled !== false;
        this.resetSearchInput = this.resetSearchInput !== false;
        // in order to propagate down changes to ngModel from the parent controller
        this.exposedModel.$viewChangeListeners.push(function () { return _this.syncModels(); });
        this.exposedModel.$render = function () { return _this.syncModels(); };
        this.reset = function (forceReset) {
            _this.items.length = 0;
            if (forceReset) {
                _this.resetModel();
            }
            return _this.$onChanges();
        };
        if (typeof this.getApi === 'function') {
            this.getApi({
                $api: this.api
            });
        }
    };
    /* @ngInject */ YSelectComponent.prototype.$onChanges = function (changes) {
        var result = Promise.resolve(null);
        this.isValidConfiguration();
        this.updateControlTemplate();
        /* we must initialize the list to contain at least the selected item
         * if a fetchEntity has been provided, it will be used
         * if no fetchEntity was provided, we resort to finding a match in the result from fetchAll
         * if we fail to find a match, the directive throws an error to notify that a fetchEntity is required
         */
        if (!this.items || this.items.length === 0) {
            if (!this.isPagedDropdown()) {
                result = this.internalFetchAll();
            }
            else if (this.fetchStrategy.fetchEntity || this.fetchStrategy.fetchEntities) {
                if (!this.isModelEmpty()) {
                    result = this.internalFetchEntities();
                }
            }
            else {
                throw new Error('could not initialize dropdown of ySelect, neither fetchEntity, fetchEntities, nor fetchAll were specified');
            }
        }
        if (changes && changes.fetchStrategy) {
            this._updateChild();
        }
        return result;
    };
    YSelectComponent.prototype.$onChanges.$inject = ["changes"];
    // Event Listeners
    /*
     * This function is called whenever the value in the ui-select changes from an external source (e.g., like
     * the user making a selection).
     * NOTE: This is not triggered if the model is changed programatically.
     */
    /* @ngInject */ YSelectComponent.prototype.syncModels = function () {
        this.model = this.exposedModel.$modelValue;
        this.$onChanges();
        this.internalOnChange();
    };
    /* @ngInject */ YSelectComponent.prototype.clear = function ($select, $event) {
        $event.preventDefault();
        $event.stopPropagation();
        delete this.model;
        this.internalOnChange();
    };
    YSelectComponent.prototype.clear.$inject = ["$select", "$event"];
    /* @ngInject */ YSelectComponent.prototype.showResultHeader = function () {
        return this.searchEnabled && this.items && this.items.length > 0;
    };
    /* @ngInject */ YSelectComponent.prototype.getActionableTemplateUrl = function () {
        return this.actionableSearchItemTemplateConfig
            ? this.actionableSearchItemTemplateConfig.templateUrl
            : '';
    };
    // in case of paged dropdown, the triggering of refresh is handled by yInfiniteScrolling component part of the pagedSelect2/choices.tpl.html template
    /* @ngInject */ YSelectComponent.prototype.refreshOptions = function (mask) {
        var _this = this;
        if (this.fetchStrategy.fetchAll) {
            this.fetchStrategy.fetchAll(mask).then(function (items) {
                if (angular$1.toJson(_this.items) !== angular$1.toJson(items)) {
                    _this.items = items;
                }
            });
        }
    };
    YSelectComponent.prototype.refreshOptions.$inject = ["mask"];
    /* @ngInject */ YSelectComponent.prototype.internalOnRemove = function (item, model) {
        if (this.onRemove) {
            this.onRemove(item, model);
        }
    };
    YSelectComponent.prototype.internalOnRemove.$inject = ["item", "model"];
    /* @ngInject */ YSelectComponent.prototype.internalOnSelect = function (item, model) {
        if (this.onSelect) {
            this.onSelect(item, model);
        }
    };
    YSelectComponent.prototype.internalOnSelect.$inject = ["item", "model"];
    /* @ngInject */ YSelectComponent.prototype.internalInit = function (select) {
        if (this.init) {
            this.init(select);
        }
        // This is a workaround for ui-select directive input removing selected entries
        // on DELETE or BACKSPACE key pressed
        select.searchInput.on('keydown', function (event) {
            if (event.key === 'Backspace' || event.key === 'Delete') {
                event.stopImmediatePropagation();
            }
        });
    };
    YSelectComponent.prototype.internalInit.$inject = ["select"];
    /* @ngInject */ YSelectComponent.prototype.internalKeyup = function (event, selectSearch) {
        if (this.keyup) {
            this.keyup(event, selectSearch);
        }
    };
    YSelectComponent.prototype.internalKeyup.$inject = ["event", "selectSearch"];
    /*
     * This method is used to propagate to the parent controller the changes made to the model programatically inside
     * this component.
     */
    /* @ngInject */ YSelectComponent.prototype.internalOnChange = function () {
        // in order to propagate up changes to ngModel into parent controller
        this.exposedModel.$setViewValue(this.model);
        if (this.onChange) {
            this.onChange();
        }
    };
    /* @ngInject */ YSelectComponent.prototype.internalFetchAll = function () {
        var _this = this;
        return this.fetchStrategy.fetchAll().then(function (items) {
            _this.items = items;
            if (_this.model) {
                var result = _this.multiSelect
                    ? _this.model.every(function (key) { return !!_this.items.find(function (item) { return item.id === key; }); })
                    : items.find(function (item) { return item.id === _this.model; });
                if (!result) {
                    _this.logService.debug('[ySelect - ' +
                        _this.id +
                        '] fetchAll was used to fetch the option identified by ' +
                        _this.model +
                        ' but failed to find a match');
                }
                _this.updateModelIfNecessary();
            }
            _this.internalOnChange();
        });
    };
    /* @ngInject */ YSelectComponent.prototype.internalFetchEntities = function () {
        var _this = this;
        var promise;
        if (!this.multiSelect) {
            promise = this.fetchEntity(this.model).then(function (item) { return [item]; });
        }
        else {
            if (this.fetchStrategy.fetchEntities) {
                promise = this.fetchStrategy.fetchEntities(this.model).then(function (items) {
                    if (items.length !== _this.model.length) {
                        _this.logService.debug('!fetchEntities was used to fetch the options identified by ' +
                            _this.model +
                            ' but failed to find all matches');
                    }
                    return items;
                });
            }
            else {
                var promiseArray = this.model.map(function (entryId) {
                    return _this.fetchEntity(entryId);
                });
                promise = Promise.all(promiseArray);
            }
        }
        return promise.then(function (result) {
            _this.items = result
                .filter(function (item) { return item !== null; })
                .map(function (item) {
                delete item.$promise;
                delete item.$resolved;
                item.technicalUniqueId = stringUtils.encode(item);
                return item;
            });
            _this.updateModelIfNecessary();
            _this.internalOnChange();
        });
    };
    /* @ngInject */ YSelectComponent.prototype.fetchEntity = function (entryId) {
        var _this = this;
        return this.fetchStrategy.fetchEntity(entryId).then(function (item) {
            if (!item) {
                _this.logService.debug('fetchEntity was used to fetch the option identified by ' +
                    item +
                    ' but failed to find a match');
            }
            return item;
        });
    };
    YSelectComponent.prototype.fetchEntity.$inject = ["entryId"];
    /* @ngInject */ YSelectComponent.prototype.updateModelIfNecessary = function () {
        var _this = this;
        if (!this.keepModelOnReset) {
            if (this.multiSelect) {
                this.model = this.model.filter(function (modelKey) {
                    return _this.items.find(function (item) { return item && item.id === modelKey; });
                });
            }
            else {
                var result = this.items.filter(function (item) { return item.id === _this.model; });
                this.model = result.length > 0 ? this.model : null;
            }
        }
    };
    // Helper functions
    /* @ngInject */ YSelectComponent.prototype.isValidConfiguration = function () {
        if (!this.fetchStrategy.fetchAll && !this.fetchStrategy.fetchPage) {
            throw new Error('neither fetchAll nor fetchPage have been specified in fetchStrategy');
        }
        if (this.fetchStrategy.fetchAll && this.fetchStrategy.fetchPage) {
            throw new Error('only one of either fetchAll or fetchPage must be specified in fetchStrategy');
        }
        if (this.fetchStrategy.fetchPage &&
            this.model &&
            !this.fetchStrategy.fetchEntity &&
            !this.fetchStrategy.fetchEntities) {
            throw new Error("fetchPage has been specified in fetchStrategy but neither fetchEntity nor fetchEntities are available to load item identified by " + this.model);
        }
        if (this.isPagedDropdown() && !this.keepModelOnReset) {
            this.logService.debug('current ySelect is paged, so keepModelOnReset flag is ignored (it will always keep the model on reset).');
        }
    };
    /* @ngInject */ YSelectComponent.prototype.requiresPaginatedStyling = function () {
        return this.isPagedDropdown() || this.hasControls();
    };
    /* @ngInject */ YSelectComponent.prototype.hasError = function () {
        return VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR === this.validationState;
    };
    /* @ngInject */ YSelectComponent.prototype.hasWarning = function () {
        return VALIDATION_MESSAGE_TYPES.WARNING === this.validationState;
    };
    /* @ngInject */ YSelectComponent.prototype.hasControls = function () {
        return (this.controls || false) === true;
    };
    /* @ngInject */ YSelectComponent.prototype.disableChoice = function (item) {
        if (this.disableChoiceFn) {
            return this.disableChoiceFn(item);
        }
        return false;
    };
    YSelectComponent.prototype.disableChoice.$inject = ["item"];
    /* @ngInject */ YSelectComponent.prototype.isPagedDropdown = function () {
        return !!this.fetchStrategy.fetchPage;
    };
    /* @ngInject */ YSelectComponent.prototype.resetModel = function () {
        if (this.multiSelect) {
            this.model.length = 0;
        }
        else {
            delete this.model;
        }
    };
    /* @ngInject */ YSelectComponent.prototype.updateControlTemplate = function () {
        this.theme = this.isPagedDropdown() ? 'pagedSelect2' : 'select2';
        this.itemTemplate = this.itemTemplate || 'defaultItemTemplate.html';
    };
    /* @ngInject */ YSelectComponent.prototype.isModelEmpty = function () {
        if (this.multiSelect) {
            return !this.model || (this.model && this.model.length === 0);
        }
        else {
            return !this.model;
        }
    };
    /* @ngInject */ YSelectComponent.prototype._updateChild = function () {
        var ySelectTemplate = 'ySelectTemplate.html';
        var yMultiSelectTemplate = 'yMultiSelectTemplate.html';
        var theme = !this.fetchStrategy.fetchPage ? 'select2' : 'pagedSelect2';
        var selectedFilters = !this.fetchStrategy.fetchPage
            ? 'repeat="item.id as item in $ctrl.items | filter: $select.search" refresh="$ctrl.refreshOptions($select.search)"'
            : 'repeat="item.id as item in $ctrl.items"';
        var rawTemplate = this.$templateCache.get(this.multiSelect ? yMultiSelectTemplate : ySelectTemplate);
        this.result = rawTemplate
            .replace('<%= theme %>', theme)
            .replace('{% filtering %}', selectedFilters);
    };
    /* @ngInject */ YSelectComponent = __decorate([
        SeComponent({
            template: "<div data-compile-html='$ctrl.result'></div>",
            transclude: true,
            require: {
                exposedModel: 'ngModel'
            },
            inputs: [
                'id:@',
                'fetchStrategy',
                'onChange',
                'controls',
                'multiSelect',
                'keepModelOnReset',
                'reset:=?',
                'isReadOnly',
                'resultsHeaderTemplate',
                'resultsHeaderTemplateUrl',
                'resultsHeaderLabel',
                'disableChoiceFn',
                'placeholder',
                'itemTemplate',
                'searchEnabled',
                'resetSearchInput',
                'onRemove',
                'onSelect',
                'init',
                'keyup',
                'showRemoveButton',
                'getApi:&'
            ]
        }),
        __metadata("design:paramtypes", [utils.LogService, Object])
    ], /* @ngInject */ YSelectComponent);
    return /* @ngInject */ YSelectComponent;
}());

/** @internal */
var /* @ngInject */ ItemPrinterComponent$1 = /** @class */ (function () {
    ItemPrinterComponent.$inject = ["$scope"];
    function /* @ngInject */ ItemPrinterComponent($scope) {
        var _this = this;
        this.$scope = $scope;
        this.$onChanges = function () {
            /* needs to bind it scope and not controller in order for the templates required by API
             * to be agnostic of whether they are invoked within ui-select-coices or ui-select-match of ui-select
             */
            _this.$scope.item = _this.model;
            _this.$scope.ySelect = _this.ySelect;
        };
        this.$scope.selected = true;
    }
    /* @ngInject */ ItemPrinterComponent = __decorate([
        SeComponent({
            selector: 'item-printer',
            template: "<div class=\"se-item-printer\" ng-include=\"$ctrl.templateUrl\"></div>",
            replace: false,
            transclude: false,
            inputs: ['templateUrl', 'model'],
            require: {
                ySelect: '^ySelect'
            }
        }),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ ItemPrinterComponent);
    return /* @ngInject */ ItemPrinterComponent;
}());

/**
 * The yActionableSearchItem Angular component is designed to work with the ySelect drop down. It allows you to add
 * a button in the resultsHeader area of the ySelect's drop-down, and trigger a user-defined action when pressed.
 *
 * ### Parameters
 *
 * `eventId='yActionableSearchItem_ACTION_CREATE'` - The event ID that is triggered on the
 * systemEventService when the button is pressed
 *
 * `actionText='se.yationablesearchitem.action.create'` - The i18n key label for the button
 *
 * @deprecated
 */
var /* @ngInject */ ActionableSearchItemComponent$1 = /** @class */ (function () {
    ActionableSearchItemComponent.$inject = ["systemEventService"];
    function /* @ngInject */ ActionableSearchItemComponent(systemEventService) {
        this.systemEventService = systemEventService;
        this.defaultEventId = 'yActionableSearchItem_ACTION_CREATE';
        this.defaultActionText = 'se.yationablesearchitem.action.create';
    }
    /* @ngInject */ ActionableSearchItemComponent.prototype.getActionText = function () {
        return this.actionText || this.defaultActionText;
    };
    /* @ngInject */ ActionableSearchItemComponent.prototype.showForm = function () {
        return this.uiSelect && this.uiSelect.search && this.uiSelect.search.length > 0;
    };
    /* @ngInject */ ActionableSearchItemComponent.prototype.getInputText = function () {
        return this.uiSelect.search;
    };
    /* @ngInject */ ActionableSearchItemComponent.prototype.buttonPressed = function () {
        var evtId = this.eventId || this.defaultEventId;
        this.systemEventService.publishAsync(evtId, this.uiSelect.search || '');
        this.uiSelect.close();
    };
    /* @ngInject */ ActionableSearchItemComponent = __decorate([
        SeComponent({
            selector: 'y-actionable-search-item',
            templateUrl: 'yActionableSearchItemTemplate.html',
            require: {
                ySelect: '^ySelect',
                uiSelect: '^uiSelect'
            },
            inputs: ['eventId:@?', 'actionText:@?']
        }),
        __metadata("design:paramtypes", [SystemEventService])
    ], /* @ngInject */ ActionableSearchItemComponent);
    return /* @ngInject */ ActionableSearchItemComponent;
}());

/**
 * **Deprecated since 2005, use {@link SelectModule}**
 *
 * @deprecated
 */
var /* @ngInject */ YSelectModule = /** @class */ (function () {
    function /* @ngInject */ YSelectModule() {
    }
    /* @ngInject */ YSelectModule = __decorate([
        SeModule({
            imports: [
                'legacySmarteditCommonsModule',
                'functionsModule',
                'ui.select',
                'ngSanitize',
                'coretemplates',
                'l10nModule',
                'seConstantsModule'
            ],
            declarations: [YSelectComponent, ItemPrinterComponent$1, ActionableSearchItemComponent$1],
            initialize: ["$templateCache", function ($templateCache) {
                'ngInject';
                // This fixes an issue with the multi-select. It will allow displaying the 'CREATE' button if no results are displayed.
                $templateCache.put('select2/select-multiple.tpl.html', $templateCache
                    .get('select2/select-multiple.tpl.html')
                    .replace("{'select2-display-none': !$select.open || $select.items.length === 0}", "{'select2-display-none': !$select.open }"));
                // placeholder for search input field.
                $templateCache.put('select2/select-multiple.tpl.html', $templateCache
                    .get('select2/select-multiple.tpl.html')
                    .replace('placeholder="{{$selectMultiple.getPlaceholder()}}"', 'placeholder="{{$select.placeholder}}"'));
                $templateCache.put('select2/select.tpl.html', $templateCache
                    .get('select2/select.tpl.html')
                    .replace('<input type="search"', '<input type="search" placeholder="{{$select.isEmpty() ? null : $select.placeholder}}"'));
                // Prevents AngularJS from adding 'unsafe:javascript' to the href value which triggers safari to go to a blank page.
                $templateCache.put('select2/match-multiple.tpl.html', $templateCache
                    .get('select2/match-multiple.tpl.html')
                    .replace('href="javascript:;"', ''));
                // use a copy of select2
                $templateCache.put('pagedSelect2/match-multiple.tpl.html', $templateCache.get('select2/match-multiple.tpl.html'));
                $templateCache.put('pagedSelect2/match.tpl.html', $templateCache.get('select2/match.tpl.html'));
                $templateCache.put('pagedSelect2/no-choice.tpl.html', $templateCache.get('select2/no-choice.tpl.html'));
                $templateCache.put('pagedSelect2/select-multiple.tpl.html', $templateCache.get('select2/select-multiple.tpl.html'));
                $templateCache.put('pagedSelect2/select.tpl.html', $templateCache.get('select2/select.tpl.html'));
                // our own flavor of select2 for paging that makes use of yInfiniteScrolling component
                $templateCache.put('pagedSelect2/choices.tpl.html', $templateCache.get('uiSelectPagedChoicesTemplate.html'));
                $templateCache.put('select2/choices.tpl.html', $templateCache.get('uiSelectChoicesTemplate.html'));
            }]
        })
    ], /* @ngInject */ YSelectModule);
    return /* @ngInject */ YSelectModule;
}());

var /* @ngInject */ IncludeReplaceDirective = /** @class */ (function () {
    IncludeReplaceDirective.$inject = ["$element"];
    function /* @ngInject */ IncludeReplaceDirective($element) {
        this.$element = $element;
    }
    /* @ngInject */ IncludeReplaceDirective.prototype.$postLink = function () {
        this.$element.replaceWith(this.$element.children());
    };
    /* @ngInject */ IncludeReplaceDirective = __decorate([
        SeDirective({
            selector: '[include-replace]',
            require: 'ngInclude'
        }),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ IncludeReplaceDirective);
    return /* @ngInject */ IncludeReplaceDirective;
}());

/**
 * Used to listen to ElementRef resize event.
 *
 * It emits an event once the {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}
 * detects the change.
 *
 * ### Example
 *
 *      <my-custom-component seResizeObserver (onResize)="handleResize()"></my-custom-component>
 */
var ResizeObserverDirective = /** @class */ (function () {
    function ResizeObserverDirective(elementRef) {
        this.elementRef = elementRef;
        this.onResize = new core.EventEmitter();
    }
    ResizeObserverDirective.prototype.ngOnInit = function () {
        this.startWatching();
    };
    ResizeObserverDirective.prototype.ngOnDestroy = function () {
        this.observer.disconnect();
    };
    ResizeObserverDirective.prototype.startWatching = function () {
        var _this = this;
        this.observer = new ResizeObserver(function (entries) {
            return _this.internalOnResize(entries);
        });
        this.observer.observe(this.elementRef.nativeElement);
    };
    ResizeObserverDirective.prototype.internalOnResize = function (entries) {
        this.onResize.emit();
    };
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], ResizeObserverDirective.prototype, "onResize", void 0);
    ResizeObserverDirective = __decorate([
        core.Directive({
            selector: '[seResizeObserver]'
        }),
        __metadata("design:paramtypes", [core.ElementRef])
    ], ResizeObserverDirective);
    return ResizeObserverDirective;
}());

var ResizeObserverModule = /** @class */ (function () {
    function ResizeObserverModule() {
    }
    ResizeObserverModule = __decorate([
        core.NgModule({
            declarations: [ResizeObserverDirective],
            exports: [ResizeObserverDirective]
        })
    ], ResizeObserverModule);
    return ResizeObserverModule;
}());

/** @ignore */
var HasOperationPermissionBaseDirective = /** @class */ (function () {
    function HasOperationPermissionBaseDirective(systemEventService, permissionService, logService) {
        this.systemEventService = systemEventService;
        this.permissionService = permissionService;
        this.logService = logService;
    }
    HasOperationPermissionBaseDirective.prototype.ngOnInit = function () {
        // NOTE: Refreshing permission checking should only be done after permissions have been cleaned
        // (PERMISSION_CACHE_CLEANED). If this is done as soon after user is changed (USER_CHANGED) then there's a race
        // condition between when the cache is cleaned and when this permission checking is executed.
        this.unregisterHandler = this.systemEventService.subscribe(utils.EVENTS.PERMISSION_CACHE_CLEANED, this.refreshIsPermissionGranted.bind(this));
    };
    HasOperationPermissionBaseDirective.prototype.ngOnDestroy = function () {
        this.unregisterHandler();
    };
    HasOperationPermissionBaseDirective.prototype.ngOnChanges = function (changes) {
        if (changes.hasOperationPermission && changes.hasOperationPermission.currentValue) {
            this.permission = changes.hasOperationPermission.currentValue;
            this.refreshIsPermissionGranted();
        }
    };
    Object.defineProperty(HasOperationPermissionBaseDirective.prototype, "isPermissionGrantedHandler", {
        set: function (handler) {
            this._isPermissionGrantedHandler = handler;
        },
        enumerable: false,
        configurable: true
    });
    HasOperationPermissionBaseDirective.prototype.refreshIsPermissionGranted = function () {
        var _this = this;
        this.isPermissionGranted(this.permission).then(function (isPermissionGranted) {
            _this._isPermissionGrantedHandler(isPermissionGranted);
        });
    };
    HasOperationPermissionBaseDirective.prototype.isPermissionGranted = function (permission) {
        var _this = this;
        return this.permissionService
            .isPermitted(this.validateAndPreparePermissions(permission))
            .then(function (isPermissionGranted) { return isPermissionGranted; }, function (error) {
            _this.logService.error('Failed to retrieve authorization', error);
            return false;
        })
            .then(function (isPermissionGranted) { return isPermissionGranted; });
    };
    HasOperationPermissionBaseDirective.prototype.validateAndPreparePermissions = function (permissions) {
        if (typeof permissions !== 'string' && !Array.isArray(permissions)) {
            throw new Error('Permission should be string or an array of objects');
        }
        return typeof permissions === 'string' ? this.toPermissions(permissions) : permissions;
    };
    HasOperationPermissionBaseDirective.prototype.toPermissions = function (permissions) {
        return [{ names: permissions.split(',') }];
    };
    return HasOperationPermissionBaseDirective;
}());

/**
 * An Authorization structural directive that conditionally will remove elements from the DOM if the user does not have authorization defined
 * by the input parameter permission keys.
 *
 * This directive makes use of the {@link IPermissionService} service to validate
 * if the current user has access to the given permission set.
 *
 * It takes a comma-separated list of permission names or an array of permission name objects structured as follows:
 *
 * ### Example
 *
 * 1. String
 * 'se-edit-page'
 *
 * 2. Object
 *
 *          {
 *              names: ["permission1", "permission2"],
 *              context: {
 *                  data: "with the context property, extra data can be included to check a permission when the Rule.verify function is called"
 *              }
 *          }
 */
var HasOperationPermissionDirective = /** @class */ (function (_super) {
    __extends(HasOperationPermissionDirective, _super);
    function HasOperationPermissionDirective(templateRef, viewContainerRef, systemEventService, permissionService, logService, cdr) {
        var _this = _super.call(this, systemEventService, permissionService, logService) || this;
        _this.templateRef = templateRef;
        _this.viewContainerRef = viewContainerRef;
        _this.cdr = cdr;
        _this.hasView = false;
        _this.isPermissionGrantedHandler = _this.getIsPermissionGrantedHandler();
        return _this;
    }
    HasOperationPermissionDirective.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    HasOperationPermissionDirective.prototype.ngOnChanges = function (changes) {
        _super.prototype.ngOnChanges.call(this, {
            hasOperationPermission: new core.SimpleChange(changes.seHasOperationPermission.previousValue, changes.seHasOperationPermission.currentValue, changes.seHasOperationPermission.firstChange)
        });
    };
    HasOperationPermissionDirective.prototype.ngOnDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    HasOperationPermissionDirective.prototype.getIsPermissionGrantedHandler = function () {
        var _this = this;
        return function (isPermissionGranted) {
            _this.updateView(isPermissionGranted);
        };
    };
    HasOperationPermissionDirective.prototype.updateView = function (isPermissionGranted) {
        if (isPermissionGranted && !this.hasView) {
            this.viewContainerRef.createEmbeddedView(this.templateRef);
            this.hasView = true;
        }
        else if (!isPermissionGranted && this.hasView) {
            this.viewContainerRef.clear();
        }
        this.cdr.markForCheck();
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], HasOperationPermissionDirective.prototype, "seHasOperationPermission", void 0);
    HasOperationPermissionDirective = __decorate([
        core.Directive({ selector: '[seHasOperationPermission]' }),
        __param(3, core.Inject(IPermissionService)),
        __metadata("design:paramtypes", [core.TemplateRef,
            core.ViewContainerRef,
            SystemEventService,
            IPermissionService,
            utils.LogService,
            core.ChangeDetectorRef])
    ], HasOperationPermissionDirective);
    return HasOperationPermissionDirective;
}(HasOperationPermissionBaseDirective));

var HasOperationPermissionDirectiveModule = /** @class */ (function () {
    function HasOperationPermissionDirectiveModule() {
    }
    HasOperationPermissionDirectiveModule = __decorate([
        core.NgModule({
            declarations: [HasOperationPermissionDirective],
            exports: [HasOperationPermissionDirective]
        })
    ], HasOperationPermissionDirectiveModule);
    return HasOperationPermissionDirectiveModule;
}());

var ClickOutsideDirective = /** @class */ (function () {
    function ClickOutsideDirective(host, iframeClickDetectionService) {
        this.host = host;
        this.iframeClickDetectionService = iframeClickDetectionService;
        this.clickOutside = new core.EventEmitter();
        this.id = "clickOutsideIframeClick" + stringUtils.generateIdentifier();
    }
    ClickOutsideDirective.prototype.onDocumentClick = function (target) {
        if (target === this.host.nativeElement || this.host.nativeElement.contains(target)) {
            return;
        }
        this.clickOutside.emit();
    };
    ClickOutsideDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.iframeClickDetectionService.registerCallback(this.id, function () { return _this.onOutsideClick(); });
    };
    ClickOutsideDirective.prototype.ngOnDestroy = function () {
        this.iframeClickDetectionService.removeCallback(this.id);
    };
    ClickOutsideDirective.prototype.onOutsideClick = function () {
        this.clickOutside.emit();
    };
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], ClickOutsideDirective.prototype, "clickOutside", void 0);
    __decorate([
        core.HostListener('document:click', ['$event.target']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [HTMLElement]),
        __metadata("design:returntype", void 0)
    ], ClickOutsideDirective.prototype, "onDocumentClick", null);
    ClickOutsideDirective = __decorate([
        core.Directive({
            selector: '[seClickOutside]'
        }),
        __metadata("design:paramtypes", [core.ElementRef,
            IIframeClickDetectionService])
    ], ClickOutsideDirective);
    return ClickOutsideDirective;
}());

var ClickOutsideModule = /** @class */ (function () {
    function ClickOutsideModule() {
    }
    ClickOutsideModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule],
            declarations: [ClickOutsideDirective],
            exports: [ClickOutsideDirective]
        })
    ], ClickOutsideModule);
    return ClickOutsideModule;
}());

/**
 * @ignore
 *
 * Used for rendering dynamic components decorated with {@link SeCustomComponent}.
 * It is meant for configurations that requires component to be sent through {@link MessageGateway} in postMessage payload.
 * Instead `component` use `componentName` as a configuration parameter.
 *
 * Due to {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage postMessageApi},
 * component class / constructor function, cannot be sent through postMessage (it is removed).
 *
 * Note: Component must be also registered in @NgModule entryComponents array.
 *
 * ### Example
 *
 *
 *      \@SeCustomComponent()
 *      \@Component({
 *          selector: 'se-my-custom-component',
 *          templateUrl: './SeMyComponent.html'
 *      })
 *      export class MyCustomComponent {}
 *
 *      \@Component({
 *          selector: 'se-my-container',
 *          template: `<div [seCustomComponentOutlet]="'MyCustomComponent'"></div>`
 *      })
 *      export class MyContainer {}
 *
 *      \@NgModule({
 *          imports: [CustomComponentOutletDirectiveModule]
 *          declarations: [MyContainer, MyCustomComponent],
 *          entryComponents: [MyContainer, MyCustomComponent]
 *      })
 *      export class MyModule {}
 *
 */
var CustomComponentOutletDirective = /** @class */ (function () {
    function CustomComponentOutletDirective(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.hasView = false;
    }
    CustomComponentOutletDirective.prototype.ngOnChanges = function () {
        this.updateView(this.componentName);
    };
    CustomComponentOutletDirective.prototype.updateView = function (componentName) {
        if (componentName && !this.hasView) {
            this.createView();
        }
        else if (!componentName && this.hasView) {
            this.removeView();
        }
        else if (componentName && this.hasView) {
            this.removeView();
            this.createView();
        }
    };
    CustomComponentOutletDirective.prototype.createView = function () {
        var componentMetadata = window.__smartedit__.getComponentDecoratorPayload(this.componentName);
        this.component = this.renderer.createElement(componentMetadata.selector);
        this.renderer.appendChild(this.elementRef.nativeElement, this.component);
        this.hasView = true;
    };
    CustomComponentOutletDirective.prototype.removeView = function () {
        this.renderer.removeChild(this.elementRef.nativeElement, this.component);
        this.hasView = false;
    };
    __decorate([
        core.Input('seCustomComponentOutlet'),
        __metadata("design:type", String)
    ], CustomComponentOutletDirective.prototype, "componentName", void 0);
    CustomComponentOutletDirective = __decorate([
        core.Directive({
            selector: '[seCustomComponentOutlet]'
        }),
        __metadata("design:paramtypes", [core.ElementRef, core.Renderer2])
    ], CustomComponentOutletDirective);
    return CustomComponentOutletDirective;
}());

/** @ignore */
var CustomComponentOutletDirectiveModule = /** @class */ (function () {
    function CustomComponentOutletDirectiveModule() {
    }
    CustomComponentOutletDirectiveModule = __decorate([
        core.NgModule({
            declarations: [CustomComponentOutletDirective],
            exports: [CustomComponentOutletDirective]
        })
    ], CustomComponentOutletDirectiveModule);
    return CustomComponentOutletDirectiveModule;
}());

var DataTableModule = /** @class */ (function () {
    function DataTableModule() {
    }
    DataTableModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, utils.TranslationModule.forChild(), CompileHtmlModule],
            declarations: [DataTableComponent, DataTableRendererComponent],
            entryComponents: [DataTableComponent, DataTableRendererComponent],
            exports: [DataTableComponent, DataTableRendererComponent]
        })
    ], DataTableModule);
    return DataTableModule;
}());

/**
 * **Deprecated since 2005, use {@link DropdownMenuComponent}.**
 */
var /* @ngInject */ YDropDownMenuComponent = /** @class */ (function () {
    YDropDownMenuComponent.$inject = ["$templateCache"];
    function /* @ngInject */ YDropDownMenuComponent($templateCache) {
        this.$templateCache = $templateCache;
    }
    /* @ngInject */ YDropDownMenuComponent.prototype.$onChanges = function () {
        // cloning binded object
        var _this = this;
        this.clonedDropdownItems = __spreadArrays(this.dropdownItems).map(function (item) { return (__assign(__assign({}, item), { condition: item.condition || (function () { return true; }) })); })
            .map(function (item) { return _this.setTemplateUrl(item); });
    };
    /* @ngInject */ YDropDownMenuComponent.prototype.isDeleteButton = function (dropdownItem) {
        return dropdownItem.key && dropdownItem.key.indexOf('remove') !== -1;
    };
    YDropDownMenuComponent.prototype.isDeleteButton.$inject = ["dropdownItem"];
    /* @ngInject */ YDropDownMenuComponent.prototype.setTemplateUrl = function (dropdownItem) {
        switch (this._validatePassedAttribute(dropdownItem)) {
            case 'callback':
                return __assign(__assign({}, dropdownItem), { templateUrl: 'yDropdownDefaultItemTemplate.html' });
            case 'template':
                // replacing 'template' with cached 'templateUrl'
                return __assign(__assign({}, dropdownItem), { templateUrl: this._cacheDropdownItemTemplate(dropdownItem), template: null });
            default:
                return dropdownItem;
        }
    };
    YDropDownMenuComponent.prototype.setTemplateUrl.$inject = ["dropdownItem"];
    /* @ngInject */ YDropDownMenuComponent.prototype._cacheDropdownItemTemplate = function (dropdownItem) {
        var nameOfCachedTemplate = 'yDropdownItem_' +
            stringUtils.getEncodedString(dropdownItem.template) +
            '_Template.html';
        if (!this.$templateCache.get(nameOfCachedTemplate)) {
            this.$templateCache.put(nameOfCachedTemplate, dropdownItem.template);
        }
        return nameOfCachedTemplate;
    };
    YDropDownMenuComponent.prototype._cacheDropdownItemTemplate.$inject = ["dropdownItem"];
    /* @ngInject */ YDropDownMenuComponent.prototype._validatePassedAttribute = function (dropdownItem) {
        var expectedAttributesAndTypes = {
            callback: 'function',
            template: 'string',
            templateUrl: 'string'
        };
        var expectedAttributes = Object.keys(expectedAttributesAndTypes);
        var passedAttributes = Object.keys(dropdownItem);
        var validatedAttribute = passedAttributes.filter(function (attribute) { return expectedAttributes.indexOf(attribute) !== -1; });
        if (validatedAttribute.length !== 1) {
            throw new Error('Please provide only one of callback, template or templateUrl.');
        }
        if (typeof dropdownItem[validatedAttribute[0]] !==
            expectedAttributesAndTypes[validatedAttribute[0]]) {
            throw new Error('Please provide a parameter of a proper type: callback(Function), template(String) or templateUrl(String).');
        }
        return validatedAttribute[0];
    };
    YDropDownMenuComponent.prototype._validatePassedAttribute.$inject = ["dropdownItem"];
    /* @ngInject */ YDropDownMenuComponent = __decorate([
        SeComponent({
            selector: 'y-drop-down-menu',
            templateUrl: 'yDropDownMenuTemplate.html',
            inputs: ['dropdownItems', 'selectedItem']
        }),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ YDropDownMenuComponent);
    return /* @ngInject */ YDropDownMenuComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "DropdownMenuComponent", {
    selector: 'se-dropdown-menu',
    template: "<fd-popover [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"placement || 'bottom-end'\" class=\"se-dropdown-more-menu\"><fd-popover-control><div #toggleMenu><div *ngIf=\"!useProjectedAnchor; else projectedAnchor;\" class=\"sap-icon--overflow se-dropdown-more-menu__toggle\"></div><ng-template #projectedAnchor><ng-content></ng-content></ng-template></div></fd-popover-control><fd-popover-body><fd-menu><ul fd-menu-list class=\"se-dropdown-menu__list\" [ngClass]=\"additionalClasses\"><se-dropdown-menu-item *ngFor=\"let dropdownItem of clonedDropdownItems\" [dropdownItem]=\"dropdownItem\" [selectedItem]=\"selectedItem\"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>"
});
var /* @ngInject */ DropdownMenuComponent = /** @class */ (function () {
    DropdownMenuComponent.$inject = ["$templateCache", "cd"];
    function /* @ngInject */ DropdownMenuComponent($templateCache, cd) {
        this.$templateCache = $templateCache;
        this.cd = cd;
        this.useProjectedAnchor = false;
        this.isOpen = false;
        this.additionalClasses = [];
        this.isOpenChange = new core.EventEmitter();
    }
    /* @ngInject */ DropdownMenuComponent.prototype.clickHandler = function (event) {
        if (this.toggleMenuElement.nativeElement.contains(event.target)) {
            event.stopPropagation();
            this.isOpen = !this.isOpen;
            this.cd.detectChanges();
            this.emitIsOpenChange();
            return;
        }
        if (this.isOpen) {
            this.isOpen = false;
            this.cd.detectChanges();
            this.emitIsOpenChange();
            return;
        }
    };
    DropdownMenuComponent.prototype.clickHandler.$inject = ["event"];
    /* @ngInject */ DropdownMenuComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes.dropdownItems) {
            this.clonedDropdownItems = this.dropdownItems
                .map(function (item) { return (__assign(__assign({}, item), { condition: item.condition || (function () { return true; }) })); })
                .map(function (item) { return _this.setComponentOrTemplateUrl(item); });
        }
    };
    DropdownMenuComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ DropdownMenuComponent.prototype.emitIsOpenChange = function () {
        this.isOpenChange.emit(this.isOpen);
    };
    /* @ngInject */ DropdownMenuComponent.prototype.setComponentOrTemplateUrl = function (dropdownItem) {
        switch (this.validateDropdownItem(dropdownItem)) {
            case 'callback':
                return __assign(__assign({}, dropdownItem), { component: DropdownMenuItemDefaultComponent });
            case 'template':
                return __assign(__assign({}, dropdownItem), { templateUrl: this.cacheDropdownItemTemplate(dropdownItem), template: null });
            default:
                return dropdownItem;
        }
    };
    DropdownMenuComponent.prototype.setComponentOrTemplateUrl.$inject = ["dropdownItem"];
    /* @ngInject */ DropdownMenuComponent.prototype.cacheDropdownItemTemplate = function (dropdownItem) {
        var keyOfCachedTemplate = 'yDropdownItem_' +
            stringUtils.getEncodedString(dropdownItem.template) +
            '_Template.html';
        if (!this.$templateCache.get(keyOfCachedTemplate)) {
            this.$templateCache.put(keyOfCachedTemplate, dropdownItem.template);
        }
        return keyOfCachedTemplate;
    };
    DropdownMenuComponent.prototype.cacheDropdownItemTemplate.$inject = ["dropdownItem"];
    /* @ngInject */ DropdownMenuComponent.prototype.validateDropdownItem = function (dropdownItem) {
        var expectedAttributes = [
            'callback',
            'template',
            'templateUrl',
            'component'
        ];
        var passedAttributes = Object.keys(dropdownItem);
        var validatedAttributes = passedAttributes.filter(function (attribute) { return expectedAttributes.indexOf(attribute) !== -1; });
        if (validatedAttributes.length !== 1) {
            throw new Error('DropdownMenuComponent.validateDropdownItem - Dropdown Item must contain at least a callback, template, templateUrl or component');
        }
        var targetAttribute = validatedAttributes[0];
        return targetAttribute;
    };
    DropdownMenuComponent.prototype.validateDropdownItem.$inject = ["dropdownItem"];
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "dropdownItems", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "selectedItem", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "placement", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "useProjectedAnchor", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "isOpen", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "additionalClasses", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "isOpenChange", void 0);
    __decorate([
        core.ViewChild('toggleMenu', { static: true }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "toggleMenuElement", void 0);
    __decorate([
        core.HostListener('document:click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [MouseEvent]),
        __metadata("design:returntype", void 0)
    ], /* @ngInject */ DropdownMenuComponent.prototype, "clickHandler", null);
    /* @ngInject */ DropdownMenuComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-dropdown-menu',
            template: "<fd-popover [triggers]=\"[]\" [closeOnOutsideClick]=\"false\" [isOpen]=\"isOpen\" [placement]=\"placement || 'bottom-end'\" class=\"se-dropdown-more-menu\"><fd-popover-control><div #toggleMenu><div *ngIf=\"!useProjectedAnchor; else projectedAnchor;\" class=\"sap-icon--overflow se-dropdown-more-menu__toggle\"></div><ng-template #projectedAnchor><ng-content></ng-content></ng-template></div></fd-popover-control><fd-popover-body><fd-menu><ul fd-menu-list class=\"se-dropdown-menu__list\" [ngClass]=\"additionalClasses\"><se-dropdown-menu-item *ngFor=\"let dropdownItem of clonedDropdownItems\" [dropdownItem]=\"dropdownItem\" [selectedItem]=\"selectedItem\"></se-dropdown-menu-item></ul></fd-menu></fd-popover-body></fd-popover>"
        }),
        __metadata("design:paramtypes", [ITemplateCacheService, core.ChangeDetectorRef])
    ], /* @ngInject */ DropdownMenuComponent);
    return /* @ngInject */ DropdownMenuComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "DropdownMenuItemComponent", {
    selector: 'se-dropdown-menu-item',
    template: "<li *ngIf=\"dropdownItem.condition(selectedItem)\" class=\"se-dropdown-menu__item-wrapper\" [ngClass]=\"dropdownItem.customCss\"><ng-container *ngIf=\"dropdownItem.component\"><ng-container *ngComponentOutlet=\"dropdownItem.component; injector: dropdownItemInjector\"></ng-container></ng-container><span *ngIf=\"dropdownItem.templateUrl\" [ngInclude]=\"dropdownItem.templateUrl\" [compileHtmlNgController]=\"compileHtmlNgController\"></span></li>"
});
var DropdownMenuItemComponent = /** @class */ (function () {
    function DropdownMenuItemComponent(injector) {
        this.injector = injector;
    }
    DropdownMenuItemComponent.prototype.ngOnInit = function () {
        if (this.dropdownItem.templateUrl) {
            this.createCompileHtmlNgController();
            return;
        }
        if (this.dropdownItem.component) {
            this.createDropdownItemInjector();
        }
    };
    DropdownMenuItemComponent.prototype.createCompileHtmlNgController = function () {
        var selectedItem = this.selectedItem;
        this.compileHtmlNgController = {
            alias: '$ctrl',
            value: function () {
                this.selectedItem = selectedItem;
            }
        };
    };
    DropdownMenuItemComponent.prototype.createDropdownItemInjector = function () {
        var selectedItem = this.selectedItem;
        this.dropdownItemInjector = core.Injector.create({
            parent: this.injector,
            providers: [
                {
                    provide: DROPDOWN_MENU_ITEM_DATA,
                    useValue: {
                        dropdownItem: this.dropdownItem,
                        selectedItem: selectedItem
                    }
                }
            ]
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], DropdownMenuItemComponent.prototype, "dropdownItem", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], DropdownMenuItemComponent.prototype, "selectedItem", void 0);
    DropdownMenuItemComponent = __decorate([
        core.Component({
            selector: 'se-dropdown-menu-item',
            template: "<li *ngIf=\"dropdownItem.condition(selectedItem)\" class=\"se-dropdown-menu__item-wrapper\" [ngClass]=\"dropdownItem.customCss\"><ng-container *ngIf=\"dropdownItem.component\"><ng-container *ngComponentOutlet=\"dropdownItem.component; injector: dropdownItemInjector\"></ng-container></ng-container><span *ngIf=\"dropdownItem.templateUrl\" [ngInclude]=\"dropdownItem.templateUrl\" [compileHtmlNgController]=\"compileHtmlNgController\"></span></li>"
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], DropdownMenuItemComponent);
    return DropdownMenuItemComponent;
}());

var DropdownMenuModule = /** @class */ (function () {
    function DropdownMenuModule() {
    }
    DropdownMenuModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, FundamentalsModule, CompileHtmlModule, utils.TranslationModule.forChild()],
            declarations: [
                DropdownMenuComponent,
                DropdownMenuItemComponent,
                DropdownMenuItemDefaultComponent
            ],
            entryComponents: [DropdownMenuComponent, DropdownMenuItemDefaultComponent],
            exports: [DropdownMenuComponent]
        })
    ], DropdownMenuModule);
    return DropdownMenuModule;
}());

/**
 * **Deprecated since 2005, use {@link DynamicPagedListComponent}.**
 *
 * Component responsible for displaying a server-side paginated list of items with custom renderers. It allows the user to search and sort the list.
 *
 * ### Parameters
 * `config` - See {@link DynamicPagedListConfig}.
 *
 * `mask` - The string value used to filter the result.
 *
 * `getApi` - {@link OnGetApiEvent} Exposes the dynamic paged list module's api object
 *
 * `onItemsUpdate` - {@link OnItemsUpdateEvent} Exposes the item list.
 *
 * ### Example of a <strong>renderers</strong> object
 *
 *      renderers = {
 *          name: function(item, key) {
 *              return "<a data-ng-click=\"$ctrl.config.injectedContext.onLink( item.path )\">{{ item[key.property] }}</a>";
 *          }
 *      };
 *
 *
 * ### Example of an <strong>injectedContext</strong> object
 *
 *      injectedContext = {
 *          onLink: function(link) {
 *              if (link) {
 *                  var experiencePath = this._buildExperiencePath();
 *                  iframeManagerService.setCurrentLocation(link);
 *                  $location.path(experiencePath);
 *              }
 *          }.bind(this),
 *          dropdownItems: []
 *      };
 *
 */
var /* @ngInject */ LegacyDynamicPagedListComponent = /** @class */ (function () {
    function /* @ngInject */ LegacyDynamicPagedListComponent() {
    }
    /**
     * Backwards compatibility getApi adapter
     */
    /* @ngInject */ LegacyDynamicPagedListComponent.prototype.internalGetApi = function ($api) {
        this.getApi({ $api: $api });
    };
    LegacyDynamicPagedListComponent.prototype.internalGetApi.$inject = ["$api"];
    /* @ngInject */ LegacyDynamicPagedListComponent = __decorate([
        SeComponent({
            selector: 'dynamic-paged-list',
            templateUrl: 'legacyDynamicPagedListTemplate.html',
            inputs: ['config:=', 'mask:=?', 'getApi:&?', 'onItemsUpdate:&?']
        })
    ], /* @ngInject */ LegacyDynamicPagedListComponent);
    return /* @ngInject */ LegacyDynamicPagedListComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "DynamicPagedListComponent", {
    selector: 'se-dynamic-paged-list',
    template: "<div *ngIf=\"ready\" class=\"se-dynamic-paged-list\"><div class=\"fd-panel__body fd-panel__body--bleed\"><se-data-table [columns]=\"columns\" [config]=\"config\" [items]=\"items\" [sortStatus]=\"sortStatus\" (onSortColumn)=\"orderByColumn($event)\"></se-data-table></div><div class=\"fd-panel__footer\"><se-pagination *ngIf=\"!!items.length\" class=\"se-dynamic-list__pagination\" [totalItems]=\"totalItems\" [itemsPerPage]=\"config.itemsPerPage\" [currentPage]=\"currentPage\" (onChange)=\"onCurrentPageChange($event)\"></se-pagination><span class=\"se-paged-list__page-count-wrapper se-paged-list__page-count-wrapper--footer\"><span class=\"span-page-list__page-count-text\">{{'se.pagelist.countsearchresult' | translate}} </span><span class=\"se-page-list__page-count\">({{ totalItems }})</span></span></div></div><se-spinner [isSpinning]=\"!ready\"></se-spinner>"
});
var /* @ngInject */ DynamicPagedListComponent = /** @class */ (function () {
    DynamicPagedListComponent.$inject = ["logService", "restServiceFactory", "cdr"];
    function /* @ngInject */ DynamicPagedListComponent(logService, restServiceFactory, cdr) {
        var _this = this;
        this.logService = logService;
        this.restServiceFactory = restServiceFactory;
        this.cdr = cdr;
        this.getApi = new core.EventEmitter();
        this.onItemsUpdate = new core.EventEmitter();
        this.api = {
            reloadItems: function () { return _this.loadItems(); }
        };
    }
    /* @ngInject */ DynamicPagedListComponent.prototype.ngOnInit = function () {
        this._validateInput();
        this.ready = false;
        this.totalItems = 0;
        this.currentPage = 1;
        this.columnSortMode = this.config.reversed
            ? exports.SortDirections.Descending
            : exports.SortDirections.Ascending;
        this.internalSortBy = lodash.cloneDeep(this.config.sortBy);
        this.oldMask = this.mask;
        this.columns = [];
        this.sortStatus = {
            internalSortBy: this.internalSortBy,
            reversed: this.config.reversed,
            currentPage: this.currentPage
        };
        this._buildColumnData();
        this.loadItems();
        this.getApi.emit(this.api);
    };
    /* @ngInject */ DynamicPagedListComponent.prototype.ngOnChanges = function (changes) {
        var maskChange = changes.mask;
        if (!!maskChange && !maskChange.firstChange && this.oldMask !== this.mask) {
            this.oldMask = this.mask;
            this.currentPage = 1;
            this.loadItems();
        }
    };
    DynamicPagedListComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ DynamicPagedListComponent.prototype.orderByColumn = function (event) {
        this.internalSortBy = event.$columnKey.property;
        this.columnSortMode = event.$columnSortMode;
        this.config.reversed = this.columnSortMode === exports.SortDirections.Descending;
        this.sortStatus.internalSortBy = this.internalSortBy;
        this.sortStatus.reversed = this.config.reversed;
        if (event.$columnKey.sortable) {
            this.currentPage = 1;
            this.sortStatus.currentPage = 1;
            this.loadItems();
        }
    };
    DynamicPagedListComponent.prototype.orderByColumn.$inject = ["event"];
    /* @ngInject */ DynamicPagedListComponent.prototype.loadItems = function () {
        var _this = this;
        this.ready = false;
        var params = __assign(__assign({}, (this.config.queryParams || {})), { currentPage: this.currentPage - 1, mask: this.mask, pageSize: this.config.itemsPerPage, sort: this.internalSortBy + ":" + this.columnSortMode });
        return this.restServiceFactory
            .get(this.config.uri)
            .page(params)
            .then(function (result) {
            _this.items = result.results;
            if (_this.items.length === 0) {
                _this.logService.warn('PagedList: No items returned to display');
            }
            _this.totalItems = result.pagination.totalCount;
            _this.currentPage = parseInt(String(result.pagination.page), 10) + 1;
            _this.ready = true;
            _this.cdr.detectChanges();
            _this.onItemsUpdate.emit(result);
            return result;
        });
    };
    /* @ngInject */ DynamicPagedListComponent.prototype.onCurrentPageChange = function (newCurrentPage) {
        if (newCurrentPage === this.currentPage) {
            return;
        }
        this.currentPage = newCurrentPage;
        this.loadItems();
    };
    DynamicPagedListComponent.prototype.onCurrentPageChange.$inject = ["newCurrentPage"];
    /* @ngInject */ DynamicPagedListComponent.prototype._validateInput = function () {
        if (!this.config) {
            throw new Error('config object is required');
        }
        if (!(this.config.keys instanceof Array)) {
            throw new Error('keys must be an array');
        }
        if (this.config.keys.length < 1) {
            throw new Error('dynamic paged list requires at least one key');
        }
        if (!this.config.uri) {
            throw new Error('dynamic paged list requires a uri to fetch the list of items');
        }
    };
    /* @ngInject */ DynamicPagedListComponent.prototype._buildColumnData = function () {
        var _this = this;
        this.columns = this.config.keys.map(function (key) { return (__assign(__assign({}, key), { renderer: _this.config.renderers[key.property] })); });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ DynamicPagedListComponent.prototype, "config", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ DynamicPagedListComponent.prototype, "mask", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ DynamicPagedListComponent.prototype, "getApi", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ DynamicPagedListComponent.prototype, "onItemsUpdate", void 0);
    /* @ngInject */ DynamicPagedListComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-dynamic-paged-list',
            template: "<div *ngIf=\"ready\" class=\"se-dynamic-paged-list\"><div class=\"fd-panel__body fd-panel__body--bleed\"><se-data-table [columns]=\"columns\" [config]=\"config\" [items]=\"items\" [sortStatus]=\"sortStatus\" (onSortColumn)=\"orderByColumn($event)\"></se-data-table></div><div class=\"fd-panel__footer\"><se-pagination *ngIf=\"!!items.length\" class=\"se-dynamic-list__pagination\" [totalItems]=\"totalItems\" [itemsPerPage]=\"config.itemsPerPage\" [currentPage]=\"currentPage\" (onChange)=\"onCurrentPageChange($event)\"></se-pagination><span class=\"se-paged-list__page-count-wrapper se-paged-list__page-count-wrapper--footer\"><span class=\"span-page-list__page-count-text\">{{'se.pagelist.countsearchresult' | translate}} </span><span class=\"se-page-list__page-count\">({{ totalItems }})</span></span></div></div><se-spinner [isSpinning]=\"!ready\"></se-spinner>"
        }),
        __metadata("design:paramtypes", [utils.LogService,
            utils.RestServiceFactory,
            core.ChangeDetectorRef])
    ], /* @ngInject */ DynamicPagedListComponent);
    return /* @ngInject */ DynamicPagedListComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "PaginationComponent", {
    selector: 'se-pagination',
    template: "<fd-pagination class=\"se-pagination\" [displayTotalItems]=\"displayTotalItems\" [totalItems]=\"totalItems\" [itemsPerPage]=\"totalItems === 1 ? 1 : itemsPerPage\" [currentPage]=\"currentPage\" (pageChangeStart)=\"onPageChanged($event)\" nextLabel=\"&rsaquo; \" previousLabel=\"&lsaquo; \"></fd-pagination>"
});
var /* @ngInject */ PaginationComponent = /** @class */ (function () {
    function /* @ngInject */ PaginationComponent() {
        this.displayTotalItems = false;
        this.onChange = new core.EventEmitter();
    }
    /* @ngInject */ PaginationComponent.prototype.onPageChanged = function (page) {
        this.currentPage = page;
        this.onChange.emit(page);
    };
    PaginationComponent.prototype.onPageChanged.$inject = ["page"];
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ PaginationComponent.prototype, "totalItems", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ PaginationComponent.prototype, "displayTotalItems", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ PaginationComponent.prototype, "itemsPerPage", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ PaginationComponent.prototype, "currentPage", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ PaginationComponent.prototype, "onChange", void 0);
    /* @ngInject */ PaginationComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-pagination',
            template: "<fd-pagination class=\"se-pagination\" [displayTotalItems]=\"displayTotalItems\" [totalItems]=\"totalItems\" [itemsPerPage]=\"totalItems === 1 ? 1 : itemsPerPage\" [currentPage]=\"currentPage\" (pageChangeStart)=\"onPageChanged($event)\" nextLabel=\"&rsaquo; \" previousLabel=\"&lsaquo; \"></fd-pagination>"
        })
    ], /* @ngInject */ PaginationComponent);
    return /* @ngInject */ PaginationComponent;
}());

var PaginationModule = /** @class */ (function () {
    function PaginationModule() {
    }
    PaginationModule = __decorate([
        core.NgModule({
            imports: [FundamentalsModule],
            declarations: [PaginationComponent],
            exports: [PaginationComponent]
        })
    ], PaginationModule);
    return PaginationModule;
}());

var DynamicPagedListModule = /** @class */ (function () {
    function DynamicPagedListModule() {
    }
    DynamicPagedListModule = __decorate([
        core.NgModule({
            imports: [
                common.CommonModule,
                PaginationModule,
                DataTableModule,
                utils.TranslationModule.forChild(),
                SpinnerModule
            ],
            declarations: [DynamicPagedListComponent],
            entryComponents: [DynamicPagedListComponent],
            exports: [DynamicPagedListComponent]
        })
    ], DynamicPagedListModule);
    return DynamicPagedListModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var TreeNestedDataSource = /** @class */ (function () {
    function TreeNestedDataSource() {
        this._data = new rxjs.BehaviorSubject([]);
    }
    TreeNestedDataSource.prototype.get = function () {
        return this._data.asObservable();
    };
    TreeNestedDataSource.prototype.set = function (data) {
        this._data.next(data);
    };
    return TreeNestedDataSource;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var TreeNodeItem = /** @class */ (function () {
    function TreeNodeItem(config) {
        this.position = 0;
        this.nodes = [];
        this.hasChildren = config.hasChildren;
        this.name = config.name;
        this.title = config.title;
        this.parentUid = config.parentUid;
        this.position = config.position;
        this.itemType = config.itemType;
        this.uid = config.uid;
        this.uuid = config.uuid;
        this.level = config.level;
        this.nodes = [];
    }
    TreeNodeItem.prototype.setPosition = function (position) {
        this.position = position;
        return this;
    };
    TreeNodeItem.prototype.setMouseHovered = function (isHovered) {
        this.mouseHovered = isHovered;
        return this;
    };
    TreeNodeItem.prototype.setInitiated = function (isInitiated) {
        this.initiated = isInitiated;
        return this;
    };
    TreeNodeItem.prototype.setLevel = function (level) {
        this.level = level;
        return this;
    };
    TreeNodeItem.prototype.addNode = function (node) {
        var _this = this;
        this.nodes = __spreadArrays(this.nodes, [node.setParent(this)]).map(function (item, idx) {
            return item.setPosition(idx).setLevel(_this.level + 1);
        });
        this.updateHasChildren();
        return this;
    };
    TreeNodeItem.prototype.addNodes = function (nodes) {
        var _this = this;
        this.nodes = __spreadArrays(this.nodes, nodes.map(function (node) { return node.setParent(_this); })).map(function (item, idx) { return item.setPosition(idx).setLevel(_this.level + 1); });
        this.updateHasChildren();
        return this;
    };
    TreeNodeItem.prototype.removeAllNodes = function () {
        this.nodes = [];
        this.updateHasChildren();
        return this;
    };
    TreeNodeItem.prototype.removeNode = function (node) {
        this.nodes = this.nodes
            .filter(function (_node) { return _node.uid !== node.uid; })
            .map(function (item, idx) { return item.setPosition(idx); });
        this.updateHasChildren();
        return this;
    };
    TreeNodeItem.prototype.setParent = function (node) {
        this.parent = node;
        this.parentUid = node.uid;
        return this;
    };
    TreeNodeItem.prototype.toggle = function () {
        this.isExpanded = !this.isExpanded;
        return this;
    };
    TreeNodeItem.prototype.collapse = function () {
        this.isExpanded = false;
        return this;
    };
    TreeNodeItem.prototype.expand = function () {
        this.isExpanded = true;
        return this;
    };
    TreeNodeItem.prototype.collapseAll = function () {
        var _this = this;
        this.nodes.forEach(function (node) { return _this.collapseRecursively(node); });
    };
    TreeNodeItem.prototype.expandAll = function () {
        var _this = this;
        this.nodes.forEach(function (node) { return _this.expandRecursively(node); });
    };
    TreeNodeItem.prototype.collapseRecursively = function (_node) {
        var _this = this;
        _node.collapse().nodes.forEach(function (node) { return _this.collapseRecursively(node); });
    };
    TreeNodeItem.prototype.expandRecursively = function (_node) {
        var _this = this;
        _node.expand().nodes.forEach(function (node) { return _this.expandRecursively(node); });
    };
    TreeNodeItem.prototype.updateHasChildren = function () {
        this.hasChildren = !!this.nodes.length;
    };
    return TreeNodeItem;
}());
var NavigationNodeItem = /** @class */ (function (_super) {
    __extends(NavigationNodeItem, _super);
    function NavigationNodeItem(config) {
        var _this = _super.call(this, config) || this;
        _this.entries = config.entries;
        return _this;
    }
    return NavigationNodeItem;
}(TreeNodeItem));

var TreeNodeItemType;
(function (TreeNodeItemType) {
    TreeNodeItemType["CMSNavigationNode"] = "CMSNavigationNode";
})(TreeNodeItemType || (TreeNodeItemType = {}));
/**
 * A service used to generate instance of node item to be consumed by {@link TreeComponent}.
 */
var /* @ngInject */ TreeNodeItemFactory = /** @class */ (function () {
    function /* @ngInject */ TreeNodeItemFactory() {
    }
    /**
     * @param dto DTO based on which the class is returned.
     *
     * Returns a class depending on itemtype.
     */
    /* @ngInject */ TreeNodeItemFactory.prototype.get = function (dto) {
        switch (dto.itemType) {
            case TreeNodeItemType.CMSNavigationNode:
                return new NavigationNodeItem(dto);
            default:
                return new TreeNodeItem(dto);
        }
    };
    TreeNodeItemFactory.prototype.get.$inject = ["dto"];
    /* @ngInject */ TreeNodeItemFactory = __decorate([
        SeDowngradeService()
    ], /* @ngInject */ TreeNodeItemFactory);
    return /* @ngInject */ TreeNodeItemFactory;
}());

/**
 * A service to manage tree nodes through a REST API.
 */
var /* @ngInject */ TreeService = /** @class */ (function () {
    TreeService.$inject = ["restServiceFactory", "treeNodeItemFactory"];
    function /* @ngInject */ TreeService(restServiceFactory, treeNodeItemFactory) {
        this.restServiceFactory = restServiceFactory;
        this.treeNodeItemFactory = treeNodeItemFactory;
        this.dataSource = new TreeNestedDataSource();
        this.$onTreeUpdated = new rxjs.BehaviorSubject(false);
    }
    /* @ngInject */ TreeService.prototype.onTreeUpdated = function () {
        return this.$onTreeUpdated.pipe(operators.filter(function (value) { return !!value; }));
    };
    /**
     * Initializes the REST service and sets root node.
     *
     * @param nodeUri URI passed to {@link TreeComponent}.
     * @param rootNodeUid root uid passed to {@link TreeComponent}.
     */
    /* @ngInject */ TreeService.prototype.init = function (nodeUri, rootNodeUid) {
        if (nodeUri) {
            this.nodesRestService = this.restServiceFactory.get(nodeUri);
        }
        this.setRoot(rootNodeUid);
    };
    TreeService.prototype.init.$inject = ["nodeUri", "rootNodeUid"];
    /**
     * Updates the position of the node within the tree.
     *
     * @param node Node to be rearranged.
     * @param position New position of node.
     */
    /* @ngInject */ TreeService.prototype.rearrange = function (node, parent, position) {
        var siblings = parent.nodes.filter(function (_node) { return _node.uid !== node.uid; });
        var rearranged = __spreadArrays(siblings.slice(0, position), [
            node
        ], siblings.slice(position, siblings.length));
        node.parent.removeNode(node);
        parent.removeAllNodes().addNodes(rearranged);
        this.update();
    };
    TreeService.prototype.rearrange.$inject = ["node", "parent", "position"];
    /**
     * Fetches the node children and updates the tree.
     */
    /* @ngInject */ TreeService.prototype.fetchChildren = function (_parent) {
        return __awaiter(this, void 0, void 0, function () {
            var parent, response, children;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parent = _parent || this.root;
                        if (!parent.initiated) return [3 /*break*/, 1];
                        this.update();
                        return [2 /*return*/, Promise.resolve(parent.nodes)];
                    case 1: return [4 /*yield*/, this.nodesRestService.get({ parentUid: parent.uid })];
                    case 2:
                        response = _a.sent();
                        children = (apiUtils.getDataFromResponse(response) || []).map(function (dto) {
                            return _this.treeNodeItemFactory.get(dto);
                        });
                        parent.removeAllNodes().addNodes(children).setInitiated(true);
                        this.update();
                        return [2 /*return*/, children];
                }
            });
        });
    };
    TreeService.prototype.fetchChildren.$inject = ["_parent"];
    /**
     * Toggles the passed node and fetches children
     *
     * @param node Node to be rearranged.
     */
    /* @ngInject */ TreeService.prototype.toggle = function (node) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                node.toggle();
                return [2 /*return*/, this.fetchChildren(node)];
            });
        });
    };
    TreeService.prototype.toggle.$inject = ["node"];
    /**
     * Adds a new child to passed node.
     *
     * @param node Node to be rearranged.
     */
    /* @ngInject */ TreeService.prototype.newChild = function (node) {
        return __awaiter(this, void 0, void 0, function () {
            var nodeData, response, elm;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nodeData = node || this.root;
                        return [4 /*yield*/, this.saveNode(nodeData)];
                    case 1:
                        response = _a.sent();
                        if (!nodeData.isExpanded) {
                            this.toggle(nodeData);
                        }
                        else {
                            elm = nodeData.nodes.find(function (_node) { return _node.uid === response.uid; });
                            if (!elm) {
                                nodeData.addNode(this.treeNodeItemFactory.get(response));
                                this.update();
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    TreeService.prototype.newChild.$inject = ["node"];
    /**
     * Adds new sibling to passed node.
     *
     * @param node Node to be rearranged.
     */
    /* @ngInject */ TreeService.prototype.newSibling = function (node) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.saveNode(node.parent)];
                    case 1:
                        response = _a.sent();
                        node.parent.addNode(this.treeNodeItemFactory.get(response));
                        this.update();
                        return [2 /*return*/];
                }
            });
        });
    };
    TreeService.prototype.newSibling.$inject = ["node"];
    /**
     * Removes passed node.
     *
     * @param node Node to be rearranged.
     */
    /* @ngInject */ TreeService.prototype.removeNode = function (node) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.nodesRestService.remove({ identifier: node.uid })];
                    case 1:
                        _a.sent();
                        node.parent.removeNode(node);
                        this.update();
                        return [2 /*return*/];
                }
            });
        });
    };
    TreeService.prototype.removeNode.$inject = ["node"];
    /**
     * Updates the data source from where the nodes are retrieved
     */
    /* @ngInject */ TreeService.prototype.update = function () {
        this.dataSource.set(null);
        this.dataSource.set(this.root.nodes);
        this.$onTreeUpdated.next(true);
    };
    /**
     * Expands all nodes from the root node
     */
    /* @ngInject */ TreeService.prototype.expandAll = function () {
        this.root.expandAll();
        this.update();
    };
    /**
     * Collapses all nodes from the root node
     */
    /* @ngInject */ TreeService.prototype.collapseAll = function () {
        this.root.collapseAll();
        this.update();
    };
    /* @ngInject */ TreeService.prototype.getNodePositionById = function (nodeUid) {
        return this.getNodeById(nodeUid).position;
    };
    TreeService.prototype.getNodePositionById.$inject = ["nodeUid"];
    /* @ngInject */ TreeService.prototype.getNodeById = function (nodeUid, nodeArray) {
        if (nodeUid === this.root.uid) {
            return this.root;
        }
        var nodes = nodeArray || this.root.nodes;
        // eslint-disable-next-line @typescript-eslint/no-for-in-array
        for (var i in nodes) {
            if (nodes.hasOwnProperty(i)) {
                if (nodes[i].uid === nodeUid) {
                    return nodes[i];
                }
                if (nodes[i].hasChildren) {
                    nodes[i].nodes = nodes[i].nodes || [];
                    var result = this.getNodeById(nodeUid, nodes[i].nodes);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        return null;
    };
    TreeService.prototype.getNodeById.$inject = ["nodeUid", "nodeArray"];
    /* @ngInject */ TreeService.prototype.saveNode = function (_parent) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.nodesRestService.save({
                            parentUid: _parent.uid,
                            name: (_parent.name ? _parent.name : _parent.uid) + _parent.nodes.length
                        })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response];
                }
            });
        });
    };
    TreeService.prototype.saveNode.$inject = ["_parent"];
    /* @ngInject */ TreeService.prototype.setRoot = function (uid) {
        this.root = this.treeNodeItemFactory.get({ uid: uid, name: 'root', level: 0 });
    };
    TreeService.prototype.setRoot.$inject = ["uid"];
    /* @ngInject */ TreeService = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [utils.RestServiceFactory,
            TreeNodeItemFactory])
    ], /* @ngInject */ TreeService);
    return /* @ngInject */ TreeService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Represents the event triggered when dragging and dropping nodes in the {@link TreeComponent}.
 */
var TreeDragAndDropEvent = /** @class */ (function () {
    /**
     * @param sourceNode `ITreeNodeItem` that is being dragged.
     * @param destinationNodes The set of the destination's parent's children `ITreeNodeItem`.
     * @param sourceParentNode Parent `ITreeNodeItem` of the dragged node.
     * @param destinationParentNode Parent `ITreeNodeItem` of the destination node.
     * @param position Index at which the `ITreeNodeItem` was dropped.
     */
    function TreeDragAndDropEvent(sourceNode, destinationNodes, sourceParentNode, destinationParentNode, position) {
        this.sourceNode = sourceNode;
        this.destinationNodes = destinationNodes;
        this.sourceParentNode = sourceParentNode;
        this.destinationParentNode = destinationParentNode;
        this.position = position;
    }
    return TreeDragAndDropEvent;
}());
var TREE_NODE = new core.InjectionToken('TREE_NODE');

var /* @ngInject */ TreeDragAndDropService = /** @class */ (function () {
    TreeDragAndDropService.$inject = ["confirmationModalService", "alertService", "treeService"];
    function /* @ngInject */ TreeDragAndDropService(confirmationModalService, alertService, treeService) {
        this.confirmationModalService = confirmationModalService;
        this.alertService = alertService;
        this.treeService = treeService;
    }
    /* @ngInject */ TreeDragAndDropService.prototype.init = function (options) {
        this.config = options;
        this.isDragEnabled =
            !!options &&
                (!!options.onDropCallback ||
                    !!options.beforeDropCallback ||
                    !!options.allowDropCallback);
    };
    TreeDragAndDropService.prototype.init.$inject = ["options"];
    /* @ngInject */ TreeDragAndDropService.prototype.handleDrop = function (event) {
        var _this = this;
        if (!this.config || !event.isPointerOverContainer) {
            return Promise.resolve();
        }
        if (!this.allowDrop(event)) {
            return Promise.resolve();
        }
        return this.beforeDrop(event).then(function (result) {
            if (result === false) {
                return;
            }
            _this.onDrop(event);
            _this.rearrangeNodes(event);
        });
    };
    TreeDragAndDropService.prototype.handleDrop.$inject = ["event"];
    /* @ngInject */ TreeDragAndDropService.prototype.rearrangeNodes = function (event) {
        this.treeService.rearrange(event.item.data, event.container.data[0].parent, event.currentIndex);
    };
    TreeDragAndDropService.prototype.rearrangeNodes.$inject = ["event"];
    /* @ngInject */ TreeDragAndDropService.prototype.onDrop = function (event) {
        if (!this.config.onDropCallback) {
            return;
        }
        var dndEvent = new TreeDragAndDropEvent(event.item.data, event.container.data, event.item.data.parent, event.container.data[0].parent, event.currentIndex);
        return this.config.onDropCallback(dndEvent);
    };
    TreeDragAndDropService.prototype.onDrop.$inject = ["event"];
    /* @ngInject */ TreeDragAndDropService.prototype.allowDrop = function (event) {
        if (!this.config.allowDropCallback) {
            return true;
        }
        return this.config.allowDropCallback(new TreeDragAndDropEvent(event.item.data, event.container.data, event.item.data.parent, event.container.data[0].parent, event.currentIndex));
    };
    TreeDragAndDropService.prototype.allowDrop.$inject = ["event"];
    /* @ngInject */ TreeDragAndDropService.prototype.beforeDrop = function (event) {
        var _this = this;
        if (!this.config.beforeDropCallback) {
            return Promise.resolve();
        }
        var dndEvent = new TreeDragAndDropEvent(event.item.data, event.container.data, event.item.data.parent, event.container.data[0].parent, event.currentIndex);
        return this.config
            .beforeDropCallback(dndEvent)
            .then(function (result) {
            if (typeof result === 'object') {
                if (result.confirmDropI18nKey) {
                    var message = {
                        description: result.confirmDropI18nKey
                    };
                    return _this.confirmationModalService.confirm(message);
                }
                if (result.rejectDropI18nKey) {
                    _this.alertService.showDanger({
                        message: result.rejectDropI18nKey
                    });
                    return false;
                }
                throw new Error('Unexpected return value for beforeDropCallback does not contain confirmDropI18nKey nor rejectDropI18nKey: ' +
                    result);
            }
            return result;
        });
    };
    TreeDragAndDropService.prototype.beforeDrop.$inject = ["event"];
    /* @ngInject */ TreeDragAndDropService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [IConfirmationModalService,
            IAlertService,
            TreeService])
    ], /* @ngInject */ TreeDragAndDropService);
    return /* @ngInject */ TreeDragAndDropService;
}());

window.__smartedit__.addDecoratorPayload("Component", "TreeComponent", {
    selector: 'se-tree',
    providers: [TreeService, TreeDragAndDropService, TreeNodeItemFactory],
    host: {
        class: 'se-tree'
    },
    template: "<div class=\"categoryTable se-tree\"><div class=\"se-tree__body\"><div class=\"desktopLayout\"><ol class=\"se-tree__nodes\"><li *ngIf=\"(this.treeService.dataSource.get() | async).length === 0\" class=\"se-tree__nodes--nodata\">{{ 'se.ytree.no.nodes.to.display' | translate }}</li><li class=\"se-tree__nodes--item\"><se-tree-node [source]=\"this.treeService.dataSource.get() | async\"></se-tree-node></li></ol></div></div></div>"
});
var /* @ngInject */ TreeComponent = /** @class */ (function () {
    TreeComponent.$inject = ["treeService", "treeDragAndDropService"];
    function /* @ngInject */ TreeComponent(treeService, treeDragAndDropService) {
        this.treeService = treeService;
        this.treeDragAndDropService = treeDragAndDropService;
        this.onTreeUpdated = new core.EventEmitter();
    }
    /* @ngInject */ TreeComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.setNodeActions();
        this.treeService.init(this.nodeUri, this.rootNodeUid);
        this.treeDragAndDropService.init(this.dragOptions);
        this.fetchData(this.treeService.root);
        this.treeService
            .onTreeUpdated()
            .subscribe(function () { return _this.onTreeUpdated.emit(_this.treeService.root.nodes); });
    };
    /* @ngInject */ TreeComponent.prototype.fetchData = function (nodeData) {
        return this.treeService.fetchChildren(nodeData);
    };
    TreeComponent.prototype.fetchData.$inject = ["nodeData"];
    /* @ngInject */ TreeComponent.prototype.hasChildren = function (node) {
        return node.hasChildren;
    };
    TreeComponent.prototype.hasChildren.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.collapseAll = function () {
        this.treeService.collapseAll();
    };
    /* @ngInject */ TreeComponent.prototype.expandAll = function () {
        this.treeService.expandAll();
    };
    /* @ngInject */ TreeComponent.prototype.remove = function (node) {
        this.treeService.removeNode(node);
    };
    TreeComponent.prototype.remove.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.newSibling = function (node) {
        this.treeService.newSibling(node);
    };
    TreeComponent.prototype.newSibling.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.refresh = function (node) {
        node.setInitiated(false);
        return this.treeService.fetchChildren(node);
    };
    TreeComponent.prototype.refresh.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.refreshParent = function (node) {
        this.refresh(node.parent);
    };
    TreeComponent.prototype.refreshParent.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.newChild = function (node) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.treeService.newChild(node);
                return [2 /*return*/];
            });
        });
    };
    TreeComponent.prototype.newChild.$inject = ["node"];
    /* @ngInject */ TreeComponent.prototype.getNodeById = function (nodeUid, nodeArray) {
        return this.treeService.getNodeById(nodeUid, nodeArray);
    };
    TreeComponent.prototype.getNodeById.$inject = ["nodeUid", "nodeArray"];
    Object.defineProperty(/* @ngInject */ TreeComponent.prototype, "dragEnabled", {
        get: function () {
            return this.treeDragAndDropService.isDragEnabled;
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ TreeComponent.prototype.setNodeActions = function () {
        var _this = this;
        Object.keys(this.nodeActions).forEach(function (functionName) {
            _this[functionName] = _this.nodeActions[functionName].bind(_this, _this.treeService);
            _this.nodeActions[functionName] = _this.nodeActions[functionName].bind(_this, _this.treeService);
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TreeComponent.prototype, "nodeTemplateUrl", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ TreeComponent.prototype, "nodeComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TreeComponent.prototype, "nodeUri", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TreeComponent.prototype, "nodeActions", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TreeComponent.prototype, "rootNodeUid", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ TreeComponent.prototype, "dragOptions", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ TreeComponent.prototype, "removeDefaultTemplate", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], /* @ngInject */ TreeComponent.prototype, "showAsList", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ TreeComponent.prototype, "onTreeUpdated", void 0);
    /* @ngInject */ TreeComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-tree',
            providers: [TreeService, TreeDragAndDropService, TreeNodeItemFactory],
            host: {
                class: 'se-tree'
            },
            template: "<div class=\"categoryTable se-tree\"><div class=\"se-tree__body\"><div class=\"desktopLayout\"><ol class=\"se-tree__nodes\"><li *ngIf=\"(this.treeService.dataSource.get() | async).length === 0\" class=\"se-tree__nodes--nodata\">{{ 'se.ytree.no.nodes.to.display' | translate }}</li><li class=\"se-tree__nodes--item\"><se-tree-node [source]=\"this.treeService.dataSource.get() | async\"></se-tree-node></li></ol></div></div></div>"
        }),
        __metadata("design:paramtypes", [TreeService,
            TreeDragAndDropService])
    ], /* @ngInject */ TreeComponent);
    return /* @ngInject */ TreeComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "TreeNodeComponent", {
    selector: 'se-tree-node',
    template: "<ol class=\"se-tree-node__ol angular-ui-tree-nodes\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\" [cdkDropListData]=\"source\" [cdkDropListDisabled]=\"isDisabled\"><li *ngFor=\"let node of source\" cdkDrag [cdkDragData]=\"node\" class=\"angular-ui-tree-node se-tree-node__li\"><se-tree-node-renderer [node]=\"node\"></se-tree-node-renderer></li></ol>"
});
var TreeNodeComponent = /** @class */ (function () {
    function TreeNodeComponent(treeDragAndDropService) {
        this.treeDragAndDropService = treeDragAndDropService;
    }
    Object.defineProperty(TreeNodeComponent.prototype, "isDisabled", {
        get: function () {
            return !this.treeDragAndDropService.isDragEnabled;
        },
        enumerable: false,
        configurable: true
    });
    TreeNodeComponent.prototype.onDrop = function (event) {
        this.treeDragAndDropService.handleDrop(event);
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], TreeNodeComponent.prototype, "source", void 0);
    TreeNodeComponent = __decorate([
        core.Component({
            selector: 'se-tree-node',
            template: "<ol class=\"se-tree-node__ol angular-ui-tree-nodes\" cdkDropList (cdkDropListDropped)=\"onDrop($event)\" [cdkDropListData]=\"source\" [cdkDropListDisabled]=\"isDisabled\"><li *ngFor=\"let node of source\" cdkDrag [cdkDragData]=\"node\" class=\"angular-ui-tree-node se-tree-node__li\"><se-tree-node-renderer [node]=\"node\"></se-tree-node-renderer></li></ol>"
        }),
        __metadata("design:paramtypes", [TreeDragAndDropService])
    ], TreeNodeComponent);
    return TreeNodeComponent;
}());

var DEFAULT_PADDING_LEFT_MODIFIER_PX = 20;
window.__smartedit__.addDecoratorPayload("Component", "TreeNodeRendererComponent", {
    selector: 'se-tree-node-renderer',
    template: "<div class=\"tree-node tree-node-content se-tree-node angular-ui-tree-handle\" [ngClass]=\"{\n        'hovered': node.mouseHovered,\n        'se-tree-node--first-level': isRootNodeDescendant,\n        'se-tree-node--selected': !collapsed\n    }\" [ngStyle]=\"{\n        'padding-left': getPaddingLeft(node.level)\n    }\" [attr.level]=\"node.level\" (mouseover)=\"onMouseOver()\" (mouseout)=\"onMouseOut()\"><div *ngIf=\"!showAsList\" class=\"se-tree-node__expander--wrapper col-xs-1 text-center\"><a class=\"se-tree-node__expander btn btn-link btn-sm\" *ngIf=\"node.hasChildren\" [attr.disabled]=\"isDisabled || null\" (click)=\"toggle($event)\"><span [ngClass]=\"{\n                    'sap-icon--slim-arrow-right': collapsed,\n                    'sap-icon--slim-arrow-down': !collapsed\n                }\"></span></a></div><div *ngIf=\"displayDefaultTemplate\" class=\"se-tree-node__name col-xs-5\" [attr.title]=\"node.title | seL10n | async \"><span>{{node.name}}</span><h6 *ngIf=\"node.title\">{{node.title | seL10n | async }}</h6></div><div [ngStyle]=\"{'width': '100%'}\" *ngIf=\"tree.nodeTemplateUrl\" [ngInclude]=\"tree.nodeTemplateUrl\" [scope]=\"{node: node}\" [compileHtmlNgController]=\"legacyController\"></div><ng-container *ngIf=\"tree.nodeComponent\"><ng-container *ngComponentOutlet=\"tree.nodeComponent; injector: nodeComponentInjector\"></ng-container></ng-container></div><se-tree-node [source]=\"node.nodes\" *ngIf=\"node.nodes.length && node.isExpanded\"></se-tree-node>"
});
var TreeNodeRendererComponent = /** @class */ (function () {
    function TreeNodeRendererComponent(tree, treeService, injector) {
        this.tree = tree;
        this.treeService = treeService;
        this.injector = injector;
    }
    TreeNodeRendererComponent.prototype.ngOnInit = function () {
        this.createNodeComponentInjector();
    };
    TreeNodeRendererComponent.prototype.ngOnChanges = function (changes) {
        if (changes.node) {
            this.createNodeComponentInjector();
            this.createNodeLegacyController();
        }
    };
    TreeNodeRendererComponent.prototype.toggle = function ($event) {
        var _this = this;
        $event.stopPropagation();
        $event.preventDefault();
        this.tree.isDropDisabled = true;
        this.treeService.toggle(this.node).then(function () {
            _this.tree.isDropDisabled = false;
        });
    };
    TreeNodeRendererComponent.prototype.onMouseOver = function () {
        this.node.setMouseHovered(true);
        this.treeService.update();
    };
    TreeNodeRendererComponent.prototype.onMouseOut = function () {
        this.node.setMouseHovered(false);
        this.treeService.update();
    };
    TreeNodeRendererComponent.prototype.getPaddingLeft = function (level) {
        return (level - 1) * DEFAULT_PADDING_LEFT_MODIFIER_PX + "px";
    };
    Object.defineProperty(TreeNodeRendererComponent.prototype, "showAsList", {
        get: function () {
            return this.tree.showAsList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeNodeRendererComponent.prototype, "isDisabled", {
        get: function () {
            return this.tree.isDropDisabled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeNodeRendererComponent.prototype, "collapsed", {
        get: function () {
            return !this.node.isExpanded;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeNodeRendererComponent.prototype, "displayDefaultTemplate", {
        get: function () {
            return !this.tree.removeDefaultTemplate;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeNodeRendererComponent.prototype, "isRootNodeDescendant", {
        get: function () {
            return this.node.parentUid === 'root';
        },
        enumerable: false,
        configurable: true
    });
    TreeNodeRendererComponent.prototype.createNodeLegacyController = function () {
        var _this = this;
        this.legacyController = { value: function () { return _this.tree; }, alias: '$ctrl' };
    };
    TreeNodeRendererComponent.prototype.createNodeComponentInjector = function () {
        this.nodeComponentInjector = core.Injector.create({
            providers: [
                {
                    provide: TREE_NODE,
                    useValue: this.node
                }
            ],
            parent: this.injector
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], TreeNodeRendererComponent.prototype, "node", void 0);
    TreeNodeRendererComponent = __decorate([
        core.Component({
            selector: 'se-tree-node-renderer',
            template: "<div class=\"tree-node tree-node-content se-tree-node angular-ui-tree-handle\" [ngClass]=\"{\n        'hovered': node.mouseHovered,\n        'se-tree-node--first-level': isRootNodeDescendant,\n        'se-tree-node--selected': !collapsed\n    }\" [ngStyle]=\"{\n        'padding-left': getPaddingLeft(node.level)\n    }\" [attr.level]=\"node.level\" (mouseover)=\"onMouseOver()\" (mouseout)=\"onMouseOut()\"><div *ngIf=\"!showAsList\" class=\"se-tree-node__expander--wrapper col-xs-1 text-center\"><a class=\"se-tree-node__expander btn btn-link btn-sm\" *ngIf=\"node.hasChildren\" [attr.disabled]=\"isDisabled || null\" (click)=\"toggle($event)\"><span [ngClass]=\"{\n                    'sap-icon--slim-arrow-right': collapsed,\n                    'sap-icon--slim-arrow-down': !collapsed\n                }\"></span></a></div><div *ngIf=\"displayDefaultTemplate\" class=\"se-tree-node__name col-xs-5\" [attr.title]=\"node.title | seL10n | async \"><span>{{node.name}}</span><h6 *ngIf=\"node.title\">{{node.title | seL10n | async }}</h6></div><div [ngStyle]=\"{'width': '100%'}\" *ngIf=\"tree.nodeTemplateUrl\" [ngInclude]=\"tree.nodeTemplateUrl\" [scope]=\"{node: node}\" [compileHtmlNgController]=\"legacyController\"></div><ng-container *ngIf=\"tree.nodeComponent\"><ng-container *ngComponentOutlet=\"tree.nodeComponent; injector: nodeComponentInjector\"></ng-container></ng-container></div><se-tree-node [source]=\"node.nodes\" *ngIf=\"node.nodes.length && node.isExpanded\"></se-tree-node>"
        }),
        __param(0, core.Inject(core.forwardRef(function () { return TreeComponent; }))),
        __metadata("design:paramtypes", [TreeComponent,
            TreeService,
            core.Injector])
    ], TreeNodeRendererComponent);
    return TreeNodeRendererComponent;
}());

var NgTreeModule$1 = /** @class */ (function () {
    function NgTreeModule() {
    }
    NgTreeModule = __decorate([
        core.NgModule({
            imports: [
                CompileHtmlModule,
                dragDrop.DragDropModule,
                common.CommonModule,
                L10nPipeModule,
                utils.TranslationModule.forChild()
            ],
            declarations: [TreeComponent, TreeNodeRendererComponent, TreeNodeComponent],
            exports: [TreeComponent, TreeNodeComponent],
            entryComponents: [TreeComponent, TreeNodeRendererComponent]
        })
    ], NgTreeModule);
    return NgTreeModule;
}());

var EditableListNodeItem = /** @class */ (function (_super) {
    __extends(EditableListNodeItem, _super);
    function EditableListNodeItem(config) {
        var _this = _super.call(this, config) || this;
        _this.thumbnail = config.thumbnail || {};
        _this.id = config.id;
        _this.code = config.code;
        _this.catalogId = config.catalogId;
        _this.catalogVersion = config.catalogVersion;
        return _this;
    }
    return EditableListNodeItem;
}(TreeNodeItem));

window.__smartedit__.addDecoratorPayload("Component", "EditableListDefaultItem", {
    selector: 'se-editable-list-default-item',
    template: "\n        <div>\n            <span>{{ node.uid }}</span>\n            <se-dropdown-menu\n                *ngIf=\"parent.editable\"\n                [dropdownItems]=\"parent.getDropdownItems()\"\n                [selectedItem]=\"node\"\n                class=\"pull-right se-tree-node__actions--more-menu\"\n            ></se-dropdown-menu>\n        </div>\n    "
});
var EditableListDefaultItem = /** @class */ (function () {
    function EditableListDefaultItem(parent, node) {
        this.parent = parent;
        this.node = node;
    }
    EditableListDefaultItem = __decorate([
        core.Component({
            selector: 'se-editable-list-default-item',
            template: "\n        <div>\n            <span>{{ node.uid }}</span>\n            <se-dropdown-menu\n                *ngIf=\"parent.editable\"\n                [dropdownItems]=\"parent.getDropdownItems()\"\n                [selectedItem]=\"node\"\n                class=\"pull-right se-tree-node__actions--more-menu\"\n            ></se-dropdown-menu>\n        </div>\n    "
        }),
        __param(0, core.Inject(core.forwardRef(function () { return EditableListComponent; }))),
        __param(1, core.Inject(TREE_NODE)),
        __metadata("design:paramtypes", [EditableListComponent, Object])
    ], EditableListDefaultItem);
    return EditableListDefaultItem;
}());
window.__smartedit__.addDecoratorPayload("Component", "EditableListComponent", {
    selector: 'se-editable-list',
    template: "<div [ngClass]=\"{ 'y-editable-list-disabled': !editable, 'se-editable-list-disabled': !editable }\"><se-tree (onTreeUpdated)=\"handleTreeUpdated($event)\" [removeDefaultTemplate]=\"true\" [rootNodeUid]=\"rootId\" [nodeTemplateUrl]=\"itemTemplateUrl\" [nodeComponent]=\"itemComponent\" [nodeActions]=\"actions\" [dragOptions]=\"dragOptions\" [showAsList]=\"true\"></se-tree></div>"
});
var /* @ngInject */ EditableListComponent = /** @class */ (function () {
    function /* @ngInject */ EditableListComponent() {
        this.refreshChange = new core.EventEmitter();
        this.itemsChange = new core.EventEmitter();
        this.dragOptions = {};
        this.itemsOld = [];
    }
    /* @ngInject */ EditableListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this._enableDragAndDrop = function () {
            _this.dragOptions.allowDropCallback = function (event) {
                return event.sourceNode.parentUid === _this.rootId;
            };
        };
        this.actions = this.getTreeActions();
        this.refreshChange.emit(function () { return _this.actions.refreshList(); });
        if (!this.itemTemplateUrl && !this.itemComponent) {
            this.itemComponent = EditableListDefaultItem;
        }
        this.rootId = 'root' + this.id;
        if (this.editable === undefined) {
            this.editable = true;
        }
        if (this.editable === true) {
            this._enableDragAndDrop();
        }
    };
    /* @ngInject */ EditableListComponent.prototype.handleTreeUpdated = function (items) {
        if (this.hasItemsChanged(this.itemsOld, items)) {
            this.itemsOld = items;
            this.itemsChange.emit(items);
            this.actions.performUpdate();
        }
    };
    EditableListComponent.prototype.handleTreeUpdated.$inject = ["items"];
    /* @ngInject */ EditableListComponent.prototype.getDropdownItems = function () {
        var _this = this;
        return [
            {
                key: 'se.ydropdownmenu.remove',
                callback: function (handle) {
                    _this.actions.removeItem(handle);
                }
            },
            {
                key: 'se.ydropdownmenu.move.up',
                condition: function (handle) {
                    return _this.actions.isMoveUpAllowed(handle);
                },
                callback: function (handle) {
                    _this.actions.moveUp(handle);
                }
            },
            {
                key: 'se.ydropdownmenu.move.down',
                condition: function (handle) {
                    return _this.actions.isMoveDownAllowed(handle);
                },
                callback: function (handle) {
                    _this.actions.moveDown(handle);
                }
            }
        ];
    };
    /* @ngInject */ EditableListComponent.prototype.hasItemsChanged = function (oldItems, newItems) {
        var oldUids = oldItems.map(function (_a) {
            var uid = _a.uid;
            return uid;
        });
        var newUids = newItems.map(function (_a) {
            var uid = _a.uid;
            return uid;
        });
        return !lodash.isEqual(oldUids, newUids);
    };
    EditableListComponent.prototype.hasItemsChanged.$inject = ["oldItems", "newItems"];
    /* @ngInject */ EditableListComponent.prototype.getTreeActions = function () {
        var _this = this;
        var items = this.getDropdownItems();
        return {
            fetchData: function (treeService, nodeData) {
                var nodeItems = _this.items.map(function (dto) { return new EditableListNodeItem(dto); });
                nodeItems.forEach(function (item) {
                    if (item.id && !item.uid) {
                        item.uid = item.id;
                    }
                    item.setParent(nodeData);
                });
                nodeData.removeAllNodes().addNodes(nodeItems);
                treeService.update();
                return Promise.resolve(nodeData);
            },
            getDropdownItems: function () { return items; },
            removeItem: function (treeService, nodeData) {
                nodeData.parent.removeNode(nodeData);
                treeService.update();
            },
            moveUp: function (treeService, nodeData) {
                treeService.rearrange(nodeData, treeService.root, nodeData.position - 1);
            },
            moveDown: function (treeService, nodeData) {
                treeService.rearrange(nodeData, treeService.root, nodeData.position + 1);
            },
            isMoveUpAllowed: function (treeService, nodeData) {
                return nodeData.position > 0;
            },
            isMoveDownAllowed: function (treeService, nodeData) {
                return treeService.root.nodes.length !== nodeData.position + 1;
            },
            performUpdate: function (treeService) {
                if (_this.onChange) {
                    _this.onChange();
                }
            },
            refreshList: function (treeService) {
                this.fetchData(treeService.root);
            }
        };
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ EditableListComponent.prototype, "refresh", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ EditableListComponent.prototype, "items", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ EditableListComponent.prototype, "onChange", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EditableListComponent.prototype, "itemTemplateUrl", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", core.Type)
    ], /* @ngInject */ EditableListComponent.prototype, "itemComponent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Boolean)
    ], /* @ngInject */ EditableListComponent.prototype, "editable", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EditableListComponent.prototype, "id", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ EditableListComponent.prototype, "refreshChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ EditableListComponent.prototype, "itemsChange", void 0);
    /* @ngInject */ EditableListComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-editable-list',
            template: "<div [ngClass]=\"{ 'y-editable-list-disabled': !editable, 'se-editable-list-disabled': !editable }\"><se-tree (onTreeUpdated)=\"handleTreeUpdated($event)\" [removeDefaultTemplate]=\"true\" [rootNodeUid]=\"rootId\" [nodeTemplateUrl]=\"itemTemplateUrl\" [nodeComponent]=\"itemComponent\" [nodeActions]=\"actions\" [dragOptions]=\"dragOptions\" [showAsList]=\"true\"></se-tree></div>"
        })
    ], /* @ngInject */ EditableListComponent);
    return /* @ngInject */ EditableListComponent;
}());

var EditableListModule = /** @class */ (function () {
    function EditableListModule() {
    }
    EditableListModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, NgTreeModule$1, DropdownMenuModule],
            declarations: [EditableListComponent, EditableListDefaultItem],
            entryComponents: [EditableListComponent, EditableListDefaultItem],
            exports: [EditableListComponent, EditableListDefaultItem]
        })
    ], EditableListModule);
    return EditableListModule;
}());

/**
 * **Deprecated since 2005, use {@link EditableListComponent}.**
 *
 * The yEditableList component allows displaying a list of items. The list can be managed dynamically, by
 * adding, removing, and re-ordering it.
 *
 * ### Parameters
 *
 * `id` - A string used to track and identify the component.
 *
 * `items` - The collection of items to display in the component.
 *
 * `refresh` - A function that can be called to update the content of the list.
 *
 * `onChange` - A function that will be called whenever the content of the list changes.
 *
 * `itemTemplateUrl` - The path to the template to display each of the items in the list.
 *
 * `editable` - The property specifies whether the content of the list can be modified.
 *
 * @deprecated
 */
var /* @ngInject */ YEditableListComponent = /** @class */ (function () {
    function /* @ngInject */ YEditableListComponent() {
        this.dragOptions = {};
    }
    /* @ngInject */ YEditableListComponent.prototype.$onInit = function () {
        var _this = this;
        this._enableDragAndDrop = function () {
            _this.dragOptions.allowDropCallback = function (event) {
                // Just allow dropping elements of the same list.
                return event.sourceNode.parentUid === _this.rootId;
            };
            _this.dragOptions.onDropCallback = function () {
                _this.actions.performUpdate();
            };
        };
        this.actions = this.getTreeActions();
        this.refresh = function () {
            _this.actions.refreshList();
        };
        if (!this.itemTemplateUrl) {
            this.itemTemplateUrl = 'yEditableListDefaultItemTemplate.html';
        }
        this.rootId = 'root' + this.id;
        if (this.editable === undefined) {
            this.editable = true;
        }
        if (this.editable === true) {
            this._enableDragAndDrop();
        }
    };
    /* @ngInject */ YEditableListComponent.prototype.getTreeActions = function () {
        var _this = this;
        var items = this.getDropdownItems();
        return {
            fetchData: function (treeService, nodeData) {
                _this.items.map(function (item) {
                    if (item.id && !item.uid) {
                        item.uid = item.id;
                    }
                    item.parentUid = _this.rootId;
                });
                nodeData.nodes = _this.items;
                return Promise.resolve(nodeData);
            },
            getDropdownItems: function () { return items; },
            removeItem: function (treeService, handle) {
                var nodeData = handle.$modelValue;
                var pos = this.root.nodes.indexOf(nodeData);
                this.root.nodes.splice(pos, 1);
                this.performUpdate(parent, handle);
            },
            moveUp: function (treeService, handle) {
                var nodeData = handle.$modelValue;
                var pos = this.root.nodes.indexOf(nodeData);
                var upperEntry = this.root.nodes[pos - 1];
                this.root.nodes.splice(pos - 1, 2, nodeData, upperEntry);
                this.performUpdate(parent, handle);
            },
            moveDown: function (treeService, handle) {
                var nodeData = handle.$modelValue;
                var pos = this.root.nodes.indexOf(nodeData);
                var lowerEntry = this.root.nodes[pos + 1];
                this.root.nodes.splice(pos, 2, lowerEntry, nodeData);
                this.performUpdate(parent, handle);
            },
            isMoveUpAllowed: function (treeService, handle) {
                var nodeData = handle.$modelValue;
                return this.root.nodes.indexOf(nodeData) > 0;
            },
            isMoveDownAllowed: function (treeService, handle) {
                var nodeData = handle.$modelValue;
                var entriesArrayLength = this.root.nodes.length;
                return this.root.nodes.indexOf(nodeData) !== entriesArrayLength - 1;
            },
            performUpdate: function () {
                if (_this.onChange) {
                    _this.onChange();
                }
            },
            refreshList: function () {
                this.fetchData(this.root);
            }
        };
    };
    /* @ngInject */ YEditableListComponent.prototype.getDropdownItems = function () {
        var _this = this;
        return [
            {
                key: 'se.ydropdownmenu.remove',
                callback: function (handle) {
                    _this.actions.removeItem(handle);
                }
            },
            {
                key: 'se.ydropdownmenu.move.up',
                condition: function (handle) { return _this.actions.isMoveUpAllowed(handle); },
                callback: function (handle) {
                    _this.actions.moveUp(handle);
                }
            },
            {
                key: 'se.ydropdownmenu.move.down',
                condition: function (handle) { return _this.actions.isMoveDownAllowed(handle); },
                callback: function (handle) {
                    _this.actions.moveDown(handle);
                }
            }
        ];
    };
    /* @ngInject */ YEditableListComponent = __decorate([
        SeComponent({
            selector: 'y-editable-list',
            templateUrl: 'yEditableListTemplate.html',
            inputs: ['id:@', 'items', 'refresh:=', 'onChange', 'itemTemplateUrl', 'editable']
        })
    ], /* @ngInject */ YEditableListComponent);
    return /* @ngInject */ YEditableListComponent;
}());

/**
 * The yEditableList module contains a component which allows displaying a list of elements. The items in
 * that list can be added, removed, and re-ordered.
 */
var /* @ngInject */ YEditableListModule = /** @class */ (function () {
    function /* @ngInject */ YEditableListModule() {
    }
    /* @ngInject */ YEditableListModule = __decorate([
        SeModule({
            imports: [TreeModule],
            declarations: [YEditableListComponent]
        })
    ], /* @ngInject */ YEditableListModule);
    return /* @ngInject */ YEditableListModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "MessageComponent", {
    selector: 'se-message',
    template: "\n        <div\n            [attr.message-id]=\"messageId\"\n            class=\"fd-alert se-y-message\"\n            role=\"alert\"\n            [ngClass]=\"classes\"\n        >\n            <div class=\"y-message-text\">\n                <div class=\"y-message-info-title\">\n                    <ng-content select=\"[se-message-title]\"></ng-content>\n                </div>\n                <div class=\"y-message-info-description\">\n                    <ng-content select=\"[se-message-description]\"></ng-content>\n                </div>\n            </div>\n        </div>\n    "
});
/**
 *  This component provides contextual feedback messages for the user actions. To provide title and description for the se-essage
 *  use transcluded elements: se-message-title and se-message-description.
 *
 *  ### Example
 *
 *      <se-message>
 *          <div se-message-title>Title</div>
 *          <div se-message-description>Description</div>
 *      </se-message>
 */
var /* @ngInject */ MessageComponent = /** @class */ (function () {
    function /* @ngInject */ MessageComponent() {
    }
    /* @ngInject */ MessageComponent.prototype.ngOnInit = function () {
        this.messageId = this.messageId || 'y-message-default-id';
        switch (this.type) {
            case 'danger':
                this.classes = 'fd-alert--error';
                break;
            case 'info':
                this.classes = 'fd-alert--information';
                break;
            case 'success':
                this.classes = 'fd-alert--success';
                break;
            case 'warning':
                this.classes = 'fd-alert--warning';
                break;
            default:
                this.classes = 'fd-alert--information';
        }
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MessageComponent.prototype, "messageId", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MessageComponent.prototype, "type", void 0);
    /* @ngInject */ MessageComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-message',
            template: "\n        <div\n            [attr.message-id]=\"messageId\"\n            class=\"fd-alert se-y-message\"\n            role=\"alert\"\n            [ngClass]=\"classes\"\n        >\n            <div class=\"y-message-text\">\n                <div class=\"y-message-info-title\">\n                    <ng-content select=\"[se-message-title]\"></ng-content>\n                </div>\n                <div class=\"y-message-info-description\">\n                    <ng-content select=\"[se-message-description]\"></ng-content>\n                </div>\n            </div>\n        </div>\n    "
        })
    ], /* @ngInject */ MessageComponent);
    return /* @ngInject */ MessageComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "EventMessageComponent", {
    selector: 'se-event-message',
    template: "\n        <div>\n            <se-message [type]=\"type\" *ngIf=\"show\">\n                <ng-container *ngIf=\"showTitle()\" se-message-title>\n                    {{ title | translate }}\n                </ng-container>\n                <ng-container *ngIf=\"showDescription()\" se-message-description>\n                    {{ description | translate }}\n                </ng-container>\n            </se-message>\n        </div>\n    "
});
/**
 * Wrapper around se-message, used to display or hide the message based on events sent through the {@link SystemEventService}.
 */
var /* @ngInject */ EventMessageComponent = /** @class */ (function () {
    EventMessageComponent.$inject = ["systemEventService"];
    function /* @ngInject */ EventMessageComponent(systemEventService) {
        this.systemEventService = systemEventService;
        this.show = false;
    }
    /* @ngInject */ EventMessageComponent.prototype.ngOnInit = function () {
        this.show = this.showToStart === 'true' || this.showToStart === true;
        this.watchShowEventChange();
        this.watchHideEventChange();
    };
    /* @ngInject */ EventMessageComponent.prototype.ngOnDestroy = function () {
        this.removeShowEventHandler();
        this.removeHideEventHandler();
    };
    /* @ngInject */ EventMessageComponent.prototype.ngOnChanges = function (changes) {
        if (changes.showEvent) {
            this.watchShowEventChange();
        }
        if (changes.hideEvent) {
            this.watchHideEventChange();
        }
    };
    EventMessageComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ EventMessageComponent.prototype.showDescription = function () {
        return typeof this.description === 'string' && this.description.length > 0;
    };
    /* @ngInject */ EventMessageComponent.prototype.showTitle = function () {
        return typeof this.title === 'string' && this.title.length > 0;
    };
    /* @ngInject */ EventMessageComponent.prototype.showEventHandler = function (eventId, eventData) {
        if (eventData.description && eventData.description.length) {
            this.description = eventData.description;
        }
        if (eventData.title && eventData.title.length) {
            this.title = eventData.title;
        }
        this.show = true;
    };
    EventMessageComponent.prototype.showEventHandler.$inject = ["eventId", "eventData"];
    /* @ngInject */ EventMessageComponent.prototype.removeHideEventHandler = function () {
        if (this.unregisterHideEventHandler) {
            this.unregisterHideEventHandler();
        }
    };
    /* @ngInject */ EventMessageComponent.prototype.removeShowEventHandler = function () {
        if (this.unregisterShowEventHandler) {
            this.unregisterShowEventHandler();
        }
    };
    /* @ngInject */ EventMessageComponent.prototype.watchShowEventChange = function () {
        var _this = this;
        this.removeShowEventHandler();
        this.unregisterShowEventHandler = this.systemEventService.subscribe(this.showEvent, function (eventId, eventData) { return _this.showEventHandler(eventId, eventData); });
    };
    /* @ngInject */ EventMessageComponent.prototype.watchHideEventChange = function () {
        var _this = this;
        this.removeHideEventHandler();
        this.unregisterHideEventHandler = this.systemEventService.subscribe(this.hideEvent, function () { return (_this.show = false); });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EventMessageComponent.prototype, "type", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EventMessageComponent.prototype, "title", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EventMessageComponent.prototype, "description", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EventMessageComponent.prototype, "showEvent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ EventMessageComponent.prototype, "hideEvent", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ EventMessageComponent.prototype, "showToStart", void 0);
    /* @ngInject */ EventMessageComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-event-message',
            template: "\n        <div>\n            <se-message [type]=\"type\" *ngIf=\"show\">\n                <ng-container *ngIf=\"showTitle()\" se-message-title>\n                    {{ title | translate }}\n                </ng-container>\n                <ng-container *ngIf=\"showDescription()\" se-message-description>\n                    {{ description | translate }}\n                </ng-container>\n            </se-message>\n        </div>\n    "
        }),
        __metadata("design:paramtypes", [SystemEventService])
    ], /* @ngInject */ EventMessageComponent);
    return /* @ngInject */ EventMessageComponent;
}());

/**
 * This module provides the se-message component, which is responsible for rendering contextual
 * feedback messages for the user actions.
 */
var MessageModule = /** @class */ (function () {
    function MessageModule() {
    }
    MessageModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, core$1.TranslateModule.forChild()],
            declarations: [MessageComponent, EventMessageComponent],
            entryComponents: [MessageComponent, EventMessageComponent],
            exports: [MessageComponent, EventMessageComponent]
        })
    ], MessageModule);
    return MessageModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var POPUP_OVERLAY_DATA = new core.InjectionToken('POPUP_OVERLAY_DATA');

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
(function (PopoverTrigger) {
    PopoverTrigger["Hover"] = "hover";
    PopoverTrigger["Click"] = "click";
})(exports.PopoverTrigger || (exports.PopoverTrigger = {}));

window.__smartedit__.addDecoratorPayload("Component", "PopupOverlayComponent", {
    selector: 'se-popup-overlay',
    template: "\n        <fd-popover\n            [placement]=\"getPlacement()\"\n            [noArrow]=\"true\"\n            [appendTo]=\"appendTo\"\n            [triggers]=\"trigger.length && trigger\"\n            (isOpenChange)=\"handleOpenChange($event)\"\n            [additionalClasses]=\"['se-popup-overlay-container']\"\n            class=\"popup-overlay popover-outer\"\n        >\n            <fd-popover-control> <ng-content></ng-content> </fd-popover-control>\n\n            <fd-popover-body #popoverBody class=\"popover-inner popup-overlay__inner\">\n                <ng-container *ngIf=\"isOpen\">\n                    <div\n                        *ngIf=\"popupOverlay.template\"\n                        [seCompileHtml]=\"popupOverlay.template\"\n                        [scope]=\"popupOverlayData\"\n                        [compileHtmlNgController]=\"popupOverlay.legacyController\"\n                    ></div>\n                    <div\n                        *ngIf=\"popupOverlay.templateUrl\"\n                        [ngInclude]=\"popupOverlay.templateUrl\"\n                        [scope]=\"popupOverlayData\"\n                        [compileHtmlNgController]=\"popupOverlay.legacyController\"\n                    ></div>\n                    <ng-container *ngIf=\"popupOverlay.component\">\n                        <ng-container\n                            *ngComponentOutlet=\"\n                                popupOverlay.component;\n                                injector: popupOverlayInjector\n                            \"\n                        ></ng-container>\n                    </ng-container>\n                    <ng-content select=\"[se-popup-overlay-body]\"></ng-content>\n                </ng-container>\n            </fd-popover-body>\n        </fd-popover>\n    ",
    styles: [".se-popup-overlay-container{z-index:1060!important}"],
    encapsulation: core.ViewEncapsulation.None
});
var /* @ngInject */ PopupOverlayComponent = /** @class */ (function () {
    PopupOverlayComponent.$inject = ["injector"];
    function /* @ngInject */ PopupOverlayComponent(injector) {
        this.injector = injector;
        this.popupOverlayOnShow = new core.EventEmitter();
        this.popupOverlayOnHide = new core.EventEmitter();
        this.trigger = [];
    }
    /* @ngInject */ PopupOverlayComponent.prototype.ngOnInit = function () {
        this.setTrigger();
        this.createInjector();
        this.appendTo = windowUtils.isIframe()
            ? document.getElementById('smarteditoverlay')
            : document.getElementsByTagName('body')[0];
    };
    /* @ngInject */ PopupOverlayComponent.prototype.ngOnChanges = function (changes) {
        if (changes.popupOverlayTrigger) {
            this.setTrigger();
        }
        if (changes.popupOverlayData) {
            this.createInjector();
        }
    };
    PopupOverlayComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ PopupOverlayComponent.prototype.handleOpenChange = function (isOpen) {
        return isOpen ? this.handleOpen() : this.handleClose();
    };
    PopupOverlayComponent.prototype.handleOpenChange.$inject = ["isOpen"];
    /* @ngInject */ PopupOverlayComponent.prototype.handleOpen = function () {
        this.isOpen = true;
        this.popupOverlayOnShow.emit();
    };
    /* @ngInject */ PopupOverlayComponent.prototype.handleClose = function () {
        this.isOpen = false;
        this.popupOverlayOnHide.emit();
    };
    /* @ngInject */ PopupOverlayComponent.prototype.getPlacement = function () {
        return (this.popupOverlay.valign || 'bottom') + "-" + this.getHorizontalAlign();
    };
    /* @ngInject */ PopupOverlayComponent.prototype.setTrigger = function () {
        if (this.popupOverlayTrigger === exports.PopoverTrigger.Click) {
            this.trigger = [this.popupOverlayTrigger];
        }
        if (this.popupOverlayTrigger === exports.PopoverTrigger.Hover) {
            this.trigger = ['mouseenter', 'mouseleave'];
        }
        if (!this.popover) {
            return;
        }
        if (this.popupOverlayTrigger === 'true' || this.popupOverlayTrigger === true) {
            this.popover.open();
        }
        else {
            this.popover.close();
        }
    };
    /* @ngInject */ PopupOverlayComponent.prototype.getHorizontalAlign = function () {
        if (!this.popupOverlay.halign) {
            return 'start';
        }
        return this.popupOverlay.halign === 'right' ? 'start' : 'end';
    };
    /* @ngInject */ PopupOverlayComponent.prototype.createInjector = function () {
        this.popupOverlayInjector = core.Injector.create({
            providers: [
                {
                    provide: POPUP_OVERLAY_DATA,
                    useValue: this.popupOverlayData || {}
                }
            ],
            parent: this.injector
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popupOverlay", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popupOverlayTrigger", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popupOverlayData", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popupOverlayOnShow", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popupOverlayOnHide", void 0);
    __decorate([
        core.ViewChild(core$2.PopoverComponent, { static: false }),
        __metadata("design:type", core$2.PopoverComponent)
    ], /* @ngInject */ PopupOverlayComponent.prototype, "popover", void 0);
    /* @ngInject */ PopupOverlayComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-popup-overlay',
            template: "\n        <fd-popover\n            [placement]=\"getPlacement()\"\n            [noArrow]=\"true\"\n            [appendTo]=\"appendTo\"\n            [triggers]=\"trigger.length && trigger\"\n            (isOpenChange)=\"handleOpenChange($event)\"\n            [additionalClasses]=\"['se-popup-overlay-container']\"\n            class=\"popup-overlay popover-outer\"\n        >\n            <fd-popover-control> <ng-content></ng-content> </fd-popover-control>\n\n            <fd-popover-body #popoverBody class=\"popover-inner popup-overlay__inner\">\n                <ng-container *ngIf=\"isOpen\">\n                    <div\n                        *ngIf=\"popupOverlay.template\"\n                        [seCompileHtml]=\"popupOverlay.template\"\n                        [scope]=\"popupOverlayData\"\n                        [compileHtmlNgController]=\"popupOverlay.legacyController\"\n                    ></div>\n                    <div\n                        *ngIf=\"popupOverlay.templateUrl\"\n                        [ngInclude]=\"popupOverlay.templateUrl\"\n                        [scope]=\"popupOverlayData\"\n                        [compileHtmlNgController]=\"popupOverlay.legacyController\"\n                    ></div>\n                    <ng-container *ngIf=\"popupOverlay.component\">\n                        <ng-container\n                            *ngComponentOutlet=\"\n                                popupOverlay.component;\n                                injector: popupOverlayInjector\n                            \"\n                        ></ng-container>\n                    </ng-container>\n                    <ng-content select=\"[se-popup-overlay-body]\"></ng-content>\n                </ng-container>\n            </fd-popover-body>\n        </fd-popover>\n    ",
            styles: [".se-popup-overlay-container{z-index:1060!important}"],
            encapsulation: core.ViewEncapsulation.None
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], /* @ngInject */ PopupOverlayComponent);
    return /* @ngInject */ PopupOverlayComponent;
}());

var PopupOverlayModule = /** @class */ (function () {
    function PopupOverlayModule() {
    }
    PopupOverlayModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, core$2.PopoverModule, CompileHtmlModule],
            declarations: [PopupOverlayComponent],
            entryComponents: [PopupOverlayComponent],
            exports: [PopupOverlayComponent]
        })
    ], PopupOverlayModule);
    return PopupOverlayModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "PreventVerticalOverflowComponent", {
    selector: 'se-prevent-vertical-overflow',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: "\n        <div #container [ngStyle]=\"containerStyle\">\n            <ng-content></ng-content>\n        </div>\n    "
});
/**
 * Component used to detect whether it's children are vertically overflowing the document.
 *
 * In case of overflow it sets it's max-height to the difference between top position and document bottom, and enables scrolling.
 */
var /* @ngInject */ PreventVerticalOverflowComponent = /** @class */ (function () {
    PreventVerticalOverflowComponent.$inject = ["document", "cdr"];
    function /* @ngInject */ PreventVerticalOverflowComponent(document, cdr) {
        this.document = document;
        this.cdr = cdr;
        this.containerStyle = {
            'max-height.px': null,
            overflow: null
        };
    }
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.onWindowResize = function () {
        if (this.containerElement) {
            this.onResize();
        }
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        // when user opens popover, it will be called once to check for overflow
        this.observer = new IntersectionObserver(function (_a) {
            var event = _a[0];
            if (event.isIntersecting) {
                _this.onResize();
            }
        }, { root: this.document, threshold: 0 });
        this.observer.observe(this.containerElement.nativeElement);
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.ngOnDestroy = function () {
        this.observer.unobserve(this.containerElement.nativeElement);
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.onResize = function () {
        var _a = this.getContainerBoundingClientRect(), top = _a.top, height = _a.height;
        // popover is not opened
        if (top === 0 && height === 0) {
            return;
        }
        this.preventOverflow(top, height);
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.preventOverflow = function (containerTop, containerHeight) {
        var didPrevent = this.preventIfOverflowing(containerTop, containerHeight);
        // If I zoom out, "didPrevent" may return false because it has set overflow and max-height.
        // In such a case, I need either to stop preventing overflow or stretch the container height for better UX.
        // To achieve that, I display it without max-height being set and then I check again whether it is overflowing.
        // If it is, I stretch the container. If it doesn't, remove max-height and overflow styles so it sets the height based on its content.
        if (!didPrevent && this.containerStyle['max-height.px']) {
            this.reset();
            var _a = this.getContainerBoundingClientRect(), top_1 = _a.top, height = _a.height;
            this.preventIfOverflowing(top_1, height);
        }
    };
    PreventVerticalOverflowComponent.prototype.preventOverflow.$inject = ["containerTop", "containerHeight"];
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.preventIfOverflowing = function (top, height) {
        if (this.isOverflowing(top, height)) {
            this.prevent(top);
            return true;
        }
        return false;
    };
    PreventVerticalOverflowComponent.prototype.preventIfOverflowing.$inject = ["top", "height"];
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.isOverflowing = function (top, height) {
        var documentHeight = this.getDocumentHeight();
        return documentHeight < top + height;
    };
    PreventVerticalOverflowComponent.prototype.isOverflowing.$inject = ["top", "height"];
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.prevent = function (elementTop) {
        var documentHeight = this.getDocumentHeight();
        var maxHeight = documentHeight - elementTop;
        this.containerStyle['max-height.px'] = maxHeight;
        this.containerStyle.overflow = 'auto';
        this.cdr.detectChanges();
    };
    PreventVerticalOverflowComponent.prototype.prevent.$inject = ["elementTop"];
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.reset = function () {
        this.containerStyle['max-height.px'] = null;
        this.containerStyle.overflow = null;
        this.cdr.detectChanges();
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.getContainerBoundingClientRect = function () {
        return this.containerElement.nativeElement.getBoundingClientRect();
    };
    /* @ngInject */ PreventVerticalOverflowComponent.prototype.getDocumentHeight = function () {
        var height = this.document.documentElement.getBoundingClientRect().height;
        return height;
    };
    __decorate([
        core.ViewChild('container', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ PreventVerticalOverflowComponent.prototype, "containerElement", void 0);
    __decorate([
        core.HostListener('window:resize'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], /* @ngInject */ PreventVerticalOverflowComponent.prototype, "onWindowResize", null);
    /* @ngInject */ PreventVerticalOverflowComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-prevent-vertical-overflow',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            template: "\n        <div #container [ngStyle]=\"containerStyle\">\n            <ng-content></ng-content>\n        </div>\n    "
        }),
        __param(0, core.Inject(common.DOCUMENT)),
        __metadata("design:paramtypes", [Document, core.ChangeDetectorRef])
    ], /* @ngInject */ PreventVerticalOverflowComponent);
    return /* @ngInject */ PreventVerticalOverflowComponent;
}());

var PreventVerticalOverflowModule = /** @class */ (function () {
    function PreventVerticalOverflowModule() {
    }
    PreventVerticalOverflowModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule],
            declarations: [PreventVerticalOverflowComponent],
            entryComponents: [PreventVerticalOverflowComponent],
            exports: [PreventVerticalOverflowComponent]
        })
    ], PreventVerticalOverflowModule);
    return PreventVerticalOverflowModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "HelpComponent", {
    selector: 'se-help',
    template: "<se-tooltip [triggers]=\"['mouseenter', 'mouseleave']\" placement=\"auto\" [isChevronVisible]=\"true\" [title]=\"title\" class=\"se-help\"><span se-tooltip-trigger class=\"sap-icon--sys-help se-y-help-icon\"></span><ng-container se-tooltip-body><div *ngIf=\"template\" [seCompileHtml]=\"template\"></div><div *ngIf=\"templateUrl\" [ngInclude]=\"templateUrl\"></div></ng-container><ng-content se-tooltip-body></ng-content></se-tooltip>"
});
var /* @ngInject */ HelpComponent = /** @class */ (function () {
    function /* @ngInject */ HelpComponent() {
    }
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ HelpComponent.prototype, "title", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ HelpComponent.prototype, "template", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ HelpComponent.prototype, "templateUrl", void 0);
    /* @ngInject */ HelpComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-help',
            template: "<se-tooltip [triggers]=\"['mouseenter', 'mouseleave']\" placement=\"auto\" [isChevronVisible]=\"true\" [title]=\"title\" class=\"se-help\"><span se-tooltip-trigger class=\"sap-icon--sys-help se-y-help-icon\"></span><ng-container se-tooltip-body><div *ngIf=\"template\" [seCompileHtml]=\"template\"></div><div *ngIf=\"templateUrl\" [ngInclude]=\"templateUrl\"></div></ng-container><ng-content se-tooltip-body></ng-content></se-tooltip>"
        })
    ], /* @ngInject */ HelpComponent);
    return /* @ngInject */ HelpComponent;
}());

var HelpModule = /** @class */ (function () {
    function HelpModule() {
    }
    HelpModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, TooltipModule, CompileHtmlModule],
            declarations: [HelpComponent],
            entryComponents: [HelpComponent],
            exports: [HelpComponent]
        })
    ], HelpModule);
    return HelpModule;
}());

var SliderPanelZIndexHelper = /** @class */ (function () {
    function SliderPanelZIndexHelper() {
    }
    /** Retrieve a highest value from array of zIndex integers. */
    SliderPanelZIndexHelper.prototype.getHighestZIndex = function (node) {
        var _this = this;
        return Math.max.apply(Math, this.getChildrenNodesFromTreeOrLeaf(node[0])
            .filter(function (elem) { return _this.filterBlacklistedNodes(elem); })
            .map(function (elem) { return _this.mapToZIndexIntegers(elem); }));
    };
    SliderPanelZIndexHelper.prototype.filterBlacklistedNodes = function (elem) {
        return !SliderPanelZIndexHelper.BLACKLISTED_NODE_NAMES.has(elem.nodeName);
    };
    /** Retrieve zIndex integer value from node, fallback with 0 value in case of NaN. */
    SliderPanelZIndexHelper.prototype.mapToZIndexIntegers = function (elem) {
        return parseInt(angular$1.element(elem).css('z-index'), 10) || 0;
    };
    /** Return recurring flat array of node and it's children. */
    SliderPanelZIndexHelper.prototype.getChildrenNodesFromTreeOrLeaf = function (node) {
        var _this = this;
        return __spreadArrays([
            node
        ], lodash.flatten(Array.from(node.children).map(function (child) {
            return _this.getChildrenNodesFromTreeOrLeaf(child);
        })));
    };
    SliderPanelZIndexHelper.BLACKLISTED_NODE_NAMES = new Set(['SCRIPT', 'LINK', 'BASE']);
    return SliderPanelZIndexHelper;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * The SliderPanelService handles the initialization and the rendering of the se-slider-panel Angular component.
 */
var SliderPanelService = /** @class */ (function () {
    function SliderPanelService(element, window, configuration, yjQuery) {
        this.element = element;
        this.window = window;
        this.configuration = configuration;
        this.yjQuery = yjQuery;
        this.inlineStyling = { container: {}, content: {} };
        this.sliderPanelDefaultConfiguration = {
            slideFrom: 'right',
            overlayDimension: '80%'
        };
        this.init();
    }
    /**
     * This method sets the inline styling applied to the slider panel container according to the dimension and position values
     * of the parent element.
     */
    SliderPanelService.prototype.updateContainerInlineStyling = function (screenResized) {
        var parentClientRect = this.parent[0].getBoundingClientRect();
        var borders = {
            left: this.parent.css('border-left-width')
                ? parseInt(this.parent.css('border-left-width').replace('px', ''), 10)
                : 0,
            top: this.parent.css('border-top-width')
                ? parseInt(this.parent.css('border-top-width').replace('px', ''), 10)
                : 0
        };
        this.inlineStyling.container.height = this.parent[0].clientHeight + 'px';
        this.inlineStyling.container.width = this.parent[0].clientWidth + 'px';
        this.inlineStyling.container.left =
            (this.appendChildTarget.nodeName === 'BODY'
                ? Math.round(parentClientRect.left + this.window.pageXOffset + borders.left)
                : 0) + 'px';
        this.inlineStyling.container.top =
            (this.appendChildTarget.nodeName === 'BODY'
                ? Math.round(parentClientRect.top + this.window.pageYOffset + borders.top)
                : 0) + 'px';
        // z-index value is not set during screen resize
        if (!screenResized) {
            this.inlineStyling.container.zIndex = this.sliderPanelConfiguration.zIndex
                ? this.sliderPanelConfiguration.zIndex.toString()
                : (this.returningHigherZIndex() + 1).toString();
        }
    };
    SliderPanelService.prototype.returningHigherZIndex = function () {
        return new SliderPanelZIndexHelper().getHighestZIndex(this.yjQuery('body'));
    };
    SliderPanelService.prototype.initializeParentRawElement = function () {
        // instantiating "parent" local variable
        var parentRawElement = this.sliderPanelConfiguration.cssSelector
            ? document.querySelector(this.sliderPanelConfiguration.cssSelector)
            : null;
        this.parent = this.yjQuery(parentRawElement || this.element.parent());
    };
    SliderPanelService.prototype.initializePanelConfiguration = function () {
        // defining the configuration set on the processed slider panel by merging the JSON object provided as parameter
        // with the default configuration
        this.sliderPanelConfiguration = lodash.defaultsDeep(this.configuration, this.sliderPanelDefaultConfiguration);
    };
    SliderPanelService.prototype.initializeInlineStyles = function () {
        // setting the inline styling applied on the slider panel content according to its configuration.
        var key = ['top', 'bottom'].indexOf(this.sliderPanelConfiguration.slideFrom) === -1
            ? 'width'
            : 'height';
        this.inlineStyling.content[key] = this.sliderPanelConfiguration.overlayDimension;
    };
    SliderPanelService.prototype.initializeChildTarget = function () {
        // instantiating "appendChildTarget" local variable
        var testedElement = this.parent;
        var modalFound = false;
        var i = 0;
        for (i; testedElement[0].nodeName !== 'BODY'; testedElement = this.yjQuery(testedElement.parent()), i++) {
            var isFundamentalModal = (testedElement[0].getAttribute('class') || '').includes('fd-modal__content');
            var isLegacyModal = testedElement[0].getAttribute('id') === 'y-modal-dialog';
            if (isFundamentalModal || isLegacyModal) {
                modalFound = true;
                break;
            }
        }
        this.appendChildTarget = modalFound ? testedElement[0] : document.body;
    };
    SliderPanelService.prototype.append = function () {
        // appending the slider panel HTML tag as last child of the HTML body tag.
        this.yjQuery(this.appendChildTarget).append(this.element[0]);
    };
    SliderPanelService.prototype.init = function () {
        this.initializePanelConfiguration();
        this.initializeParentRawElement();
        this.initializeInlineStyles();
        this.initializeChildTarget();
        this.append();
    };
    return SliderPanelService;
}());

var /* @ngInject */ SliderPanelServiceFactory = /** @class */ (function () {
    SliderPanelServiceFactory.$inject = ["yjQuery"];
    function /* @ngInject */ SliderPanelServiceFactory(yjQuery) {
        this.yjQuery = yjQuery;
    }
    /**
     * Set and returns a new instance of the slider panel.
     */
    /* @ngInject */ SliderPanelServiceFactory.prototype.getNewServiceInstance = function (element, window, configuration) {
        return new SliderPanelService(element, window, configuration, this.yjQuery);
    };
    SliderPanelServiceFactory.prototype.getNewServiceInstance.$inject = ["element", "window", "configuration"];
    /* @ngInject */ SliderPanelServiceFactory = __decorate([
        SeDowngradeService(),
        __param(0, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [Function])
    ], /* @ngInject */ SliderPanelServiceFactory);
    return /* @ngInject */ SliderPanelServiceFactory;
}());

var CSS_CLASSNAMES = {
    SLIDERPANEL_ANIMATED: 'sliderpanel--animated',
    SLIDERPANEL_SLIDEPREFIX: 'sliderpanel--slidefrom'
};
window.__smartedit__.addDecoratorPayload("Component", "SliderPanelComponent", {
    selector: 'se-slider-panel',
    template: "<div class=\"se-slider-panel-wrapper\" *ngIf=\"isShown\"><div class=\"se-slider-panel-container slide-in\"><div class=\"se-slider-panel__header\" *ngIf=\"sliderPanelConfiguration.modal\"><span class=\"se-slider-panel__title\" *ngIf=\"sliderPanelConfiguration.modal.title\">{{ sliderPanelConfiguration.modal.title | translate }}</span> <button type=\"button\" class=\"se-slider-panel__close-btn fd-button--light fd-modal__close\" aria-label=\"close\" *ngIf=\"sliderPanelConfiguration.modal.showDismissButton\" (click)=\"sliderPanelDismissAction()\"></button></div><div class=\"se-slider-panel__body\"><div *ngIf=\"sliderPanelConfiguration.template\" [seCompileHtml]=\"sliderPanelConfiguration.template\" [scope]=\"sliderPanelConfiguration.scope\"></div><div *ngIf=\"sliderPanelConfiguration.templateUrl\" [ngInclude]=\"sliderPanelConfiguration.templateUrl\" [scope]=\"sliderPanelConfiguration.scope\"></div><ng-content></ng-content></div><div class=\"se-slider-panel__footer\" *ngIf=\"sliderPanelConfiguration.modal && (sliderPanelConfiguration.modal.cancel || sliderPanelConfiguration.modal.save)\"><button type=\"button\" class=\"fd-button--light se-slider-panel__footer-btn se-slider-panel__footer-btn--cancel\" *ngIf=\"sliderPanelConfiguration.modal.cancel\" (click)=\"sliderPanelConfiguration.modal.cancel.onClick()\">{{ sliderPanelConfiguration.modal.cancel.label | translate }}</button> <button type=\"button\" class=\"fd-button--emphasized se-slider-panel__footer-btn se-slider-panel__footer-btn--save\" *ngIf=\"sliderPanelConfiguration.modal.save\" (click)=\"sliderPanelConfiguration.modal.save.onClick()\" [disabled]=\"isSaveDisabled()\">{{ sliderPanelConfiguration.modal.save.label | translate }}</button></div></div></div>",
    styles: [".se-slider-panel-wrapper{position:fixed;display:flex;justify-content:center;overflow:hidden;width:100%;top:0;left:0;z-index:1060}.se-slider-panel-container{display:flex;flex-direction:column;transform:translateX(100%);-webkit-transform:translateX(100%);background-color:#fff;border-radius:4px;width:650px}.se-slider-panel__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px}.se-slider-panel__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-slider-panel__body{padding:20px;overflow-y:auto;max-height:70vh;height:70vh;min-height:500px;flex:1 1 auto}.se-slider-panel__footer{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:flex-end;border-top:1px solid #d9d9d9;height:69px}.se-slider-panel__footer button{text-transform:capitalize;margin-left:12px}.slide-in{animation:slide-in .4s forwards;-webkit-animation:slide-in .4s forwards}@keyframes slide-in{100%{transform:translateX(0)}}@-webkit-keyframes slide-in{100%{-webkit-transform:translateX(0)}}:host-context(.fd-modal-container).sliderpanel--animated{position:fixed;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);align-items:center;display:flex}:host-context(.fd-modal-container).sliderpanel--animated .se-slider-panel-wrapper{top:auto}:host-context(.fd-modal-container).sliderpanel--animated .se-slider-panel-wrapper .se-slider-panel__body{max-height:calc(100vh - 128px);min-height:auto}"]
});
var /* @ngInject */ SliderPanelComponent = /** @class */ (function () {
    SliderPanelComponent.$inject = ["renderer", "element", "windowUtils", "yjQuery", "sliderPanelServiceFactory"];
    function /* @ngInject */ SliderPanelComponent(renderer, element, windowUtils, yjQuery, sliderPanelServiceFactory) {
        this.renderer = renderer;
        this.element = element;
        this.windowUtils = windowUtils;
        this.yjQuery = yjQuery;
        this.sliderPanelServiceFactory = sliderPanelServiceFactory;
        this.sliderPanelHideChange = new core.EventEmitter();
        this.sliderPanelShowChange = new core.EventEmitter();
        this.isShownChange = new core.EventEmitter();
        this.inlineStyling = { container: {}, content: {} };
    }
    /* @ngInject */ SliderPanelComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.isShown = false;
        this.uniqueId = stringUtils.generateIdentifier();
        this.sliderPanelService = this.sliderPanelServiceFactory.getNewServiceInstance(this.yjQuery(this.element.nativeElement), this.windowUtils.getWindow(), this.sliderPanelConfiguration);
        this.sliderPanelConfiguration = this.sliderPanelService.sliderPanelConfiguration;
        this.slideClassName =
            CSS_CLASSNAMES.SLIDERPANEL_SLIDEPREFIX + this.sliderPanelConfiguration.slideFrom;
        this.inlineStyling = {
            container: this.sliderPanelService.inlineStyling.container,
            content: this.sliderPanelService.inlineStyling.content
        };
        setTimeout(function () {
            _this.sliderPanelShowChange.emit(function () { return _this.showSlider(); });
            _this.sliderPanelHideChange.emit(function () { return _this.hideSlider(); });
        });
        this.sliderPanelDismissAction =
            this.sliderPanelConfiguration.modal &&
                this.sliderPanelConfiguration.modal.dismiss &&
                this.sliderPanelConfiguration.modal.dismiss.onClick
                ? this.sliderPanelConfiguration.modal.dismiss.onClick
                : this.hideSlider;
        this.addScreenResizeEventHandler();
        if (this.sliderPanelConfiguration.displayedByDefault) {
            this.showSlider();
        }
    };
    /* @ngInject */ SliderPanelComponent.prototype.ngOnDestroy = function () {
        this.yjQuery(this.windowUtils.getWindow()).off('resize.doResize');
    };
    /* @ngInject */ SliderPanelComponent.prototype.ngOnChanges = function () {
        this.validateComponent();
    };
    /* @ngInject */ SliderPanelComponent.prototype.hideSlider = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.renderer.removeClass(_this.element.nativeElement, CSS_CLASSNAMES.SLIDERPANEL_ANIMATED);
            _this.isShown = false;
            _this.isShownChange.emit(_this.isShown);
            resolve();
        });
    };
    /* @ngInject */ SliderPanelComponent.prototype.showSlider = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.sliderPanelService.updateContainerInlineStyling(false);
            _this.inlineStyling.container = _this.sliderPanelService.inlineStyling.container;
            var isSecondarySliderPanel = false;
            _this.yjQuery('se-slider-panel.sliderpanel--animated .se-slider-panel-container')
                .toArray()
                .forEach(function (sliderPanelContainer) {
                var container = _this.yjQuery(sliderPanelContainer);
                if (!isSecondarySliderPanel) {
                    if (container.css('height') === _this.inlineStyling.container.height &&
                        container.css('width') === _this.inlineStyling.container.width &&
                        container.css('left') === _this.inlineStyling.container.left &&
                        container.css('top') === _this.inlineStyling.container.top) {
                        isSecondarySliderPanel = true;
                    }
                }
            });
            _this.sliderPanelConfiguration.noGreyedOutOverlay =
                typeof _this.sliderPanelConfiguration.noGreyedOutOverlay === 'boolean'
                    ? _this.sliderPanelConfiguration.noGreyedOutOverlay
                    : isSecondarySliderPanel;
            _this.isShown = true;
            _this.isShownChange.emit(_this.isShown);
            _this.renderer.addClass(_this.element.nativeElement, CSS_CLASSNAMES.SLIDERPANEL_ANIMATED);
            resolve();
        });
    };
    /* @ngInject */ SliderPanelComponent.prototype.isSaveDisabled = function () {
        if (this.sliderPanelConfiguration.modal &&
            this.sliderPanelConfiguration.modal.save &&
            this.sliderPanelConfiguration.modal.save.isDisabledFn) {
            return this.sliderPanelConfiguration.modal.save.isDisabledFn();
        }
        return false;
    };
    /* @ngInject */ SliderPanelComponent.prototype.validateComponent = function () {
        var _a, _b;
        var isContentProvided = !!this.content;
        var isLegacyTemplateProvided = !!((_a = this.sliderPanelConfiguration) === null || _a === void 0 ? void 0 : _a.templateUrl) ||
            !!((_b = this.sliderPanelConfiguration) === null || _b === void 0 ? void 0 : _b.template);
        var isInvalid = isContentProvided && isLegacyTemplateProvided;
        if (isInvalid) {
            throw new Error('SliderComponent - invalid configuration provided. Only content or template / templateUrl can be provided, not both.');
        }
    };
    /* @ngInject */ SliderPanelComponent.prototype.addScreenResizeEventHandler = function () {
        var _this = this;
        this.yjQuery(this.windowUtils.getWindow()).on('resize.sliderPanelRedraw_' + this.uniqueId, function () {
            if (_this.isShown) {
                setTimeout(function () {
                    _this.sliderPanelService.updateContainerInlineStyling(true);
                    _this.inlineStyling.container = _this.sliderPanelService.inlineStyling.container;
                }, 0);
            }
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ SliderPanelComponent.prototype, "sliderPanelConfiguration", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SliderPanelComponent.prototype, "sliderPanelHide", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ SliderPanelComponent.prototype, "sliderPanelShow", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ SliderPanelComponent.prototype, "sliderPanelHideChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ SliderPanelComponent.prototype, "sliderPanelShowChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ SliderPanelComponent.prototype, "isShownChange", void 0);
    __decorate([
        core.ContentChild(core.TemplateRef, { static: false }),
        __metadata("design:type", core.TemplateRef)
    ], /* @ngInject */ SliderPanelComponent.prototype, "content", void 0);
    /* @ngInject */ SliderPanelComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-slider-panel',
            template: "<div class=\"se-slider-panel-wrapper\" *ngIf=\"isShown\"><div class=\"se-slider-panel-container slide-in\"><div class=\"se-slider-panel__header\" *ngIf=\"sliderPanelConfiguration.modal\"><span class=\"se-slider-panel__title\" *ngIf=\"sliderPanelConfiguration.modal.title\">{{ sliderPanelConfiguration.modal.title | translate }}</span> <button type=\"button\" class=\"se-slider-panel__close-btn fd-button--light fd-modal__close\" aria-label=\"close\" *ngIf=\"sliderPanelConfiguration.modal.showDismissButton\" (click)=\"sliderPanelDismissAction()\"></button></div><div class=\"se-slider-panel__body\"><div *ngIf=\"sliderPanelConfiguration.template\" [seCompileHtml]=\"sliderPanelConfiguration.template\" [scope]=\"sliderPanelConfiguration.scope\"></div><div *ngIf=\"sliderPanelConfiguration.templateUrl\" [ngInclude]=\"sliderPanelConfiguration.templateUrl\" [scope]=\"sliderPanelConfiguration.scope\"></div><ng-content></ng-content></div><div class=\"se-slider-panel__footer\" *ngIf=\"sliderPanelConfiguration.modal && (sliderPanelConfiguration.modal.cancel || sliderPanelConfiguration.modal.save)\"><button type=\"button\" class=\"fd-button--light se-slider-panel__footer-btn se-slider-panel__footer-btn--cancel\" *ngIf=\"sliderPanelConfiguration.modal.cancel\" (click)=\"sliderPanelConfiguration.modal.cancel.onClick()\">{{ sliderPanelConfiguration.modal.cancel.label | translate }}</button> <button type=\"button\" class=\"fd-button--emphasized se-slider-panel__footer-btn se-slider-panel__footer-btn--save\" *ngIf=\"sliderPanelConfiguration.modal.save\" (click)=\"sliderPanelConfiguration.modal.save.onClick()\" [disabled]=\"isSaveDisabled()\">{{ sliderPanelConfiguration.modal.save.label | translate }}</button></div></div></div>",
            styles: [".se-slider-panel-wrapper{position:fixed;display:flex;justify-content:center;overflow:hidden;width:100%;top:0;left:0;z-index:1060}.se-slider-panel-container{display:flex;flex-direction:column;transform:translateX(100%);-webkit-transform:translateX(100%);background-color:#fff;border-radius:4px;width:650px}.se-slider-panel__header{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;border-bottom:1px solid #d9d9d9;height:53px}.se-slider-panel__header:first-child{font-size:1.1428571429rem;line-height:1.25;font-weight:400;color:#32363a}.se-slider-panel__body{padding:20px;overflow-y:auto;max-height:70vh;height:70vh;min-height:500px;flex:1 1 auto}.se-slider-panel__footer{padding:20px;display:flex;flex-direction:row;align-items:center;justify-content:flex-end;border-top:1px solid #d9d9d9;height:69px}.se-slider-panel__footer button{text-transform:capitalize;margin-left:12px}.slide-in{animation:slide-in .4s forwards;-webkit-animation:slide-in .4s forwards}@keyframes slide-in{100%{transform:translateX(0)}}@-webkit-keyframes slide-in{100%{-webkit-transform:translateX(0)}}:host-context(.fd-modal-container).sliderpanel--animated{position:fixed;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);align-items:center;display:flex}:host-context(.fd-modal-container).sliderpanel--animated .se-slider-panel-wrapper{top:auto}:host-context(.fd-modal-container).sliderpanel--animated .se-slider-panel-wrapper .se-slider-panel__body{max-height:calc(100vh - 128px);min-height:auto}"]
        }),
        __param(3, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [core.Renderer2,
            core.ElementRef,
            WindowUtils, Function, SliderPanelServiceFactory])
    ], /* @ngInject */ SliderPanelComponent);
    return /* @ngInject */ SliderPanelComponent;
}());

var SliderPanelModule = /** @class */ (function () {
    function SliderPanelModule() {
    }
    SliderPanelModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, utils.TranslationModule.forChild(), CompileHtmlModule],
            declarations: [SliderPanelComponent],
            entryComponents: [SliderPanelComponent],
            providers: [SliderPanelServiceFactory],
            exports: [SliderPanelComponent]
        })
    ], SliderPanelModule);
    return SliderPanelModule;
}());

/**
 * This object defines injectable Angular constants that store the CSS class names used in the controller to define the
 * rendering and animation of the slider panel.
 */
var CSS_CLASSNAMES$1 = {
    /**
     * The class name applied to the slide panel container to trigger the sliding action in the CSS animation.
     */
    SLIDERPANEL_ANIMATED: 'sliderpanel--animated',
    /**
     * A common prefix for the class names that defines how the content of the slider panel is to be rendered.
     */
    SLIDERPANEL_SLIDEPREFIX: 'sliderpanel--slidefrom'
};
/**
 * # Module
 *
 * **Deprecated since 2005, use {@link SliderPanelModule}.**
 *
 * This module defines the slider panel AngularJS component and its associated constants and controller.
 *
 * ## Basic Implementation
 *
 * To define a new slider panel, you must make some basic modifications to your AngularJS module and controller, as well
 * as to your HTML template.
 *
 * ### AngularJS Module
 *
 * You must add the sliderPanelModule as a dependency to your AngularJS module.
 *
 *      angular.module('yourApp', ['sliderPanelModule']) { ... }
 *
 *
 * ### AngularJS Controller
 *
 * Within the AngularJS controller, you must add a function to be instantiated so that the controller will trigger the
 * display of the slider panel.
 *
 *
 *      angular.module('yourApp', ['sliderPanelModule'])
 *          .controller('yourController', function() {
 *              ...
 *              this.showSliderPanel = function() {};
 *              ...
 *          });
 *
 * ### HTML template
 *
 * To include HTML content in the slider panel, you must embed the HTML content in a `<y-slider-panel> </y-slider-panel>` tag.<br />
 * For more information, see the definition of the component.
 *
 *
 *      <y-slider-panel data-slider-panel-show="$ctrl.sliderPanelShow">
 *          <content>
 *              any HTML content
 *          </content>
 *      </y-slider-panel>
 *
 * You can then make the slider panel visible by calling the "Show Slider Panel" function defined in the associated controller; for example:
 *
 *
 *      <button class="btn btn-default" ng-click="$ctrl.sliderPanelShow();">
 *          Show Slider Panel
 *      </button>
 *
 * ## Advanced Configurations
 *
 * A default set of configurations is applied to all slider panels. You can overwrite and update the default configuration.
 *
 * To update the configuration of a specific slider panel, you must instantiate a JSON object that contains the expected
 * configuration in the AngularJS controller and provide it to the slider panel controller using the HTML template, for example:
 *
 *
 *      <y-slider-panel ... data-slider-panel-configuration="$ctrl.sliderPanelConfiguration">
 *
 * If you define this type of configuration set, SmartEdit will automatically merge it with the slider panel's default configuration.
 * For information about the available settings, see the SliderPanelService.getNewServiceInstance method.
 *
 * # Component
 *
 * **Deprecated since 2005, use {@link SliderPanelComponent}.**
 *
 * ### Parameters
 *
 *
 * `dataSliderPanelConfiguration` - (optional) A JSON object containing the configuration to be applied on slider panel.
 *
 * `dataSliderPanelHide` - (optional) A function shared in a two ways binding by the main controller and the slider panel and used to trigger the hiding of the slider panel.
 *
 * `dataSliderPanelShow` - A function shared in a two ways binding by the main controller and the slider panel and used to trigger the display of the slider panel.
 *
 * The ySliderPanel AngularJS component allows for the dynamic display of any HTML content on a sliding panel.
 *
 * @deprecated
 */
var /* @ngInject */ YSliderPanelComponent = /** @class */ (function () {
    YSliderPanelComponent.$inject = ["$animate", "$element", "$timeout", "$window", "yjQuery", "sliderPanelServiceFactory"];
    function /* @ngInject */ YSliderPanelComponent($animate, $element, $timeout, $window, yjQuery, sliderPanelServiceFactory) {
        this.$animate = $animate;
        this.$element = $element;
        this.$timeout = $timeout;
        this.$window = $window;
        this.yjQuery = yjQuery;
        this.sliderPanelServiceFactory = sliderPanelServiceFactory;
        this.inlineStyling = { container: {}, content: {} };
    }
    /* @ngInject */ YSliderPanelComponent.prototype.$onInit = function () {
        var _this = this;
        this.isShown = false;
        this.uniqueId = lodash.uniqueId();
        // setting new instance of slider panel service
        this.sliderPanelService = this.sliderPanelServiceFactory.getNewServiceInstance(this.$element, this.$window, this.sliderPanelConfiguration);
        // variables made available on the html template
        this.sliderPanelConfiguration = this.sliderPanelService.sliderPanelConfiguration;
        this.slideClassName =
            CSS_CLASSNAMES$1.SLIDERPANEL_SLIDEPREFIX + this.sliderPanelConfiguration.slideFrom;
        this.inlineStyling = {
            container: this.sliderPanelService.inlineStyling.container,
            content: this.sliderPanelService.inlineStyling.content
        };
        this.sliderPanelShow = function () { return _this.showSlider(); };
        this.sliderPanelHide = function () { return _this.hideSlider(); };
        this.sliderPanelDismissAction =
            this.sliderPanelConfiguration.modal &&
                this.sliderPanelConfiguration.modal.dismiss &&
                this.sliderPanelConfiguration.modal.dismiss.onClick
                ? this.sliderPanelConfiguration.modal.dismiss.onClick
                : this.hideSlider;
        // applying event handler for screen resize
        this.addScreenResizeEventHandler();
        if (this.sliderPanelConfiguration.displayedByDefault) {
            this.showSlider();
        }
    };
    /* @ngInject */ YSliderPanelComponent.prototype.$onDestroy = function () {
        this.yjQuery(window).off('resize.doResize');
    };
    /* @ngInject */ YSliderPanelComponent.prototype.hideSlider = function () {
        var _this = this;
        return this.$animate
            .removeClass(this.$element, CSS_CLASSNAMES$1.SLIDERPANEL_ANIMATED)
            .then(function () {
            _this.isShown = false;
        });
    };
    /* @ngInject */ YSliderPanelComponent.prototype.showSlider = function () {
        var _this = this;
        // container inline styling
        this.sliderPanelService.updateContainerInlineStyling(false);
        this.inlineStyling.container = this.sliderPanelService.inlineStyling.container;
        // container greyed out overlay
        var isSecondarySliderPanel = false;
        angular$1.forEach(angular$1.element('y-slider-panel.sliderpanel--animated .se-slider-panel-container'), function (sliderPanelContainer) {
            var container = angular$1.element(sliderPanelContainer);
            if (!isSecondarySliderPanel) {
                if (container.css('height') === _this.inlineStyling.container.height &&
                    container.css('width') === _this.inlineStyling.container.width &&
                    container.css('left') === _this.inlineStyling.container.left &&
                    container.css('top') === _this.inlineStyling.container.top) {
                    isSecondarySliderPanel = true;
                }
            }
        });
        // if no related configuration has been set, the no greyed out overlay is set to true for all secondary slider panels.
        this.sliderPanelConfiguration.noGreyedOutOverlay =
            typeof this.sliderPanelConfiguration.noGreyedOutOverlay === 'boolean'
                ? this.sliderPanelConfiguration.noGreyedOutOverlay
                : isSecondarySliderPanel;
        // triggering slider panel display
        this.isShown = true;
        return this.$animate.addClass(this.$element, CSS_CLASSNAMES$1.SLIDERPANEL_ANIMATED);
    };
    /* @ngInject */ YSliderPanelComponent.prototype.isSaveDisabled = function () {
        if (this.sliderPanelConfiguration.modal &&
            this.sliderPanelConfiguration.modal.save &&
            this.sliderPanelConfiguration.modal.save.isDisabledFn) {
            return this.sliderPanelConfiguration.modal.save.isDisabledFn();
        }
        return false;
    };
    /* @ngInject */ YSliderPanelComponent.prototype.addScreenResizeEventHandler = function () {
        var _this = this;
        this.yjQuery(window).on('resize.sliderPanelRedraw_' + this.uniqueId, function () {
            if (_this.isShown) {
                _this.$timeout(function () {
                    _this.sliderPanelService.updateContainerInlineStyling(true);
                    _this.inlineStyling.container = _this.sliderPanelService.inlineStyling.container;
                });
            }
        });
    };
    /* @ngInject */ YSliderPanelComponent = __decorate([
        SeComponent({
            selector: 'y-slider-panel',
            templateUrl: 'sliderPanelTemplate.html',
            transclude: true,
            inputs: ['sliderPanelConfiguration', 'sliderPanelHide:=', 'sliderPanelShow:=']
        }),
        __metadata("design:paramtypes", [Object, Object, Function, Object, Function, SliderPanelServiceFactory])
    ], /* @ngInject */ YSliderPanelComponent);
    return /* @ngInject */ YSliderPanelComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "MoreTextComponent", {
    selector: 'se-more-text',
    template: "\n        <span id=\"y-more-text-payload\" class=\"se-more-text__payload\">{{ text }}</span>\n        <span\n            id=\"y-more-text-toggle\"\n            class=\"se-more-text__toggle\"\n            [ngClass]=\"{ 'se-more-text__toggle--capitalize': capitalizeLabel }\"\n            (click)=\"showHideMoreText()\"\n            *ngIf=\"isTruncated\"\n            >{{ linkLabel }}</span\n        >\n    ",
    styles: [".se-more-text__toggle--capitalize{text-transform:capitalize;color:#0a6ed1;cursor:pointer}"],
    providers: [TextTruncateService]
});
var /* @ngInject */ MoreTextComponent = /** @class */ (function () {
    MoreTextComponent.$inject = ["textTruncateService", "translate"];
    function /* @ngInject */ MoreTextComponent(textTruncateService, translate) {
        this.textTruncateService = textTruncateService;
        this.translate = translate;
        this.capitalizeLabel = false;
        this.isTruncated = false;
        this.showingMore = false;
    }
    /* @ngInject */ MoreTextComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.limit = this.limit || 100;
        this.moreLabelI18nKey = this.moreLabelI18nKey || 'se.moretext.more.link';
        this.lessLabelI18nKey = this.lessLabelI18nKey || 'se.moretext.less.link';
        this.truncatedText = this.textTruncateService.truncateToNearestWord(this.limit, this.text, this.ellipsis);
        this.isTruncated = this.truncatedText.isTruncated();
        this.translateLabels().subscribe(function () {
            _this.showHideMoreText();
        });
    };
    /* @ngInject */ MoreTextComponent.prototype.showHideMoreText = function () {
        if (!this.isTruncated) {
            return;
        }
        this.text = this.showingMore
            ? this.truncatedText.getUntruncatedText()
            : this.truncatedText.getTruncatedText();
        this.linkLabel = this.showingMore ? this.lessLabel : this.moreLabel;
        this.showingMore = !this.showingMore;
    };
    /* @ngInject */ MoreTextComponent.prototype.translateLabels = function () {
        var _this = this;
        return rxjs.zip(this.translate.get(this.moreLabelI18nKey), this.translate.get(this.lessLabelI18nKey)).pipe(operators.tap(function (_a) {
            var more = _a[0], less = _a[1];
            _this.moreLabel = more;
            _this.lessLabel = less;
        }));
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MoreTextComponent.prototype, "text", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ MoreTextComponent.prototype, "limit", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MoreTextComponent.prototype, "moreLabelI18nKey", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MoreTextComponent.prototype, "lessLabelI18nKey", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ MoreTextComponent.prototype, "ellipsis", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ MoreTextComponent.prototype, "capitalizeLabel", void 0);
    /* @ngInject */ MoreTextComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-more-text',
            template: "\n        <span id=\"y-more-text-payload\" class=\"se-more-text__payload\">{{ text }}</span>\n        <span\n            id=\"y-more-text-toggle\"\n            class=\"se-more-text__toggle\"\n            [ngClass]=\"{ 'se-more-text__toggle--capitalize': capitalizeLabel }\"\n            (click)=\"showHideMoreText()\"\n            *ngIf=\"isTruncated\"\n            >{{ linkLabel }}</span\n        >\n    ",
            styles: [".se-more-text__toggle--capitalize{text-transform:capitalize;color:#0a6ed1;cursor:pointer}"],
            providers: [TextTruncateService]
        }),
        __metadata("design:paramtypes", [TextTruncateService,
            core$1.TranslateService])
    ], /* @ngInject */ MoreTextComponent);
    return /* @ngInject */ MoreTextComponent;
}());

var MoreTextModule = /** @class */ (function () {
    function MoreTextModule() {
    }
    MoreTextModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule],
            declarations: [MoreTextComponent],
            entryComponents: [MoreTextComponent],
            exports: [MoreTextComponent]
        })
    ], MoreTextModule);
    return MoreTextModule;
}());

var SharedComponentsModule = /** @class */ (function () {
    function SharedComponentsModule() {
    }
    SharedComponentsModule = __decorate([
        core.NgModule({
            imports: [
                utils.TranslationModule.forChild(),
                FundamentalsModule,
                common.CommonModule,
                forms.FormsModule,
                utils.SelectModule,
                utils.LanguageDropdownModule,
                forms.ReactiveFormsModule,
                CollapsibleContainerModule,
                CompileHtmlModule,
                MessageModule,
                NgTreeModule$1,
                HasOperationPermissionDirectiveModule,
                DropdownMenuModule,
                ResizeObserverModule,
                InfiniteScrollingModule,
                SpinnerModule,
                PopupOverlayModule,
                StartFromPipeModule,
                PaginationModule,
                TooltipModule,
                ReversePipeModule,
                EditableListModule,
                SliderPanelModule,
                utils.LoginDialogModule,
                utils.FundamentalModalTemplateModule,
                DynamicPagedListModule,
                DataTableModule,
                HelpModule,
                TabsModule,
                MoreTextModule,
                PreventVerticalOverflowModule
            ],
            declarations: [WaitDialogComponent],
            entryComponents: [WaitDialogComponent],
            exports: [
                WaitDialogComponent,
                utils.SelectModule,
                utils.LanguageDropdownModule,
                CompileHtmlModule,
                MessageModule,
                NgTreeModule$1,
                CollapsibleContainerModule,
                HasOperationPermissionDirectiveModule,
                DropdownMenuModule,
                PopupOverlayModule,
                ResizeObserverModule,
                InfiniteScrollingModule,
                StartFromPipeModule,
                PaginationModule,
                TooltipModule,
                ReversePipeModule,
                EditableListModule,
                SpinnerModule,
                SliderPanelModule,
                utils.LoginDialogModule,
                utils.FundamentalModalTemplateModule,
                DynamicPagedListModule,
                DataTableModule,
                HelpModule,
                TabsModule,
                MoreTextModule,
                PreventVerticalOverflowModule
            ]
        })
    ], SharedComponentsModule);
    return SharedComponentsModule;
}());

/**
 * Directive solely responsible for handling the submitting of its current data state to
 * an onSave input method and notifying of success and failure.
 *
 * ### Example
 *
 *      <form
 *          [contentManager]="{onSave: editor.submit$}"
 *          (onSuccess)="editor.onSuccess($event)"
 *          (onError)="editor.onFailure($event)"
 *      >
 *      </form>
 *
 * @param option object containing the onSave method of type (data: T) => Observable<T>
 * @param onSuccess outputs the successful result of onSave invocation
 * @param onError outputs the failing result of onSave invocation
 */
var ContentManager = /** @class */ (function () {
    function ContentManager() {
        /**
         * Called when a saving is a success.
         */
        this.onSuccess = new core.EventEmitter();
        /**
         * Called when there is an error after saving.
         */
        this.onError = new core.EventEmitter();
        /**
         * Submitting state of the manager.
         *
         * @type {boolean}
         */
        this.submitting = false;
    }
    Object.defineProperty(ContentManager.prototype, "option", {
        set: function (option) {
            this._onSave = option.onSave;
        },
        enumerable: false,
        configurable: true
    });
    ContentManager.prototype.save = function () {
        var _this = this;
        this.submitting = true;
        return this._onSave().pipe(operators.finalize(function () { return (_this.submitting = false); }), operators.tap(function (content) {
            _this.onSuccess.emit(content);
        }), operators.catchError(function (err) {
            _this.onError.emit(err);
            return rxjs.throwError(err);
        }));
    };
    __decorate([
        core.Input('contentManager'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ContentManager.prototype, "option", null);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], ContentManager.prototype, "onSuccess", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], ContentManager.prototype, "onError", void 0);
    ContentManager = __decorate([
        core.Directive({
            selector: '[contentManager]'
        })
    ], ContentManager);
    return ContentManager;
}());

var createApi = function (editor) {
    /**
     * The generic editor's api object exposing public functionality
     */
    return ({
        /**
         * Overrides the i18n key used bfor the submit button.
         */
        setSubmitButtonText: function (_submitButtonText) {
            editor.submitButtonText = _submitButtonText;
        },
        /**
         * Overrides the i18n key used bfor the submit button.
         */
        setCancelButtonText: function (_cancelButtonText) {
            editor.cancelButtonText = _cancelButtonText;
        },
        /**
         * If set to true, will always show the submit button.
         */
        setAlwaysShowSubmit: function (_alwaysShowSubmit) {
            editor.alwaysShowSubmit = _alwaysShowSubmit;
        },
        /**
         * If set to true, will always show the reset button.
         */
        setAlwaysShowReset: function (_alwaysShowReset) {
            editor.alwaysShowReset = _alwaysShowReset;
        },
        /**
         * To be executed after reset.
         */
        setOnReset: function (_onReset) {
            editor.onReset = _onReset;
        },
        /**
         * Function that passes a preparePayload function to the editor in order to transform the payload prior to submitting (see `GenericEditorFactoryService#preparePayload`)
         * @param preparePayload The function that takes the original payload as argument
         */
        setPreparePayload: function (_preparePayload) {
            editor.preparePayload = _preparePayload;
        },
        /**
         * Function that passes an updateCallback function to the editor in order to perform an action upon successful submit. It is invoked with two arguments: the pristine object and the response from the server.
         * @param updateCallback the callback invoked upon successful submit.
         */
        setUpdateCallback: function (_updateCallback) {
            editor.updateCallback = _updateCallback;
        },
        /**
         * Function that updates the content of the generic editor without having to reinitialize
         *
         * @param component The component to replace the current model for the generic editor
         */
        updateContent: function (component) {
            editor.form && editor.form.patchComponent(component);
        },
        /**
         * Copies of the current model
         * @returns a copy
         */
        getContent: function () {
            return editor.form ? objectUtils.copy(editor.form.component) : undefined;
        },
        /**
         * **Deprecated since 1905 - use {@link addContentChangeEvent} instead.**
         *
         * Function triggered everytime the current model changes
         *
         * @deprecated
         */
        onContentChange: function () {
            return;
        },
        /**
         * Method adds a new function to the list of functions triggered everytime the current model changes
         *
         * @param {Function} The function triggered everytime the current model changes
         *
         * @returns The function to unregister the event;
         */
        addContentChangeEvent: function (event) {
            editor.onChangeEvents.push(event);
            return function () {
                var index = editor.onChangeEvents.findIndex(function (e) { return e === event; });
                if (index > -1) {
                    editor.onChangeEvents.splice(index, 1);
                }
            };
        },
        /**
         * Triggers all functions that were added with addContentChangeEvent api method. It provides current content as parameter to every function call.
         */
        triggerContentChangeEvents: function () {
            editor.onChangeEvents.forEach(function (event) {
                event(objectUtils.copy(editor.form.component));
            });
        },
        /**
         * Function that clears all validation messages in the editor
         */
        clearMessages: function () {
            editor.form.removeValidationMessages();
        },
        /**
         * Causes the genericEditor to switch to the tab containing a qualifier of the given name.
         * @param qualifier the qualifier contained in the tab we want to switch to.
         */
        switchToTabContainingQualifier: function (qualifier) {
            editor.targetedQualifier = qualifier;
        },
        /** Currently used by clone components to open editor in dirty mode. */
        considerFormDirty: function () {
            editor.initialDirty = true;
        },
        setInProgress: function (isInProgress) {
            editor.inProgress = isInProgress;
        },
        /**
         * Returns true to inform that the submit button delegated to the invoker should be disabled.
         * @returns true if submit is disabled
         */
        isSubmitDisabled: function () { return editor.isSubmitDisabled(); },
        /**
         * Function that returns a promise resolving to language descriptors. If defined, will be resolved
         * when the generic editor is initialized to override what languages are used for localized elements
         * within the editor.
         * @returns a promise resolving to language descriptors. Each descriptor provides the following
         * language properties: isocode, nativeName, name, active, and required.
         */
        getLanguages: function () { return null; },
        /**
         * If set to true, will always enable the submit button.
         */
        setAlwaysEnableSubmit: function (alwaysEnableSubmit) {
            editor.alwaysEnableSubmit = alwaysEnableSubmit;
        }
    });
};

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var GENERIC_EDITOR_WIDGET_DATA = new core.InjectionToken('GENERIC_EDITOR_WIDGET_DATA');

window.__smartedit__.addDecoratorPayload("Component", "BooleanComponent", {
    selector: 'se-boolean',
    template: "<div class=\"se-boolean fd-form__item fd-form__item--check\"><span class=\"fd-toggle fd-toggle--xs fd-form__control\"><label class=\"fd-form__label\" for=\"{{qualifierId}}-checkbox\"><input type=\"checkbox\" id=\"{{qualifierId}}-checkbox\" class=\"se-boolean__input\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"!widget.field.editable\" [(ngModel)]=\"widget.model[widget.qualifier]\"/> <span class=\"fd-toggle__switch\" role=\"presentation\"></span></label></span><p *ngIf=\"widget.field.labelText && !widget.model[widget.qualifier]\" class=\"se-boolean__text\">{{widget.field.labelText| translate}}</p></div>"
});
var BooleanComponent = /** @class */ (function () {
    function BooleanComponent(widget) {
        this.widget = widget;
    }
    BooleanComponent.prototype.ngOnInit = function () {
        this.qualifierId = this.widget.qualifier + stringUtils.generateIdentifier();
        if (this.widget.model[this.widget.qualifier] === undefined) {
            var defaultValue = this.widget.field.defaultValue !== undefined
                ? this.widget.field.defaultValue
                : false;
            this.widget.model[this.widget.qualifier] = defaultValue;
            this.widget.editor.pristine[this.widget.qualifier] = defaultValue;
        }
    };
    BooleanComponent = __decorate([
        core.Component({
            selector: 'se-boolean',
            template: "<div class=\"se-boolean fd-form__item fd-form__item--check\"><span class=\"fd-toggle fd-toggle--xs fd-form__control\"><label class=\"fd-form__label\" for=\"{{qualifierId}}-checkbox\"><input type=\"checkbox\" id=\"{{qualifierId}}-checkbox\" class=\"se-boolean__input\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"!widget.field.editable\" [(ngModel)]=\"widget.model[widget.qualifier]\"/> <span class=\"fd-toggle__switch\" role=\"presentation\"></span></label></span><p *ngIf=\"widget.field.labelText && !widget.model[widget.qualifier]\" class=\"se-boolean__text\">{{widget.field.labelText| translate}}</p></div>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], BooleanComponent);
    return BooleanComponent;
}());

var BooleanModule = /** @class */ (function () {
    function BooleanModule() {
    }
    BooleanModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, forms.FormsModule, core$1.TranslateModule.forChild()],
            declarations: [BooleanComponent],
            entryComponents: [BooleanComponent],
            exports: [BooleanComponent]
        })
    ], BooleanModule);
    return BooleanModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Contains a map of all inconsistent locales ISOs between SmartEdit and MomentJS
 */
var RESOLVED_LOCALE_TO_MOMENT_LOCALE_MAP = new core.InjectionToken('resolvedLocaleToMomentLocaleMap');
/**
 * Contains a map of all tooltips to be localized in the date time picker
 */
var TOOLTIPS_MAP = new core.InjectionToken('tooltipsMap');

/**
 * The DateTimePickerLocalizationService is responsible for both localizing the date time picker as well as the tooltips
 */
var /* @ngInject */ DateTimePickerLocalizationService = /** @class */ (function () {
    DateTimePickerLocalizationService.$inject = ["translate", "resolvedLocaleToMomentLocaleMap", "tooltipsMap", "languageService"];
    function /* @ngInject */ DateTimePickerLocalizationService(translate, resolvedLocaleToMomentLocaleMap, tooltipsMap, languageService) {
        this.translate = translate;
        this.resolvedLocaleToMomentLocaleMap = resolvedLocaleToMomentLocaleMap;
        this.tooltipsMap = tooltipsMap;
        this.languageService = languageService;
    }
    /* @ngInject */ DateTimePickerLocalizationService.prototype.localizeDateTimePicker = function (datetimepicker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.localizeDateTimePickerUI(datetimepicker)];
                    case 1:
                        _a.sent();
                        this.localizeDateTimePickerTooltips(datetimepicker);
                        return [2 /*return*/];
                }
            });
        });
    };
    DateTimePickerLocalizationService.prototype.localizeDateTimePicker.$inject = ["datetimepicker"];
    /* @ngInject */ DateTimePickerLocalizationService.prototype.convertResolvedToMomentLocale = function (resolvedLocale) {
        var conversion = this.resolvedLocaleToMomentLocaleMap[resolvedLocale];
        if (conversion) {
            return conversion;
        }
        else {
            return resolvedLocale;
        }
    };
    DateTimePickerLocalizationService.prototype.convertResolvedToMomentLocale.$inject = ["resolvedLocale"];
    /* @ngInject */ DateTimePickerLocalizationService.prototype.getLocalizedTooltips = function () {
        var localizedTooltips = {};
        for (var index in this.tooltipsMap) {
            if (this.tooltipsMap.hasOwnProperty(index)) {
                localizedTooltips[index] = this.translate.instant(this.tooltipsMap[index]);
            }
        }
        return localizedTooltips;
    };
    /* @ngInject */ DateTimePickerLocalizationService.prototype.compareTooltips = function (tooltips1, tooltips2) {
        for (var index in this.tooltipsMap) {
            if (tooltips1[index] !== tooltips2[index]) {
                return false;
            }
        }
        return true;
    };
    DateTimePickerLocalizationService.prototype.compareTooltips.$inject = ["tooltips1", "tooltips2"];
    /* @ngInject */ DateTimePickerLocalizationService.prototype.localizeDateTimePickerUI = function (datetimepicker) {
        var _this = this;
        return this.languageService.getResolveLocale().then(function (language) {
            var momentLocale = _this.convertResolvedToMomentLocale(language);
            // This if statement was added to prevent infinite recursion, at the moment it triggers twice
            // due to what seems like datetimepicker.locale(<string>) broadcasting dp.show
            if (datetimepicker.locale() !== momentLocale) {
                datetimepicker.locale(momentLocale);
            }
        });
    };
    DateTimePickerLocalizationService.prototype.localizeDateTimePickerUI.$inject = ["datetimepicker"];
    /* @ngInject */ DateTimePickerLocalizationService.prototype.localizeDateTimePickerTooltips = function (datetimepicker) {
        var currentTooltips = datetimepicker.tooltips();
        var translatedTooltips = this.getLocalizedTooltips();
        // This if statement was added to prevent infinite recursion, at the moment it triggers twice
        // due to what seems like datetimepicker.tooltips(<tooltips obj>) broadcasting dp.show
        if (!this.compareTooltips(currentTooltips, translatedTooltips)) {
            datetimepicker.tooltips(translatedTooltips);
        }
    };
    DateTimePickerLocalizationService.prototype.localizeDateTimePickerTooltips.$inject = ["datetimepicker"];
    /* @ngInject */ DateTimePickerLocalizationService = __decorate([
        SeDowngradeService(),
        __param(1, core.Inject(RESOLVED_LOCALE_TO_MOMENT_LOCALE_MAP)),
        __param(2, core.Inject(TOOLTIPS_MAP)),
        __metadata("design:paramtypes", [core$1.TranslateService, Object, Object, LanguageService])
    ], /* @ngInject */ DateTimePickerLocalizationService);
    return /* @ngInject */ DateTimePickerLocalizationService;
}());

var DATE_PICKER_CONFIG = {
    format: DATE_CONSTANTS.MOMENT_FORMAT,
    keepOpen: true,
    minDate: new Date(0),
    showClear: true,
    showClose: true,
    useCurrent: false,
    widgetPositioning: {
        horizontal: 'right',
        vertical: 'bottom'
    }
};
var RESOLVED_LOCALE_TO_MOMENT_LOCALE_MAP_VALUE = {
    in: 'id',
    zh: 'zh-cn'
};
var TOOLTIPS_MAP_VALUE = {
    today: 'se.datetimepicker.today',
    clear: 'se.datetimepicker.clear',
    close: 'se.datetimepicker.close',
    selectMonth: 'se.datetimepicker.selectmonth',
    prevMonth: 'se.datetimepicker.previousmonth',
    nextMonth: 'se.datetimepicker.nextmonth',
    selectYear: 'se.datetimepicker.selectyear',
    prevYear: 'se.datetimepicker.prevyear',
    nextYear: 'se.datetimepicker.nextyear',
    selectDecade: 'se.datetimepicker.selectdecade',
    prevDecade: 'se.datetimepicker.prevdecade',
    nextDecade: 'se.datetimepicker.nextdecade',
    prevCentury: 'se.datetimepicker.prevcentury',
    nextCentury: 'se.datetimepicker.nextcentury',
    pickHour: 'se.datetimepicker.pickhour',
    incrementHour: 'se.datetimepicker.incrementhour',
    decrementHour: 'se.datetimepicker.decrementhour',
    pickMinute: 'se.datetimepicker.pickminute',
    incrementMinute: 'se.datetimepicker.incrementminute',
    decrementMinute: 'se.datetimepicker.decrementminute',
    pickSecond: 'se.datetimepicker.picksecond',
    incrementSecond: 'se.datetimepicker.incrementsecond',
    decrementSecond: 'se.datetimepicker.decrementsecond',
    togglePeriod: 'se.datetimepicker.toggleperiod',
    selectTime: 'se.datetimepicker.selecttime'
};

/**
 * The date formatter is for displaying the date in the desired format.
 * You can pass the desired format in the attributes of this directive and it will be shown.
 * It is  used with the <input> tag as we cant use date filter with it.
 * for eg- <input type='text' dateFormatter formatType="short">
 * format-type can be short, medium etc.
 * If the format-type is not given in the directive template, by default it uses the short type
 */
var DateFormatterDirective = /** @class */ (function () {
    function DateFormatterDirective(ngModel, element, renderer, datePipe) {
        this.ngModel = ngModel;
        this.element = element;
        this.renderer = renderer;
        this.datePipe = datePipe;
    }
    DateFormatterDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.ngModel.valueChanges.subscribe(function (value) {
            var patchedValue = _this.datePipe.transform(value, _this.formatType || DATE_CONSTANTS.ANGULAR_FORMAT);
            if (patchedValue !== value) {
                _this.renderer.setProperty(_this.element.nativeElement, 'value', patchedValue);
            }
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], DateFormatterDirective.prototype, "formatType", void 0);
    DateFormatterDirective = __decorate([
        core.Directive({
            selector: '[ngModel][dateFormatter]',
            providers: [forms.NgModel, common.DatePipe]
        }),
        __metadata("design:paramtypes", [forms.NgModel,
            core.ElementRef,
            core.Renderer2,
            common.DatePipe])
    ], DateFormatterDirective);
    return DateFormatterDirective;
}());

window.__smartedit__.addDecoratorPayload("Component", "DateTimePickerComponent", {
    selector: 'se-date-time-picker',
    template: "<div #dateTimePicker *ngIf=\"isEditable\" class=\"input-group se-date-field\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{\n            'is-invalid': widget.field.hasErrors,\n            'is-warning': widget.field.hasWarnings,\n            'se-input--is-disabled': !isEditable\n        }\" [placeholder]=\"placeholderText | translate\" [attr.name]=\"widget.field.qualifier\"/> <span class=\"input-group-addon se-date-field--button\" [ngClass]=\"{ 'se-date-field--button-has-error': widget.field.hasErrors, 'se-date-field--button-has-warning': widget.field.hasWarnings }\"><span class=\"sap-icon--calendar se-date-field--button-icon\"></span></span></div><div class=\"input-group date se-date-field\" *ngIf=\"!isEditable\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{'se-input--is-disabled': !isEditable}\" [(ngModel)]=\"widget.model[this.widget.qualifier]\" dateFormatter formatType=\"short\" [disabled]=\"true\"/></div>"
});
var DateTimePickerComponent = /** @class */ (function () {
    function DateTimePickerComponent(widget, yjQuery, dateTimePickerLocalizationService) {
        this.widget = widget;
        this.yjQuery = yjQuery;
        this.dateTimePickerLocalizationService = dateTimePickerLocalizationService;
        this.placeholderText = 'se.componentform.select.date';
    }
    DateTimePickerComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.isEditable) {
            this.node
                .datetimepicker(DATE_PICKER_CONFIG)
                .on('dp.change', function () { return _this.handleDatePickerChange(); })
                .on('dp.show', function () { return _this.handleDatePickerShow(); });
            if (this.widget.model[this.widget.qualifier]) {
                setTimeout(function () {
                    _this.datetimepicker.date(moment(_this.widget.model[_this.widget.qualifier]));
                });
            }
        }
    };
    DateTimePickerComponent.prototype.handleDatePickerShow = function () {
        this.dateTimePickerLocalizationService.localizeDateTimePicker(this.datetimepicker);
    };
    DateTimePickerComponent.prototype.handleDatePickerChange = function () {
        var momentDate = this.datetimepicker.date();
        this.widget.model[this.widget.qualifier] = momentDate
            ? dateUtils.formatDateAsUtc(momentDate)
            : undefined;
    };
    Object.defineProperty(DateTimePickerComponent.prototype, "node", {
        get: function () {
            return this.yjQuery(this.dateTimePickerElement.nativeElement);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "datetimepicker", {
        get: function () {
            return this.node.datetimepicker().data('DateTimePicker');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "isEditable", {
        get: function () {
            return !this.widget.isFieldDisabled();
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        core.ViewChild('dateTimePicker', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], DateTimePickerComponent.prototype, "dateTimePickerElement", void 0);
    DateTimePickerComponent = __decorate([
        core.Component({
            selector: 'se-date-time-picker',
            template: "<div #dateTimePicker *ngIf=\"isEditable\" class=\"input-group se-date-field\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{\n            'is-invalid': widget.field.hasErrors,\n            'is-warning': widget.field.hasWarnings,\n            'se-input--is-disabled': !isEditable\n        }\" [placeholder]=\"placeholderText | translate\" [attr.name]=\"widget.field.qualifier\"/> <span class=\"input-group-addon se-date-field--button\" [ngClass]=\"{ 'se-date-field--button-has-error': widget.field.hasErrors, 'se-date-field--button-has-warning': widget.field.hasWarnings }\"><span class=\"sap-icon--calendar se-date-field--button-icon\"></span></span></div><div class=\"input-group date se-date-field\" *ngIf=\"!isEditable\" id=\"date-time-picker-{{widget.field.qualifier}}\"><input type=\"text\" class=\"fd-form-control se-date-field--input\" [ngClass]=\"{'se-input--is-disabled': !isEditable}\" [(ngModel)]=\"widget.model[this.widget.qualifier]\" dateFormatter formatType=\"short\" [disabled]=\"true\"/></div>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __param(1, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [Object, Function, DateTimePickerLocalizationService])
    ], DateTimePickerComponent);
    return DateTimePickerComponent;
}());

/**
 * The date time picker service module is a module used for displaying a date time picker
 *
 * Use the se-date-time-picker to open the date time picker.
 *
 * Once the se-date-time-picker is opened, its DateTimePickerLocalizationService is used to localize the tooling.
 */
var DateTimePickerModule = /** @class */ (function () {
    function DateTimePickerModule() {
    }
    DateTimePickerModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, forms.FormsModule, core$1.TranslateModule.forChild()],
            providers: [
                {
                    provide: RESOLVED_LOCALE_TO_MOMENT_LOCALE_MAP,
                    useValue: RESOLVED_LOCALE_TO_MOMENT_LOCALE_MAP_VALUE
                },
                {
                    provide: TOOLTIPS_MAP,
                    useValue: TOOLTIPS_MAP_VALUE
                },
                DateTimePickerLocalizationService
            ],
            declarations: [DateFormatterDirective, DateTimePickerComponent],
            entryComponents: [DateTimePickerComponent],
            exports: [DateFormatterDirective, DateTimePickerComponent]
        })
    ], DateTimePickerModule);
    return DateTimePickerModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "DropdownItemPrinterComponent", {
    selector: 'se-dropdown-item-printer',
    template: " <span>{{ data.item.label }}</span> "
});
var DropdownItemPrinterComponent = /** @class */ (function () {
    function DropdownItemPrinterComponent(data) {
        this.data = data;
    }
    DropdownItemPrinterComponent = __decorate([
        core.Component({
            selector: 'se-dropdown-item-printer',
            template: " <span>{{ data.item.label }}</span> "
        }),
        __param(0, core.Inject(ITEM_COMPONENT_DATA_TOKEN)),
        __metadata("design:paramtypes", [Object])
    ], DropdownItemPrinterComponent);
    return DropdownItemPrinterComponent;
}());
window.__smartedit__.addDecoratorPayload("Component", "DropdownComponent", {
    selector: 'se-dropdown-wrapper',
    template: "\n        <se-select\n            [id]=\"data.field.qualifier\"\n            class=\"se-generic-editor-dropdown\"\n            [(model)]=\"data.model[data.qualifier]\"\n            [searchEnabled]=\"false\"\n            [fetchStrategy]=\"fetchStrategy\"\n            [itemComponent]=\"itemComponent\"\n            [placeholder]=\"'se.genericeditor.sedropdown.placeholder'\"\n        ></se-select>\n    "
});
var DropdownComponent = /** @class */ (function () {
    function DropdownComponent(data) {
        this.data = data;
        this.itemComponent = DropdownItemPrinterComponent;
        var options = data.field.options;
        this.fetchStrategy = {
            fetchAll: function () { return Promise.resolve(options); }
        };
    }
    DropdownComponent = __decorate([
        core.Component({
            selector: 'se-dropdown-wrapper',
            template: "\n        <se-select\n            [id]=\"data.field.qualifier\"\n            class=\"se-generic-editor-dropdown\"\n            [(model)]=\"data.model[data.qualifier]\"\n            [searchEnabled]=\"false\"\n            [fetchStrategy]=\"fetchStrategy\"\n            [itemComponent]=\"itemComponent\"\n            [placeholder]=\"'se.genericeditor.sedropdown.placeholder'\"\n        ></se-select>\n    "
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], DropdownComponent);
    return DropdownComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "EditableDropdownComponent", {
    selector: 'se-editable-dropdown',
    template: "<se-generic-editor-dropdown [id]=\"data.id\" [field]=\"data.field\" [qualifier]=\"data.qualifier\" [model]=\"data.model\"></se-generic-editor-dropdown>"
});
var EditableDropdownComponent = /** @class */ (function () {
    function EditableDropdownComponent(data) {
        this.data = data;
    }
    EditableDropdownComponent = __decorate([
        core.Component({
            selector: 'se-editable-dropdown',
            template: "<se-generic-editor-dropdown [id]=\"data.id\" [field]=\"data.field\" [qualifier]=\"data.qualifier\" [model]=\"data.model\"></se-generic-editor-dropdown>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], EditableDropdownComponent);
    return EditableDropdownComponent;
}());

var EditableDropdownModule = /** @class */ (function () {
    function EditableDropdownModule() {
    }
    EditableDropdownModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, GenericEditorDropdownModule],
            declarations: [EditableDropdownComponent],
            entryComponents: [EditableDropdownComponent],
            exports: [EditableDropdownComponent]
        })
    ], EditableDropdownModule);
    return EditableDropdownModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "EmailComponent", {
    selector: 'se-email',
    template: "<input [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [max]=\"255\" type=\"email\" id=\"{{widget.field.qualifier}}-shortstring\" class=\"fd-form-control\"/>"
});
var /* @ngInject */ EmailComponent = /** @class */ (function () {
    EmailComponent.$inject = ["widget"];
    function /* @ngInject */ EmailComponent(widget) {
        this.widget = widget;
    }
    /* @ngInject */ EmailComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-email',
            template: "<input [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [max]=\"255\" type=\"email\" id=\"{{widget.field.qualifier}}-shortstring\" class=\"fd-form-control\"/>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ EmailComponent);
    return /* @ngInject */ EmailComponent;
}());

var EmailModule = /** @class */ (function () {
    function EmailModule() {
    }
    EmailModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, core$1.TranslateModule.forChild(), forms.FormsModule],
            declarations: [EmailComponent],
            entryComponents: [EmailComponent],
            exports: [EmailComponent]
        })
    ], EmailModule);
    return EmailModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "EnumItemPrinterComponent", {
    selector: 'se-enum-item-printer',
    template: " <span id=\"enum-{{ data.select.id }}\">{{ data.item.label }}</span> "
});
var EnumItemPrinterComponent = /** @class */ (function () {
    function EnumItemPrinterComponent(data) {
        this.data = data;
    }
    EnumItemPrinterComponent = __decorate([
        core.Component({
            selector: 'se-enum-item-printer',
            template: " <span id=\"enum-{{ data.select.id }}\">{{ data.item.label }}</span> "
        }),
        __param(0, core.Inject(ITEM_COMPONENT_DATA_TOKEN)),
        __metadata("design:paramtypes", [Object])
    ], EnumItemPrinterComponent);
    return EnumItemPrinterComponent;
}());
window.__smartedit__.addDecoratorPayload("Component", "EnumComponent", {
    selector: 'se-enum',
    template: "\n        <se-select\n            [id]=\"data.field.qualifier\"\n            class=\"se-generic-editor-dropdown\"\n            [(model)]=\"data.model[data.qualifier]\"\n            [isReadOnly]=\"data.isFieldDisabled()\"\n            [resetSearchInput]=\"false\"\n            [fetchStrategy]=\"fetchStrategy\"\n            [itemComponent]=\"itemComponent\"\n            [placeholder]=\"'se.genericeditor.sedropdown.placeholder'\"\n            [showRemoveButton]=\"true\"\n        ></se-select>\n    "
});
var EnumComponent = /** @class */ (function () {
    function EnumComponent(data) {
        var _this = this;
        this.data = data;
        this.itemComponent = EnumItemPrinterComponent;
        var editor = data.editor, field = data.field, qualifier = data.qualifier;
        this.fetchStrategy = {
            fetchAll: function (search) { return __awaiter(_this, void 0, void 0, function () {
                var options, selectItems;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: 
                        // the refereshOptions does not resolve with items, it populates the "field.options" object with the fetched data
                        return [4 /*yield*/, editor.refreshOptions(field, qualifier, search)];
                        case 1:
                            // the refereshOptions does not resolve with items, it populates the "field.options" object with the fetched data
                            _a.sent();
                            options = field.options[qualifier];
                            selectItems = options.map(function (option) { return (__assign(__assign({}, option), { id: option.code })); });
                            return [2 /*return*/, selectItems];
                    }
                });
            }); }
        };
    }
    EnumComponent = __decorate([
        core.Component({
            selector: 'se-enum',
            template: "\n        <se-select\n            [id]=\"data.field.qualifier\"\n            class=\"se-generic-editor-dropdown\"\n            [(model)]=\"data.model[data.qualifier]\"\n            [isReadOnly]=\"data.isFieldDisabled()\"\n            [resetSearchInput]=\"false\"\n            [fetchStrategy]=\"fetchStrategy\"\n            [itemComponent]=\"itemComponent\"\n            [placeholder]=\"'se.genericeditor.sedropdown.placeholder'\"\n            [showRemoveButton]=\"true\"\n        ></se-select>\n    "
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], EnumComponent);
    return EnumComponent;
}());

var DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION = '0.01';
window.__smartedit__.addDecoratorPayload("Component", "FloatComponent", {
    selector: 'se-float',
    template: "<input pattern=\"^[-]?([0-9]*)(.[0-9]{1,5})?$\" type=\"number\" id=\"{{widget.field.qualifier}}-float\" class=\"fd-form-control\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [step]=\"precision\"/>"
});
var /* @ngInject */ FloatComponent = /** @class */ (function () {
    FloatComponent.$inject = ["widget"];
    function /* @ngInject */ FloatComponent(widget) {
        this.widget = widget;
        this.precision = DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION;
    }
    /* @ngInject */ FloatComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-float',
            template: "<input pattern=\"^[-]?([0-9]*)(.[0-9]{1,5})?$\" type=\"number\" id=\"{{widget.field.qualifier}}-float\" class=\"fd-form-control\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" [step]=\"precision\"/>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ FloatComponent);
    return /* @ngInject */ FloatComponent;
}());

var FloatModule = /** @class */ (function () {
    function FloatModule() {
    }
    FloatModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, core$1.TranslateModule.forChild(), forms.FormsModule],
            declarations: [FloatComponent],
            entryComponents: [FloatComponent],
            exports: [FloatComponent]
        })
    ], FloatModule);
    return FloatModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "LongStringComponent", {
    template: "\n        <textarea\n            class=\"fd-form__control\"\n            [ngClass]=\"{ 'is-invalid': data.field.hasErrors, 'is-warning': data.field.hasWarnings }\"\n            [placeholder]=\"data.field.tooltip || '' | translate\"\n            [attr.name]=\"data.field.qualifier\"\n            [disabled]=\"data.isFieldDisabled()\"\n            [(ngModel)]=\"data.model[data.qualifier]\"\n        ></textarea>\n    ",
    selector: 'se-long-string'
});
var LongStringComponent = /** @class */ (function () {
    function LongStringComponent(data) {
        this.data = data;
    }
    LongStringComponent = __decorate([
        core.Component({
            template: "\n        <textarea\n            class=\"fd-form__control\"\n            [ngClass]=\"{ 'is-invalid': data.field.hasErrors, 'is-warning': data.field.hasWarnings }\"\n            [placeholder]=\"data.field.tooltip || '' | translate\"\n            [attr.name]=\"data.field.qualifier\"\n            [disabled]=\"data.isFieldDisabled()\"\n            [(ngModel)]=\"data.model[data.qualifier]\"\n        ></textarea>\n    ",
            selector: 'se-long-string'
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], LongStringComponent);
    return LongStringComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "NumberComponent", {
    selector: 'se-number',
    template: "<input [min]=\"1\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" id=\"{{widget.field.qualifier}}-number\" class=\"fd-form-control\" type=\"number\"/>"
});
var /* @ngInject */ NumberComponent = /** @class */ (function () {
    NumberComponent.$inject = ["widget"];
    function /* @ngInject */ NumberComponent(widget) {
        this.widget = widget;
    }
    /* @ngInject */ NumberComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-number',
            template: "<input [min]=\"1\" [ngClass]=\"{ 'is-invalid': widget.field.hasErrors, 'is-warning': widget.field.hasWarnings }\" [placeholder]=\"(widget.field.tooltip || '') | translate\" [attr.name]=\"widget.field.qualifier\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" id=\"{{widget.field.qualifier}}-number\" class=\"fd-form-control\" type=\"number\"/>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], /* @ngInject */ NumberComponent);
    return /* @ngInject */ NumberComponent;
}());

var NumberModule = /** @class */ (function () {
    function NumberModule() {
    }
    NumberModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, core$1.TranslateModule.forChild(), forms.FormsModule],
            declarations: [NumberComponent],
            entryComponents: [NumberComponent],
            exports: [NumberComponent]
        })
    ], NumberModule);
    return NumberModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
var RESOLVED_LOCALE_TO_CKEDITOR_LOCALE_MAP = new core.InjectionToken('resolvedLocaleToCKEDITORLocaleMap');
var RICH_TEXT_CONFIGURATION = new core.InjectionToken('richTextConfiguration');

var /* @ngInject */ GenericEditorSanitizationService = /** @class */ (function () {
    GenericEditorSanitizationService.$inject = ["domSanitizer"];
    function /* @ngInject */ GenericEditorSanitizationService(domSanitizer) {
        this.domSanitizer = domSanitizer;
    }
    /* @ngInject */ GenericEditorSanitizationService.prototype.isSanitized = function (content) {
        var sanitizedContent = this.domSanitizer
            .sanitize(core.SecurityContext.HTML, content)
            .replace(/&#10;/g, '\n')
            .replace(/&#160;/g, '\u00a0')
            .replace(/<br>/g, '<br />');
        var originalContent = content
            .replace(/&#10;/g, '\n')
            .replace(/&#160;/g, '\u00a0')
            .replace(/<br>/g, '<br />');
        return sanitizedContent === originalContent;
    };
    GenericEditorSanitizationService.prototype.isSanitized.$inject = ["content"];
    /* @ngInject */ GenericEditorSanitizationService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [platformBrowser.DomSanitizer])
    ], /* @ngInject */ GenericEditorSanitizationService);
    return /* @ngInject */ GenericEditorSanitizationService;
}());

var /* @ngInject */ RichTextFieldLocalizationService = /** @class */ (function () {
    RichTextFieldLocalizationService.$inject = ["languageService", "resolvedLocaleToCKEDITORLocaleMap"];
    function /* @ngInject */ RichTextFieldLocalizationService(languageService, resolvedLocaleToCKEDITORLocaleMap) {
        this.languageService = languageService;
        this.resolvedLocaleToCKEDITORLocaleMap = resolvedLocaleToCKEDITORLocaleMap;
    }
    /* @ngInject */ RichTextFieldLocalizationService.prototype.localizeCKEditor = function () {
        var _this = this;
        return this.languageService.getResolveLocale().then(function (locale) {
            CKEDITOR.config.language = _this.convertResolvedToCKEditorLocale(locale);
        });
    };
    /* @ngInject */ RichTextFieldLocalizationService.prototype.convertResolvedToCKEditorLocale = function (resolvedLocale) {
        var conversion = this.resolvedLocaleToCKEDITORLocaleMap[resolvedLocale];
        if (conversion) {
            return conversion;
        }
        return resolvedLocale;
    };
    RichTextFieldLocalizationService.prototype.convertResolvedToCKEditorLocale.$inject = ["resolvedLocale"];
    /* @ngInject */ RichTextFieldLocalizationService = __decorate([
        SeDowngradeService(),
        __param(1, core.Inject(RESOLVED_LOCALE_TO_CKEDITOR_LOCALE_MAP)),
        __metadata("design:paramtypes", [LanguageService, Object])
    ], /* @ngInject */ RichTextFieldLocalizationService);
    return /* @ngInject */ RichTextFieldLocalizationService;
}());

var /* @ngInject */ RichTextLoaderService = /** @class */ (function () {
    function /* @ngInject */ RichTextLoaderService() {
        var _this = this;
        this.loadPromise = new Promise(function (resolve) {
            _this.checkLoadedInterval = setInterval(function () {
                if (CKEDITOR.status === 'loaded') {
                    resolve();
                    clearInterval(_this.checkLoadedInterval);
                    _this.checkLoadedInterval = null;
                }
            }, 100);
        });
    }
    /* @ngInject */ RichTextLoaderService.prototype.load = function () {
        return this.loadPromise;
    };
    /* @ngInject */ RichTextLoaderService = __decorate([
        SeDowngradeService(),
        __metadata("design:paramtypes", [])
    ], /* @ngInject */ RichTextLoaderService);
    return /* @ngInject */ RichTextLoaderService;
}());

window.__smartedit__.addDecoratorPayload("Component", "RichTextFieldComponent", {
    selector: 'se-rich-text-field',
    template: "<textarea #textarea class=\"fd-form__control\" [ngClass]=\"{'has-error': widget.field.hasErrors}\" name=\"{{widget.field.qualifier}}-{{widget.qualifier}}\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" (change)=\"reassignUserCheck()\"></textarea><div *ngIf=\"requiresUserCheck()\"><div id=\"richTextWarningMessage\" [hidden]=\"widget.field.isUserChecked\"><span fd-status-label [status]=\"'warning'\" [icon]=\"'message-warning'\">{{'se.editor.richtext.message.warning' | translate}}</span></div><input id=\"richTextWarningCheckBox\" type=\"checkbox\" [(ngModel)]=\"widget.field.isUserChecked\" (click)=\"checkboxOnClick($event.target)\"/> <span [ngClass]=\"{'warning-check-msg': true, 'not-checked': widget.editor.hasFrontEndValidationErrors && !widget.field.isUserChecked}\">{{'se.editor.richtext.check' | translate}}</span></div>"
});
var /* @ngInject */ RichTextFieldComponent = /** @class */ (function () {
    RichTextFieldComponent.$inject = ["widget", "seRichTextLoaderService", "seRichTextConfiguration", "genericEditorSanitizationService", "seRichTextFieldLocalizationService", "settingsService"];
    function /* @ngInject */ RichTextFieldComponent(widget, seRichTextLoaderService, seRichTextConfiguration, genericEditorSanitizationService, seRichTextFieldLocalizationService, settingsService) {
        this.widget = widget;
        this.seRichTextLoaderService = seRichTextLoaderService;
        this.seRichTextConfiguration = seRichTextConfiguration;
        this.genericEditorSanitizationService = genericEditorSanitizationService;
        this.seRichTextFieldLocalizationService = seRichTextFieldLocalizationService;
        this.settingsService = settingsService;
    }
    /* @ngInject */ RichTextFieldComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        return this.settingsService
            .get('cms.components.allowUnsafeJavaScript')
            .then(function (allowUnsafeJavaScript) {
            return _this.seRichTextLoaderService.load().then(function () {
                _this.seRichTextConfiguration.allowedContent = allowUnsafeJavaScript === 'true';
                _this.editorInstance = CKEDITOR.replace(_this.textarea.nativeElement, _this.seRichTextConfiguration);
                _this.seRichTextFieldLocalizationService.localizeCKEditor();
                if (_this.editorInstance) {
                    _this.editorInstance.on('change', function () { return _this.onChange(); });
                    _this.editorInstance.on('mode', function () { return _this.onMode(); });
                    CKEDITOR.on('instanceReady', function (ev) { return _this.onInstanceReady(ev); });
                }
            });
        });
    };
    /* @ngInject */ RichTextFieldComponent.prototype.ngOnDestroy = function () {
        if (this.editorInstance && CKEDITOR.instances[this.editorInstance.name]) {
            CKEDITOR.instances[this.editorInstance.name].destroy();
        }
    };
    /* @ngInject */ RichTextFieldComponent.prototype.onChange = function () {
        var _this = this;
        setTimeout(function () {
            _this.widget.model[_this.widget.qualifier] = _this.editorInstance.getData();
            _this.reassignUserCheck();
            _this.toggleSubmitButton(_this.requiresUserCheck() && !_this.widget.field.isUserChecked);
        });
    };
    /* @ngInject */ RichTextFieldComponent.prototype.onMode = function () {
        var _this = this;
        if (this.editorInstance.mode === 'source') {
            var editable = this.editorInstance.editable();
            editable.attachListener(editable, 'input', function () {
                _this.editorInstance.fire('change');
            });
        }
    };
    /* @ngInject */ RichTextFieldComponent.prototype.onInstanceReady = function (ev) {
        var tags = CKEDITOR.dtd;
        var elements = __assign(__assign(__assign(__assign(__assign({}, tags.$nonBodyContent), tags.$block), tags.$listItem), tags.$tableContent), { br: 1 });
        for (var _i = 0, _a = Object.keys(elements); _i < _a.length; _i++) {
            var element = _a[_i];
            ev.editor.dataProcessor.writer.setRules(element, {
                indent: false,
                breakBeforeOpen: false,
                breakAfterOpen: false,
                breakBeforeClose: false,
                breakAfterClose: false
            });
        }
        ev.editor.dataProcessor.writer.lineBreakChars = '';
        ev.editor.dataProcessor.writer.indentationChars = '';
    };
    RichTextFieldComponent.prototype.onInstanceReady.$inject = ["ev"];
    /* @ngInject */ RichTextFieldComponent.prototype.requiresUserCheck = function () {
        var requiresUserCheck = false;
        for (var qualifier in this.widget.field.requiresUserCheck) {
            if (this.widget.field.requiresUserCheck.hasOwnProperty(qualifier)) {
                requiresUserCheck =
                    requiresUserCheck || this.widget.field.requiresUserCheck[qualifier];
            }
        }
        return requiresUserCheck;
    };
    /* @ngInject */ RichTextFieldComponent.prototype.reassignUserCheck = function () {
        if (this.widget.model &&
            this.widget.qualifier &&
            this.widget.model[this.widget.qualifier]) {
            var sanitizedContentMatchesContent = this.genericEditorSanitizationService.isSanitized(this.widget.model[this.widget.qualifier]);
            this.widget.field.requiresUserCheck = this.widget.field.requiresUserCheck || {};
            this.widget.field.requiresUserCheck[this.widget.qualifier] = !sanitizedContentMatchesContent;
        }
        else {
            this.widget.field.requiresUserCheck = this.widget.field.requiresUserCheck || {};
            this.widget.field.requiresUserCheck[this.widget.qualifier] = false;
        }
    };
    /* @ngInject */ RichTextFieldComponent.prototype.checkboxOnClick = function (event) {
        this.toggleSubmitButton(!event.checked);
    };
    RichTextFieldComponent.prototype.checkboxOnClick.$inject = ["event"];
    /* @ngInject */ RichTextFieldComponent.prototype.toggleSubmitButton = function (state) {
        this.widget.editor.api.setInProgress(state);
    };
    RichTextFieldComponent.prototype.toggleSubmitButton.$inject = ["state"];
    __decorate([
        core.ViewChild('textarea', { static: false }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ RichTextFieldComponent.prototype, "textarea", void 0);
    /* @ngInject */ RichTextFieldComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-rich-text-field',
            template: "<textarea #textarea class=\"fd-form__control\" [ngClass]=\"{'has-error': widget.field.hasErrors}\" name=\"{{widget.field.qualifier}}-{{widget.qualifier}}\" [disabled]=\"widget.isFieldDisabled()\" [(ngModel)]=\"widget.model[widget.qualifier]\" (change)=\"reassignUserCheck()\"></textarea><div *ngIf=\"requiresUserCheck()\"><div id=\"richTextWarningMessage\" [hidden]=\"widget.field.isUserChecked\"><span fd-status-label [status]=\"'warning'\" [icon]=\"'message-warning'\">{{'se.editor.richtext.message.warning' | translate}}</span></div><input id=\"richTextWarningCheckBox\" type=\"checkbox\" [(ngModel)]=\"widget.field.isUserChecked\" (click)=\"checkboxOnClick($event.target)\"/> <span [ngClass]=\"{'warning-check-msg': true, 'not-checked': widget.editor.hasFrontEndValidationErrors && !widget.field.isUserChecked}\">{{'se.editor.richtext.check' | translate}}</span></div>"
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __param(2, core.Inject(RICH_TEXT_CONFIGURATION)),
        __metadata("design:paramtypes", [Object, RichTextLoaderService, Object, GenericEditorSanitizationService,
            RichTextFieldLocalizationService,
            SettingsService])
    ], /* @ngInject */ RichTextFieldComponent);
    return /* @ngInject */ RichTextFieldComponent;
}());

var RichTextFieldModule = /** @class */ (function () {
    function RichTextFieldModule() {
    }
    RichTextFieldModule = __decorate([
        core.NgModule({
            imports: [common.CommonModule, forms.FormsModule, core$1.TranslateModule.forChild(), core$2.BadgeLabelModule],
            providers: [
                GenericEditorSanitizationService,
                RichTextFieldLocalizationService,
                RichTextLoaderService,
                SettingsService,
                {
                    provide: RESOLVED_LOCALE_TO_CKEDITOR_LOCALE_MAP,
                    useValue: {
                        in: 'id',
                        es_CO: 'es'
                    }
                },
                {
                    provide: RICH_TEXT_CONFIGURATION,
                    useValue: {
                        toolbar: 'full',
                        toolbar_full: [
                            {
                                name: 'basicstyles',
                                items: ['Bold', 'Italic', 'Strike', 'Underline']
                            },
                            {
                                name: 'paragraph',
                                items: ['BulletedList', 'NumberedList', 'Blockquote']
                            },
                            {
                                name: 'editing',
                                items: ['JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']
                            },
                            {
                                name: 'links',
                                items: ['Link', 'Unlink', 'Anchor']
                            },
                            {
                                name: 'tools',
                                items: ['SpellChecker', 'Maximize']
                            },
                            '/',
                            {
                                name: 'styles',
                                items: [
                                    'Format',
                                    'Font',
                                    'FontSize',
                                    'TextColor',
                                    'PasteText',
                                    'PasteFromWord',
                                    'RemoveFormat'
                                ]
                            },
                            {
                                name: 'insert',
                                items: ['Image', 'Table', 'SpecialChar']
                            },
                            {
                                name: 'forms',
                                items: ['Outdent', 'Indent']
                            },
                            '/',
                            {
                                name: 'clipboard',
                                items: ['Undo', 'Redo']
                            },
                            {
                                name: 'document',
                                items: ['PageBreak', 'Source']
                            }
                        ],
                        disableNativeSpellChecker: false,
                        height: '100px',
                        width: '100%',
                        autoParagraph: false,
                        basicEntities: false,
                        fillEmptyBlocks: false,
                        extraAllowedContent: 'div(*)[role]',
                        extraPlugins: 'colorbutton, colordialog, font',
                        font_names: 'Arial/Arial, Helvetica, sans-serif;Times New Roman/Times New Roman, Times, serif;Verdana',
                        fontSize_sizes: '10/10px;12/12px;14/14px;16/16px;18/18px;20/20px;22/22px;24/24px;36/36px;48/48px;',
                        protectedSource: [/\r|\n|\r\n|\t/g]
                    }
                }
            ],
            declarations: [RichTextFieldComponent],
            entryComponents: [RichTextFieldComponent],
            exports: [RichTextFieldComponent]
        })
    ], RichTextFieldModule);
    return RichTextFieldModule;
}());

window.__smartedit__.addDecoratorPayload("Component", "ShortStringComponent", {
    template: "\n        <input\n            type=\"text\"\n            id=\"{{ data.field.qualifier }}-shortstring\"\n            [ngClass]=\"{\n                'is-invalid': data.field.hasErrors,\n                'is-warning': data.field.hasWarnings\n            }\"\n            class=\"fd-form-control\"\n            [placeholder]=\"data.field.tooltip || '' | translate\"\n            [attr.name]=\"data.field.qualifier\"\n            [disabled]=\"data.isFieldDisabled()\"\n            [(ngModel)]=\"data.model[data.qualifier]\"\n        />\n    ",
    selector: 'se-short-string'
});
var ShortStringComponent = /** @class */ (function () {
    function ShortStringComponent(data) {
        this.data = data;
    }
    ShortStringComponent = __decorate([
        core.Component({
            template: "\n        <input\n            type=\"text\"\n            id=\"{{ data.field.qualifier }}-shortstring\"\n            [ngClass]=\"{\n                'is-invalid': data.field.hasErrors,\n                'is-warning': data.field.hasWarnings\n            }\"\n            class=\"fd-form-control\"\n            [placeholder]=\"data.field.tooltip || '' | translate\"\n            [attr.name]=\"data.field.qualifier\"\n            [disabled]=\"data.isFieldDisabled()\"\n            [(ngModel)]=\"data.model[data.qualifier]\"\n        />\n    ",
            selector: 'se-short-string'
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], ShortStringComponent);
    return ShortStringComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "TextComponent", {
    template: " <p [id]=\"data.field.qualifier + '-text'\">{{ data.model[data.qualifier] }}</p> ",
    selector: 'se-component-text'
});
var TextComponent = /** @class */ (function () {
    function TextComponent(data) {
        this.data = data;
    }
    TextComponent = __decorate([
        core.Component({
            template: " <p [id]=\"data.field.qualifier + '-text'\">{{ data.model[data.qualifier] }}</p> ",
            selector: 'se-component-text'
        }),
        __param(0, core.Inject(GENERIC_EDITOR_WIDGET_DATA)),
        __metadata("design:paramtypes", [Object])
    ], TextComponent);
    return TextComponent;
}());

/**
 * FLOAT PRECISION
 */
/* @internal  */
var DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION$1 = '0.01';
/**
 * The editorFieldMappingService contains the strategies that the `GenericEditorComponent` component
 * uses to control the rendering of a field. When the genericEditor directive is about to display a field, it queries the
 * editorFieldMappingService service to retrieve the right strategies to use. Internally, this service makes this selection based on three
 * matchers:
 * <ul>
 * 	<li><b>structureTypeNameMatcher</b>:	The matcher for the cmsStructureType of a field.</li>
 * 	<li><b>componentTypeNameMatcher</b>:	The matcher for the smarteditComponentType of the CMS component containing the field.</li>
 * <li><b>discriminatorMatcher</b>:			The matcher for the qualifier used by the genericEditor to identify the field.</li>
 * </ul>
 * These three matchers are used together to provide finer-grained control on the selection of strategies. A matcher itself is either a
 * string or a function that will be used to determine whether a value is considered a match or not. The following list describes
 * how a matcher behaves depending on its type:
 * <ul>
 *  <li><b>String</b>:                      Matches only the parameters that equal the provided string. </li>
 *  <li><b>Null</b>:                        Matches any parameter provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
 *  <li><b>Function</b>:                    Matches only the parameters for which the provided callback returns true. This option allows more
 *                                          control over the parameters to match.
 * </li>
 * </ul>
 * <br/>
 *
 * Currently, there are two types of strategies that the genericEditor uses to control the way a field is rendered:
 * <ul>
 *  <li><b>editor field mapping</b>:        This strategy is used to select and customize which property editor is to be used for this field.</li>
 *  <li><b>tab field mapping</b>:           This strategy is used to select the tab in the genericEditor where a field will be positioned.</li>
 * </ul>
 *
 */
var /* @ngInject */ EditorFieldMappingService = /** @class */ (function () {
    EditorFieldMappingService.$inject = ["logService"];
    function /* @ngInject */ EditorFieldMappingService(logService) {
        this.logService = logService;
        // --------------------------------------------------------------------------------------
        // Variables
        // --------------------------------------------------------------------------------------
        this._editorsFieldMapping = [];
        this._fieldsTabsMapping = [];
    }
    /* @ngInject */ EditorFieldMappingService_1 = /* @ngInject */ EditorFieldMappingService;
    // --------------------------------------------------------------------------------------
    // Public API
    // --------------------------------------------------------------------------------------
    /**
     * This method overrides the default strategy of the `GenericEditorComponent` directive.
     * used to choose the property editor for a given field. Internally, this selection is based on three matchers:
     * <ul>
     * 	<li><b>structureTypeNameMatcher</b>:	The matcher for the cmsStructureType of a field.</li>
     * 	<li><b>componentTypeNameMatcher</b>:	The matcher for the smarteditComponentType of the CMS component containing the field.</li>
     * <li><b>discriminatorMatcher</b>:			The matcher for the qualifier used by the genericEditor to identify the field.</li>
     * </ul>
     * Only the fields that match all three matchers will be overriden.
     *
     * The following example shows how some sample fields would match some mappings:
     * <pre>
     * const field1 = {
     * 		cmsStructureType: 'ShortString',
     * 		smarteditComponentType: 'CmsParagraphComponent',
     * 		qualifier: 'name'
     * };
     *
     *  const field2 = {
     *      cmsStructureType: 'Boolean',
     *      smarteditComponentType: 'CmsParagraphComponent',
     *      qualifier: 'visible'
     *  };
     * </pre>
     *
     * <pre>
     * // This mapping won't match any of the fields. They don't match all three matchers.
     * editorFieldMappingService.addFieldMapping(
     *  'ShortString', 'CmsParagraphComponent', 'visible', configuration);
     *
     * // This mapping will match field2. It matches all three matchers perfectly.
     * editorFieldMappingService.addFieldMapping(
     *  'Boolean', 'CmsParagraphComponent', 'visible', configuration);
     *
     * // This mapping will match both fields. They match all three matchers.
     * // Note that both null and '*' represent a wildcard that accepts any value.
     * editorFieldMappingService.addFieldMapping(
     *  null, 'CmsParagraphComponent', '*', configuration);
     * </pre>
     *
     * <b>Note:</b> <br/>
     * The genericEditor has some predefined editors for the following cmsStructureTypes:
     * <ul>
     * 		<li><b>ShortString</b>:			Displays a text input field.</li>
     * 		<li><b>LongString</b>:  		Displays a text area.</li>
     * 		<li><b>RichText</b>:    		Displays an HTML/rich text editor.</li>
     * 		<li><b>Boolean</b>:     		Displays a check box.</li>
     * 		<li><b>DateTime</b>:        	Displays an input field with a date-time picker.</li>
     * 		<li><b>Media</b>:       		Displays a filterable dropdown list of media</li>
     * 		<li><b>Enum</b>:		 		Displays a filterable dropdown list of the enum class values identified by cmsStructureEnumType property.
     * 		<li><b>EditableDropdown</b>: 	Displays a configurable dropdown list that is enabled by `GenericEditorDropdownComponent`.
     * </ul>
     * <br />
     * You can program the `GenericEditorComponent` to use other property editors for these
     * cmsStructureTypes. You can also add custom cmsStructureTypes.
     * All default and custom property editors are HTML templates. These templates must adhere to the PropertyEditorTemplate {@link PropertyEditorTemplate contract}.
     *
     * @param structureTypeName The matcher used to identify the cmsStructureTypes for which a custom property editor is
     * required.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>
     *  <li><b>field:</b>                      The field to evaluate.</li>
     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * </li>
     * </ul>
     * @param componentTypeName The matcher used to identify the smarteditComponentType for which a custom property editor is
     * required.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>
     *  <li><b>field:</b>                     The field to evaluate. </li>
     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * </li>
     * </ul>
     * @param discriminator The matcher used to identify the discriminator for which a custom property editor is
     * required.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>
     *  <li><b>field:</b>                       The field to evaluate. </li>
     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * @param configuration The holder that contains the override instructions. Cannot be null.
     * @param configuration.template The path to the HTML template used in the override. Cannot be null.
     * @param  configuration.customSanitize Custom sanitize function for a custom property editor. It's provided with a payload and
     * an optional `functionsModule.sanitize` function.
     */
    /* @ngInject */ EditorFieldMappingService.prototype.addFieldMapping = function (structureTypeName, componentTypeName, discriminator, configuration) {
        this._addMapping(structureTypeName, componentTypeName, discriminator, configuration, this._editorsFieldMapping);
    };
    EditorFieldMappingService.prototype.addFieldMapping.$inject = ["structureTypeName", "componentTypeName", "discriminator", "configuration"];
    /**
     * This method is used by the genericEditor to retrieve the property editor to be rendered in a generic editor, along with its configuration.
     * If more than one property editor could be applied to the provided field, the one with the most accurate match will be used.
     *
     * Note:
     * Currently, all templates in SmartEdit use the short form. Before returning a response, this method ensures that
     * the template provided to the generic editor is in short form. For example:
     * - A template 'genericEditor/templates/shortStringTemplate.html' will be transformed to 'shortStringTemplate.html'
     *
     * @param field The object that represents the field that the property editor is retrieved for.
     * @param field.cmsStructureType The cmsStructureType that the property editor is retrieved for.
     * @param field.smarteditComponentType The smarteditComponentType that the property editor is retrieved for.
     * @param field.qualifier The field name of the smarteditComponentType that the property editor is retrieved for.
     * @param componentTypeStructure The smarteditComponentType structure of the componenent that contains the field that the property editor
     * is retrieved for.
     * @returns The configuration of the property editor to be used for this field. Can be null if no adequate match is found.
     *
     */
    /* @ngInject */ EditorFieldMappingService.prototype.getEditorFieldMapping = function (field, componentTypeStructure) {
        var fieldMapping = this._getMapping(field, componentTypeStructure, this._editorsFieldMapping);
        if (!fieldMapping) {
            this.logService.warn('editorFieldMappingService - Cannot find suitable field mapping for type ', field.cmsStructureType);
            fieldMapping = null;
        }
        else if (fieldMapping && fieldMapping.template) {
            fieldMapping.template = this._cleanTemplate(fieldMapping.template);
        }
        return fieldMapping;
    };
    EditorFieldMappingService.prototype.getEditorFieldMapping.$inject = ["field", "componentTypeStructure"];
    /**
     * This method overrides the default strategy of the `GenericEditorComponent` directive
     * used to choose the tab where to render a field in the generic editor. Internally, this selection is based on three elements:
     * <ul>
     * 	<li><b>structureTypeName</b>:			The cmsStructureType of a field.</li>
     * 	<li><b>componentTypeName</b>:			The smarteditComponentType of the component containing the field.</li>
     * <li><b>discriminator</b>:			    The qualifier used by the genericEditor to identify the field.</li>
     * </ul>
     * Only the fields that match all three elements will be overriden.
     *
     * The following example shows how sample fields would match some mappings:
     * <pre>
     *  const field1 = {
     *      cmsStructureType: 'ShortString',
     *      smarteditComponentType: 'CmsParagraphComponent',
     *      qualifier: 'name'
     *  };
     *
     *  const field2 = {
     *      cmsStructureType: 'Boolean',
     *      smarteditComponentType: 'CmsParagraphComponent',
     *      qualifier: 'visible'
     *  };
     * </pre>
     *
     * <pre>
     * // This mapping won't match any of the fields. They don't match all three matchers.
     * editorFieldMappingService.addFieldTabMapping(
     *  'ShortString', 'CmsParagraphComponent', 'visible', tabId);
     *
     * // This mapping will match field2. It matches all three matchers perfectly.
     * editorFieldMappingService.addFieldTabMapping(
     *  'Boolean', 'CmsParagraphComponent', 'visible', tabId);
     *
     * // This mapping will match both fields. They match all three matchers.
     * // Note that both null and '*' represent a wildcard that accepts any value.
     * editorFieldMappingService.addFieldTabMapping(
     *  null, 'CmsParagraphComponent', '*', tabId);
     * </pre>
     *
     * @param structureTypeNameMatcher The matcher used to identify the cmsStructureTypes for which to find its tab.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>
     *  <li><b>field:</b>                      The field to evaluate.</li>
     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * </li>
     * </ul>
     * @param {String | Function} componentTypeName The matcher used to identify the smarteditComponentType for which for which to find its tab.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>
     *  <li><b>field:</b>                     The field to evaluate. </li>
     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * </li>
     * </ul>
     * @param discriminator The matcher used to identify the discriminator for which for which to find its tab.
     * There are three possible values for this parameter:
     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>
     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>
     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more
     *                                          control over the types to match.
     *
     * This function will be called with three parameters:
     * <ul>
     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>
     *  <li><b>field:</b>                       The field to evaluate. </li>
     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>
     * </ul>
     * </li>
     * </ul>
     * @param tabId The ID of the tab where the field must be rendered in the generic editor.
     */
    /* @ngInject */ EditorFieldMappingService.prototype.addFieldTabMapping = function (structureTypeName, componentTypeName, discriminator, tabId) {
        this._addMapping(structureTypeName, componentTypeName, discriminator, tabId, this._fieldsTabsMapping);
    };
    EditorFieldMappingService.prototype.addFieldTabMapping.$inject = ["structureTypeName", "componentTypeName", "discriminator", "tabId"];
    /**
     * This method is used by the genericEditor to retrieve the tab where the field will be rendered in the generic editor.
     * If more than one tab matches the field provided, then the tab with the most accurate match will be used.
     *
     * @param field The object that represents the field that the tab is retrieved for.
     * @param field.cmsStructureType The cmsStructureType that the tab is retrieved for.
     * @param field.smarteditComponentType The smarteditComponentType that the tab is retrieved for.
     * @param field.qualifier The field name of the smarteditComponentType that the tab is retrieved for.
     * @param componentTypeStructure The smarteditComponentType structure of the component that contains the field that the tab is retrieved for.
     * @returns The ID of the tab where this field must reside. Can be null if no adequate match is found.
     *
     */
    /* @ngInject */ EditorFieldMappingService.prototype.getFieldTabMapping = function (field, componentTypeStructure) {
        return this._getMapping(field, componentTypeStructure, this._fieldsTabsMapping);
    };
    EditorFieldMappingService.prototype.getFieldTabMapping.$inject = ["field", "componentTypeStructure"];
    // --------------------------------------------------------------------------------------
    // Helper Methods
    // --------------------------------------------------------------------------------------
    /* @ngInject */ EditorFieldMappingService.prototype._addMapping = function (structureTypeMatcher, componentTypeMatcher, discriminatorMatcher, mappedValue, collection) {
        structureTypeMatcher = this._validateField(structureTypeMatcher);
        componentTypeMatcher = this._validateField(componentTypeMatcher);
        discriminatorMatcher = this._validateField(discriminatorMatcher);
        var newMapping = {
            structureTypeMatcher: structureTypeMatcher,
            componentTypeMatcher: componentTypeMatcher,
            discriminatorMatcher: discriminatorMatcher,
            value: mappedValue
        };
        lodash.remove(collection, function (element) {
            return element.structureTypeMatcher === structureTypeMatcher &&
                element.componentTypeMatcher === componentTypeMatcher &&
                element.discriminatorMatcher === discriminatorMatcher;
        });
        collection.push(newMapping);
    };
    EditorFieldMappingService.prototype._addMapping.$inject = ["structureTypeMatcher", "componentTypeMatcher", "discriminatorMatcher", "mappedValue", "collection"];
    /* @ngInject */ EditorFieldMappingService.prototype._validateField = function (field) {
        if (field === null) {
            field = /* @ngInject */ EditorFieldMappingService_1.WILDCARD;
        }
        else if (typeof field !== 'string' && typeof field !== 'function') {
            throw new Error('editorFieldMappingService: Mapping matcher must be of type string or function.');
        }
        return field;
    };
    EditorFieldMappingService.prototype._validateField.$inject = ["field"];
    /* @ngInject */ EditorFieldMappingService.prototype._getMapping = function (field, componentTypeStructure, collection) {
        var _this = this;
        var result = null;
        var maxValue = 0;
        collection.forEach(function (mappingEntry) {
            var mappingValue = _this._evaluateMapping(mappingEntry, field, componentTypeStructure);
            if (mappingValue > maxValue) {
                result = mappingEntry.value;
                maxValue = mappingValue;
            }
        });
        return result;
    };
    EditorFieldMappingService.prototype._getMapping.$inject = ["field", "componentTypeStructure", "collection"];
    /* @ngInject */ EditorFieldMappingService.prototype._evaluateMapping = function (mappingEntry, field, componentTypeStructure) {
        var componentTypeMatch;
        var discriminatorMatch;
        var mappingMatch = /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;
        var structureTypeMatch = this._evaluateMatcher(mappingEntry.structureTypeMatcher, field.cmsStructureType, field, componentTypeStructure);
        if (structureTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {
            componentTypeMatch = this._evaluateMatcher(mappingEntry.componentTypeMatcher, field.smarteditComponentType, field, componentTypeStructure);
            if (componentTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {
                discriminatorMatch = this._evaluateMatcher(mappingEntry.discriminatorMatcher, field.qualifier, field, componentTypeStructure);
            }
        }
        if (structureTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE &&
            componentTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE &&
            discriminatorMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {
            mappingMatch = structureTypeMatch + componentTypeMatch + discriminatorMatch;
        }
        return mappingMatch;
    };
    EditorFieldMappingService.prototype._evaluateMapping.$inject = ["mappingEntry", "field", "componentTypeStructure"];
    /* @ngInject */ EditorFieldMappingService.prototype._evaluateMatcher = function (matcher, actualValue, field, componentTypeStructure) {
        if (typeof matcher === 'string') {
            if (matcher === /* @ngInject */ EditorFieldMappingService_1.WILDCARD) {
                return /* @ngInject */ EditorFieldMappingService_1.MATCH.PARTIAL;
            }
            else {
                return this._exactValueMatchPredicate(matcher, actualValue)
                    ? /* @ngInject */ EditorFieldMappingService_1.MATCH.EXACT
                    : /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;
            }
        }
        else {
            return matcher(actualValue, field, componentTypeStructure)
                ? /* @ngInject */ EditorFieldMappingService_1.MATCH.EXACT
                : /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;
        }
    };
    EditorFieldMappingService.prototype._evaluateMatcher.$inject = ["matcher", "actualValue", "field", "componentTypeStructure"];
    /* @ngInject */ EditorFieldMappingService.prototype._registerDefaultFieldMappings = function () {
        if (!this._initialized) {
            this._initialized = true;
            this.addFieldMapping('Boolean', null, null, {
                component: BooleanComponent
            });
            this.addFieldMapping('ShortString', null, null, {
                component: ShortStringComponent
            });
            this.addFieldMapping('Text', null, null, {
                component: TextComponent
            });
            this.addFieldMapping('LongString', null, null, {
                component: LongStringComponent
            });
            this.addFieldMapping('RichText', null, null, {
                component: RichTextFieldComponent
            });
            this.addFieldMapping('Number', null, null, {
                component: NumberComponent
            });
            this.addFieldMapping('Float', null, null, {
                component: FloatComponent
            });
            this.addFieldMapping('Dropdown', null, null, {
                component: DropdownComponent
            });
            this.addFieldMapping('EditableDropdown', null, null, {
                component: EditableDropdownComponent
            });
            this.addFieldMapping('DateTime', null, null, {
                component: DateTimePickerComponent
            });
            this.addFieldMapping('Enum', null, null, {
                component: EnumComponent
            });
            this.addFieldMapping('Email', null, null, {
                component: EmailComponent,
                validators: {
                    email: function (id, structure, required, component) { return true; }
                }
            });
        }
    };
    /* @ngInject */ EditorFieldMappingService.prototype._cleanTemplate = function (template) {
        var index = template ? template.lastIndexOf('/') : -1;
        if (index !== -1) {
            template = template.substring(index + 1);
        }
        return template;
    };
    EditorFieldMappingService.prototype._cleanTemplate.$inject = ["template"];
    // --------------------------------------------------------------------------------------
    // Predicates
    // --------------------------------------------------------------------------------------
    /* @ngInject */ EditorFieldMappingService.prototype._exactValueMatchPredicate = function (expectedValue, actualValue) {
        return expectedValue === actualValue;
    };
    EditorFieldMappingService.prototype._exactValueMatchPredicate.$inject = ["expectedValue", "actualValue"];
    var /* @ngInject */ EditorFieldMappingService_1;
    // --------------------------------------------------------------------------------------
    // Constants
    // --------------------------------------------------------------------------------------
    /* @ngInject */ EditorFieldMappingService.WILDCARD = '*';
    /* @ngInject */ EditorFieldMappingService.MATCH = {
        NONE: 0,
        PARTIAL: 1,
        EXACT: 4 // An exact match is always better than a partial.
    };
    /* @ngInject */ EditorFieldMappingService = /* @ngInject */ EditorFieldMappingService_1 = __decorate([
        SeDowngradeService(),
        core.Injectable(),
        __metadata("design:paramtypes", [utils.LogService])
    ], /* @ngInject */ EditorFieldMappingService);
    return /* @ngInject */ EditorFieldMappingService;
}());

/* @internal  */
var /* @ngInject */ FetchEnumDataHandler = /** @class */ (function () {
    FetchEnumDataHandler.$inject = ["restServiceFactory"];
    function /* @ngInject */ FetchEnumDataHandler(restServiceFactory) {
        this.restServiceFactory = restServiceFactory;
        this.restServiceForEnum = this.restServiceFactory.get(ENUM_RESOURCE_URI);
    }
    /* @ngInject */ FetchEnumDataHandler_1 = /* @ngInject */ FetchEnumDataHandler;
    /* @ngInject */ FetchEnumDataHandler.resetForTests = function () {
        /* @ngInject */ FetchEnumDataHandler_1.cache = {};
    };
    /* @ngInject */ FetchEnumDataHandler.prototype.findByMask = function (field, search) {
        return (/* @ngInject */ FetchEnumDataHandler_1.cache[field.cmsStructureEnumType]
            ? Promise.resolve(/* @ngInject */ FetchEnumDataHandler_1.cache[field.cmsStructureEnumType])
            : Promise.resolve(this.restServiceForEnum.get({
                enumClass: field.cmsStructureEnumType
            }))).then(function (response) {
            /* @ngInject */ FetchEnumDataHandler_1.cache[field.cmsStructureEnumType] = response;
            return /* @ngInject */ FetchEnumDataHandler_1.cache[field.cmsStructureEnumType].enums.filter(function (element) {
                return utils.stringUtils.isBlank(search) ||
                    element.label.toUpperCase().indexOf(search.toUpperCase()) > -1;
            });
        });
    };
    FetchEnumDataHandler.prototype.findByMask.$inject = ["field", "search"];
    /* @ngInject */ FetchEnumDataHandler.prototype.getById = function (field, identifier) {
        return null;
    };
    FetchEnumDataHandler.prototype.getById.$inject = ["field", "identifier"];
    var /* @ngInject */ FetchEnumDataHandler_1;
    /* @ngInject */ FetchEnumDataHandler.cache = {};
    /* @ngInject */ FetchEnumDataHandler = /* @ngInject */ FetchEnumDataHandler_1 = __decorate([
        SeDowngradeService(),
        core.Injectable(),
        __metadata("design:paramtypes", [utils.RestServiceFactory])
    ], /* @ngInject */ FetchEnumDataHandler);
    return /* @ngInject */ FetchEnumDataHandler;
}());

var parseValidationMessage = function (message) {
    var expression = new RegExp('[a-zA-Z]+: ([|{)([a-zA-Z0-9]+)(]|}).?', 'g');
    var matches = message.match(expression) || [];
    return matches.reduce(function (messages, match) {
        messages.message = messages.message.replace(match, '').trim();
        var key = match.split(':')[0].trim().toLowerCase();
        var value = match.split(':')[1].match(/[a-zA-Z0-9]+/g)[0];
        messages[key] = value;
        return messages;
    }, {
        message: message
    });
};
/**
 * This service provides the functionality to parse validation messages (errors, warnings) received from the backend.
 * This service is used to parse validation messages (errors, warnings) for parameters such as language and format,
 * which are sent as part of the message itself.
 */
var /* @ngInject */ SeValidationMessageParser = /** @class */ (function () {
    function /* @ngInject */ SeValidationMessageParser() {
    }
    /**
     * Parses extra details, such as language and format, from a validation message (error, warning). These details are also
     * stripped out of the final message. This function expects the message to be in the following format:
     *
     * <pre>
     * const message = "Some validation message occurred. Language: [en]. Format: [widescreen]. SomeKey: [SomeVal]."
     * </pre>
     *
     * The resulting message object is as follows:
     * <pre>
     * {
     *     message: "Some validation message occurred."
     *     language: "en",
     *     format: "widescreen",
     *     somekey: "someval"
     * }
     * </pre>
     */
    /* @ngInject */ SeValidationMessageParser.prototype.parse = function (message) {
        return parseValidationMessage(message);
    };
    SeValidationMessageParser.prototype.parse.$inject = ["message"];
    /* @ngInject */ SeValidationMessageParser = __decorate([
        SeDowngradeService(),
        core.Injectable()
    ], /* @ngInject */ SeValidationMessageParser);
    return /* @ngInject */ SeValidationMessageParser;
}());

/**
 * The Generic Editor is a class that makes it possible for SmartEdit users (CMS managers, editors, etc.) to edit components in the SmartEdit interface.
 * The Generic Editor class is used by the `GenericEditorComponent` component.
 * The genericEditor directive makes a call either to a Structure API or, if the Structure API is not available, it reads the data from a local structure to request the information that it needs to build an HTML form.
 * It then requests the component by its type and ID from the Content API. The genericEditor directive populates the form with the data that is has received.
 * The form can now be used to edit the component. The modified data is saved using the Content API if it is provided else it would return the form data itself.
 *
 *
 * **The structure and the REST structure API</strong>.**
 *
 * The constructor of the `GenericEditorFactoryService` must be provided with the pattern of a REST Structure API, which must contain the string  ":smarteditComponentType", or with a local data structure.
 * If the pattern, Structure API, or the local structure is not provided, the Generic Editor will fail. If the Structure API is used, it must return a JSON payload that holds an array within the attributes property.
 * If the actual structure is used, it must return an array. Each entry in the array provides details about a component property to be displayed and edited. The following details are provided for each property:
 *
 * <ul>
 * <li><strong>qualifier:</strong> Name of the property.
 * <li><strong>i18nKey:</strong> Key of the property label to be translated into the requested language.
 * <li><strong>editable:</strong> Boolean that indicates if a property is editable or not. The default value is true.
 * <li><strong>localized:</strong> Boolean that indicates if a property is localized or not. The default value is false.
 * <li><strong>required:</strong> Boolean that indicates if a property is mandatory or not. The default value is false.
 * <li><strong>cmsStructureType:</strong> Value that is used to determine which form widget (property editor) to display for a specified property.
 * The selection is based on an extensible strategy mechanism owned by {@link EditorFieldMappingService}.
 * <li><strong>cmsStructureEnumType:</strong> The qualified name of the Enum class when cmsStructureType is "Enum"
 * </li>
 * <ul><br/>
 *
 * <b>Note:</b><br/>
 * The generic editor has a tabset within. This allows it to display complex types in an organized and clear way. By default, all fields are stored
 * in the default tab, and if there is only one tab the header is hidden. The selection and configuration of where each field resides is
 * controlled by the  {@link EditorFieldMappingService}. Similarly, the rendering
 * of tabs can be customized with the `GenericEditorTabService`.
 *
 *
 *
 * There are two options when you use the Structure API. The first option is to use an API resource that returns the structure object.
 * The following is an example of the JSON payload that is returned by the Structure API in this case:
 *
 *      {
 *          attributes: [{
 *              cmsStructureType: "ShortString",
 *              qualifier: "someQualifier1",
 *              i18nKey: 'i18nkeyForsomeQualifier1',
 *              localized: false
 *          }, {
 *              cmsStructureType: "LongString",
 *              qualifier: "someQualifier2",
 *              i18nKey: 'i18nkeyForsomeQualifier2',
 *              localized: false
 *          }, {
 *              cmsStructureType: "RichText",
 *              qualifier: "someQualifier3",
 *              i18nKey: 'i18nkeyForsomeQualifier3',
 *              localized: true,
 *              required: true
 *          }, {
 *              cmsStructureType: "Boolean",
 *              qualifier: "someQualifier4",
 *              i18nKey: 'i18nkeyForsomeQualifier4',
 *              localized: false
 *          }, {
 *              cmsStructureType: "DateTime",
 *              qualifier: "someQualifier5",
 *              i18nKey: 'i18nkeyForsomeQualifier5',
 *              localized: false
 *          }, {
 *              cmsStructureType: "Media",
 *              qualifier: "someQualifier6",
 *              i18nKey: 'i18nkeyForsomeQualifier6',
 *              localized: true,
 *              required: true
 *          }, {
 *              cmsStructureType: "Enum",
 *              cmsStructureEnumType:'de.mypackage.Orientation'
 *              qualifier: "someQualifier7",
 *              i18nKey: 'i18nkeyForsomeQualifier7',
 *              localized: true,
 *              required: true
 *          }]
 *      }
 *
 *
 * The second option is to use an API resource that returns a list of structures. In this case, the generic editor will select the first element from the list and use it to display its attributes.
 * The generic editor expects the structures to be in one of the two fields below.
 *
 *      {
 *          structures: [{}, {}]
 *      }
 *
 *
 * or
 *
 *      {
 *          componentTypes: [{}, {}]
 *      }
 *
 *
 * If the list has more than one element, the Generic Editor will throw an exception, otherwise it will get the first element on the list.
 * The following is an example of the JSON payload that is returned by the Structure API in this case:
 *
 *      {
 *          structures: [
 *              {
 *                  attributes: [{
 *                 	    cmsStructureType: "ShortString",
 *                 		qualifier: "someQualifier1",
 *                 		i18nKey: 'i18nkeyForsomeQualifier1',
 *                 		localized: false
 *             		}, {
 *                 		cmsStructureType: "LongString",
 *                 		qualifier: "someQualifier2",
 *                 		i18nKey: 'i18nkeyForsomeQualifier2',
 *                 		localized: false
 *         	   		}]
 *              }
 *          ]
 *      }
 *
 *
 *      {
 *          componentTypes: [
 *              {
 *                  attributes: [{
 *                 	    cmsStructureType: "ShortString",
 *                 		qualifier: "someQualifier1",
 *                 		i18nKey: 'i18nkeyForsomeQualifier1',
 *                 		localized: false
 *             		}, {
 *                 		cmsStructureType: "LongString",
 *                 		qualifier: "someQualifier2",
 *                 		i18nKey: 'i18nkeyForsomeQualifier2',
 *                 		localized: false
 *         	   		}]
 *              }
 *          ]
 *      }
 *
 *
 * The following is an example of the expected format of a structure:
 *
 *
 *      [{
 *          cmsStructureType: "ShortString",
 *          qualifier: "someQualifier1",
 *          i18nKey: 'i18nkeyForsomeQualifier1',
 *          localized: false
 *      }, {
 *          cmsStructureType: "LongString",
 *          qualifier: "someQualifier2",
 *          i18nKey: 'i18nkeyForsomeQualifier2',
 *          editable: false,
 *          localized: false
 *      }, {
 *          cmsStructureType: "RichText",
 *          qualifier: "someQualifier3",
 *          i18nKey: 'i18nkeyForsomeQualifier3',
 *          localized: true,
 *          required: true
 *      }, {
 *          cmsStructureType: "Boolean",
 *          qualifier: "someQualifier4",
 *          i18nKey: 'i18nkeyForsomeQualifier4',
 *          localized: false
 *      }, {
 *          cmsStructureType: "DateTime",
 *          qualifier: "someQualifier5",
 *          i18nKey: 'i18nkeyForsomeQualifier5',
 *          editable: false,
 *          localized: false
 *      }, {
 *          cmsStructureType: "Media",
 *          qualifier: "someQualifier6",
 *          i18nKey: 'i18nkeyForsomeQualifier6',
 *          localized: true,
 *          required: true
 *      }, {
 *          cmsStructureType: "Enum",
 *          cmsStructureEnumType:'de.mypackage.Orientation'
 *          qualifier: "someQualifier7",
 *          i18nKey: 'i18nkeyForsomeQualifier7',
 *          localized: true,
 *          required: true
 *      }]
 *
 * <strong>The REST CRUD API</strong>, is given to the constructor of `GenericEditorFactoryService`.
 * The CRUD API must support GET and PUT of JSON payloads.
 * The PUT method must return the updated payload in its response. Specific to the GET and PUT, the payload must fulfill the following requirements:
 * <ul>
 * 	<li>DateTime types: Must be serialized as long timestamps.</li>
 * 	<li>Media types: Must be serialized as identifier strings.</li>
 * 	<li>If a cmsStructureType is localized, then we expect that the CRUD API returns a map containing the type (string or map) and the map of values, where the key is the language and the value is the content that the type returns.</li>
 * </ul>
 *
 * The following is an example of a localized payload:
 *
 *      {
 *          content: {
 * 		        'en': 'content in english',
 * 		        'fr': 'content in french',
 * 		        'hi': 'content in hindi'
 * 	    }
 *
 *
 *
 *
 * If a validation warning or error occurs, the PUT method of the REST CRUD API will return a validation warning/error object that contains an array of validation messages. The information returned for each validation message is as follows:
 * <ul>
 * 	<li><strong>subject:</strong> The qualifier that has the error</li>
 * 	<li><strong>message:</strong> The error message to be displayed</li>
 * 	<li><strong>type:</strong> The type of message returned. This is of the type ValidationError or Warning.</li>
 * 	<li><strong>language:</strong> The language the error needs to be associated with. If no language property is provided, a match with regular expression /(Language: \[)[a-z]{2}\]/g is attempted from the message property. As a fallback, it implies that the field is not localized.</li>
 * </ul>
 *
 * The following code is an example of an error response object:
 *
 *      {
 *          errors: [{
 *              subject: 'qualifier1',
 *              message: 'error message for qualifier',
 *              type: 'ValidationError'
 *          }, {
 *              subject: 'qualifier2',
 *              message: 'error message for qualifier2 language: [fr]',
 *              type: 'ValidationError'
 *          }, {
 *              subject: 'qualifier3',
 *              message: 'error message for qualifier2',
 *              type: 'ValidationError'
 *          }, {
 *              subject: 'qualifier4',
 *              message: 'warning message for qualifier4',
 *              type: 'Warning'
 *          }]
 *      }
 *
 *
 * Whenever any sort of dropdown is used in one of the cmsStructureType widgets, it is advised using {@link GenericEditorFactoryService#refreshOptions}. See this method documentation to learn more.
 *
 */
/* @internal */
var /* @ngInject */ GenericEditorFactoryService = /** @class */ (function () {
    GenericEditorFactoryService.$inject = ["yjQuery", "restServiceFactory", "languageService", "sharedDataService", "systemEventService", "logService", "upgrade", "seValidationMessageParser", "editorFieldMappingService"];
    function /* @ngInject */ GenericEditorFactoryService(yjQuery, restServiceFactory, languageService, sharedDataService, systemEventService, logService, upgrade, seValidationMessageParser, editorFieldMappingService) {
        editorFieldMappingService._registerDefaultFieldMappings();
        this.genericEditorConstructor = /** @class */ (function () {
            function class_1(conf) {
                var _this = this;
                this.schema$ = new rxjs.BehaviorSubject(null);
                this.data$ = new rxjs.BehaviorSubject(null);
                this.submitButtonText = 'se.componentform.actions.submit';
                this.cancelButtonText = 'se.componentform.actions.cancel';
                this.api = createApi(this);
                this.onSubmit = function (payload) {
                    if (_this.smarteditComponentId) {
                        payload.identifier = _this.smarteditComponentId;
                    }
                    // if POST mode
                    if (_this.editorCRUDService && !_this.smarteditComponentId) {
                        // if we have a type field in the structure, use it for the type in the POST payload
                        if (_this.structure && _this.structure.type) {
                            // if the user already provided a type field, lets be nice
                            if (!payload.type) {
                                payload.type = _this.structure.type;
                            }
                        }
                    }
                    return _this.preparePayload(payload).then(function (preparedPayload) {
                        var promise = _this.editorCRUDService
                            ? _this.smarteditComponentId
                                ? _this.editorCRUDService.update(preparedPayload)
                                : _this.editorCRUDService.save(preparedPayload)
                            : Promise.resolve(preparedPayload);
                        return promise.then(function (response) {
                            return {
                                payload: payload,
                                response: response
                            };
                        });
                    });
                };
                this.submit$ = function () { return rxjs.from(_this.submit(_this.form.component)); };
                this.onSuccess = function (submitResult) {
                    // If we're doing a POST or PUT and the request returns non empty response, then this response is returned.
                    // Otherwise the payload for the request is returned.
                    var pristine;
                    if (submitResult.response) {
                        pristine = objectUtils.copy(submitResult.response);
                    }
                    else {
                        pristine = objectUtils.copy(submitResult.payload);
                    }
                    delete pristine.identifier;
                    if (!_this.smarteditComponentId && submitResult.response) {
                        _this.smarteditComponentId = submitResult.response.uuid;
                    }
                    _this.form && _this.form.removeValidationMessages();
                    _this.inProgress = false;
                    if (_this.updateCallback) {
                        // should onSuccess = updateCallback ?
                        _this.updateCallback(pristine, submitResult.response);
                    }
                };
                this.onFailure = function (failure) {
                    _this.form.removeValidationMessages();
                    var errors = failure.error ? failure.error.errors : [];
                    _this.form.displayValidationMessages(errors, true);
                    // send unrelated validation messages to any other listening genericEditor when no other errors
                    var unrelatedValidationMessages = _this.form.collectUnrelatedValidationMessages(errors);
                    if (unrelatedValidationMessages.length > 0) {
                        // send tab id in errors for the legacy event.
                        systemEventService.publishAsync(GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, {
                            messages: unrelatedValidationMessages,
                            sourceGenericEditorId: _this.id
                        });
                    }
                    _this.inProgress = false;
                };
                this.isSubmitDisabled = function () {
                    if (_this.inProgress) {
                        return true;
                    }
                    else if (!_this.isDirty() || !_this.isValid()) {
                        return !_this.alwaysEnableSubmit;
                    }
                    else {
                        return false;
                    }
                };
                this._validate(conf);
                this.id = conf.id;
                this.inProgress = false;
                this.smarteditComponentType = conf.smarteditComponentType;
                this.smarteditComponentId = conf.smarteditComponentId;
                this.editorStackId = conf.editorStackId || this.id;
                this.updateCallback = conf.updateCallback;
                this.structure = conf.structure;
                this.onChangeEvents = [];
                if (conf.structureApi) {
                    this.editorStructureService = restServiceFactory.get(conf.structureApi);
                }
                this.uriContext = conf.uriContext;
                if (conf.contentApi) {
                    this.editorCRUDService = restServiceFactory.get(conf.contentApi);
                }
                this.initialContent = lodash.cloneDeep(conf.content);
                this.initialDirty = false;
                if (conf.customOnSubmit) {
                    this.onSubmit = conf.customOnSubmit;
                }
                this._unregisterUnrelatedMessagesEvent = systemEventService.subscribe(GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT, this._handleUnrelatedValidationMessages.bind(this));
                this.element = conf.element;
            }
            Object.defineProperty(class_1.prototype, "pristine", {
                get: function () {
                    return this.form ? this.form.pristine : undefined;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(class_1.prototype, "nativeForm", {
                get: function () {
                    return this.element.querySelector('form');
                },
                enumerable: false,
                configurable: true
            });
            class_1.prototype.setForm = function (state) {
                var _this = this;
                this.form = state;
                this.form.group.valueChanges.subscribe(function () {
                    _this.api.triggerContentChangeEvents();
                });
            };
            class_1.prototype._finalize = function () {
                this._unregisterUnrelatedMessagesEvent();
                this.popEditorFromStack();
            };
            class_1.prototype.popEditorFromStack = function () {
                if (!this.editorStackId) {
                    return;
                }
                systemEventService.publishAsync(GenericEditorStackService.EDITOR_POP_FROM_STACK_EVENT, {
                    editorStackId: this.editorStackId
                });
            };
            /**
             * Sets the content within the editor to its original state.
             */
            class_1.prototype.reset = function (pristine) {
                var _this = this;
                this.form && this.form.removeValidationMessages();
                var structurePromise = this.editorStructureService
                    ? this.editorStructureService.get({
                        smarteditComponentType: this.smarteditComponentType
                    })
                    : Promise.resolve(this.structure);
                return this._getUriContext()
                    .then(function (uriContext) {
                    return Promise.all([
                        _this.api.getLanguages() ||
                            languageService.getLanguagesForSite(uriContext[CONTEXT_SITE_ID]),
                        structurePromise.then(function (structure) {
                            return _this._convertStructureArray(structure);
                        }),
                        Promise.resolve(uriContext)
                    ]);
                })
                    .then(function (_a) {
                    var languages = _a[0], structure = _a[1], uriContext = _a[2];
                    var schema = {
                        id: _this.id,
                        languages: languages,
                        structure: structure,
                        uriContext: uriContext,
                        smarteditComponentType: _this.smarteditComponentType,
                        targetedQualifier: _this.targetedQualifier
                    };
                    _this.schema$.next(schema);
                    _this.data$.next(pristine ? pristine : _this.pristine);
                    return;
                });
            };
            /**
             *  fetch will:
             *  - return data if initialContent is provided
             *  - make a call to the CRUD API to return the payload if initialContent is not provided
             *
             *  (In initialDirty is set to true, it is populated after loading and setting the content which will make the
             *   pristine and component states out of sync thus making the editor dirty)
             */
            class_1.prototype.fetch = function () {
                if (!this.initialDirty) {
                    return this.initialContent
                        ? Promise.resolve(this.initialContent)
                        : this.smarteditComponentId
                            ? this.editorCRUDService
                                .getById(this.smarteditComponentId)
                                .then(function (response) { return response || {}; })
                            : Promise.resolve({});
                }
                return Promise.resolve({});
            };
            class_1.prototype.load = function () {
                var _this = this;
                return this.fetch().then(function (pristine) { return _this.reset(pristine); }, function (failure) {
                    logService.error('GenericEditor.load failed');
                    logService.error(failure);
                });
            };
            class_1.prototype.getComponent = function () {
                return (this.form && this.form.component) || null;
            };
            /**
             * Transforms the payload before POST/PUT to server
             *
             * @param originalPayload the transformed payload
             */
            class_1.prototype.preparePayload = function (originalPayload) {
                return Promise.resolve(this.form.sanitizedPayload(originalPayload));
            };
            /**
             * Saves the content within the form for a specified component. If there are any validation errors returned by the CRUD API after saving the content, it will display the errors.
             */
            class_1.prototype.submit = function (newContent) {
                // It's necessary to remove validation errors even if the form is not dirty. This might be because of unrelated validation errors
                // triggered in other tab.
                this.form.removeValidationMessages();
                this.hasFrontEndValidationErrors = false;
                if (!this.form.fieldsAreUserChecked()) {
                    this.hasFrontEndValidationErrors = true;
                    // Mark this tab as "in error" due to front-end validation.
                    return Promise.reject(true);
                }
                else if (this.isValid(true)) {
                    this.inProgress = true;
                    /*
                     * upon submitting, server side may have been updated,
                     * since we PUT and not PATCH, we need to take latest of the fields not presented and send them back with the editable ones
                     */
                    return this.onSubmit(newContent);
                }
                else {
                    logService.warn('GenericEditor.submit() - unable to submit form. Form is unexpectedly invalid.');
                    return Promise.reject({});
                }
            };
            /**
             * Is invoked by HTML field templates that update and manage dropdowns.
             * It updates the dropdown list upon initialization (creates a list of one option) and when performing a search (returns a filtered list).
             * To do this, the GenericEditor fetches an implementation of the `FetchDataHandlerInterface` using the following naming convention:
             * <pre>"fetch" + cmsStructureType + "DataHandler"</pre>
             * @param field The field in the structure that requires a dropdown to be built.
             * @param qualifier For a non-localized field, it is the actual field.qualifier. For a localized field, it is the ISO code of the language.
             * @param search The value of the mask to filter the dropdown entries on.
             */
            class_1.prototype.refreshOptions = function (field, qualifier, search) {
                var _this = this;
                return new Promise(function (resolve) {
                    var ctorOrToken = _this._getRefreshHandleContructorOrToken(field.cmsStructureType);
                    var objHandler = _this._getDataHandler(ctorOrToken);
                    var theIdentifier;
                    var optionsIdentifier;
                    if (field.localized) {
                        theIdentifier = _this.form.component[field.qualifier][qualifier];
                        optionsIdentifier = qualifier;
                    }
                    else {
                        theIdentifier = _this.form.component[field.qualifier];
                        optionsIdentifier = field.qualifier;
                    }
                    field.initiated = field.initiated || [];
                    field.options = field.options || {};
                    if (field.cmsStructureType === 'Enum') {
                        field.initiated.push(optionsIdentifier);
                    }
                    if (field.initiated.indexOf(optionsIdentifier) > -1) {
                        if (search.length > 2 || field.cmsStructureType === 'Enum') {
                            return objHandler
                                .findByMask(field, search)
                                .then(function (entities) {
                                field.options[optionsIdentifier] = entities;
                                resolve();
                            });
                        }
                    }
                    else if (theIdentifier) {
                        return objHandler.getById(field, theIdentifier).then(function (entity) {
                            field.options[optionsIdentifier] = [entity];
                            field.initiated.push(optionsIdentifier);
                            resolve();
                        });
                    }
                    else {
                        field.initiated.push(optionsIdentifier);
                    }
                    return resolve();
                });
            };
            /**
             * A predicate function that returns true if the editor is in dirty state or false if it not.
             * The state of the editor is determined by comparing the current state of the component with the state of the component when it was pristine.
             *
             * @returns An indicator if the editor is in dirty state or not.
             */
            class_1.prototype.isDirty = function (qualifier, language) {
                return (this.initialDirty ||
                    (this.form ? this.form.isDirty(qualifier, language) : false));
            };
            /**
             * Check for html validation errors on all the form fields.
             * If so, assign an error to a field that is not pristine.
             * The seGenericEditorFieldError will render these errors, just like
             * errors we receive from the backend.
             * It also validates error states for tabs.
             */
            class_1.prototype.isValid = function (comesFromSubmit) {
                if (comesFromSubmit === void 0) { comesFromSubmit = false; }
                if (comesFromSubmit) {
                    var validationErrors = this.form.collectFrontEndValidationErrors(comesFromSubmit, this.nativeForm);
                    this.form.removeFrontEndValidationMessages();
                    this.form.displayValidationMessages(validationErrors, comesFromSubmit);
                }
                return !!this.form && this.form.group.valid;
            };
            class_1.prototype.watchFormErrors = function (el) {
                this.form.watchErrors(el);
            };
            class_1.prototype.init = function () {
                var _this = this;
                return this.load().then(function () {
                    // If initialDirty is set to true and if any initial content is provided, it is populated here which will make the
                    // pristine and component states out of sync thus making the editor dirty
                    if (_this.initialDirty) {
                        _this.form.patchComponent(_this.initialContent || {});
                        _this.data$.next(_this.initialContent || {});
                    }
                    _this._pushEditorToStack();
                    systemEventService.publishAsync(GENERIC_EDITOR_LOADED_EVENT, _this.id);
                });
            };
            /* @internal */
            class_1.prototype._validate = function (conf) {
                if (stringUtils.isBlank(conf.structureApi) && !conf.structure) {
                    throw new Error('genericEditor.configuration.error.no.structure');
                }
                else if (!stringUtils.isBlank(conf.structureApi) && conf.structure) {
                    throw new Error('genericEditor.configuration.error.2.structures');
                }
            };
            /* @internal */
            class_1.prototype._getUriContext = function () {
                return Promise.resolve(this.uriContext
                    ? this.uriContext
                    : sharedDataService.get(EXPERIENCE_STORAGE_KEY).then(function (experience) {
                        var _a;
                        return (_a = {},
                            _a[CONTEXT_SITE_ID] = experience.siteDescriptor.uid,
                            _a[CONTEXT_CATALOG] = experience.catalogDescriptor.catalogId,
                            _a[CONTEXT_CATALOG_VERSION] = experience.catalogDescriptor.catalogVersion,
                            _a);
                    }));
            };
            /**
             * @internal
             * Conversion function in case the first attribute of the response is an array of type structures.
             */
            class_1.prototype._convertStructureArray = function (structure) {
                var structureArray = structure.structures || structure.componentTypes;
                if (lodash.isArray(structureArray)) {
                    if (structureArray.length > 1) {
                        throw new Error('init: Invalid structure, multiple structures returned');
                    }
                    structure = structureArray[0];
                }
                return structure;
            };
            /* @internal */
            class_1.prototype._handleUnrelatedValidationMessages = function (key, validationData) {
                if (validationData.targetGenericEditorId &&
                    validationData.targetGenericEditorId !== this.id) {
                    return;
                }
                if (validationData.sourceGenericEditorId &&
                    validationData.sourceGenericEditorId === this.id) {
                    return;
                }
                this.form.removeValidationMessages();
                this.form.displayValidationMessages(validationData.messages, true);
            };
            /* @internal */
            class_1.prototype._getDataHandler = function (ctorOrToken) {
                if (upgrade.injector.get(ctorOrToken, null)) {
                    return upgrade.injector.get(ctorOrToken);
                }
                if (upgrade.$injector.has(ctorOrToken)) {
                    return upgrade.$injector.get(ctorOrToken);
                }
                return null;
            };
            /* @internal */
            class_1.prototype._getRefreshHandleContructorOrToken = function (type) {
                switch (type) {
                    case 'Enum':
                        return FetchEnumDataHandler;
                    default:
                        return 'fetch' + type + 'DataHandler';
                }
            };
            /* @internal */
            class_1.prototype._pushEditorToStack = function () {
                systemEventService.publishAsync(GenericEditorStackService.EDITOR_PUSH_TO_STACK_EVENT, {
                    editorId: this.id,
                    editorStackId: this.editorStackId,
                    component: this.form.component,
                    componentType: this.smarteditComponentType
                });
            };
            return class_1;
        }());
    }
    /* @ngInject */ GenericEditorFactoryService.prototype.getGenericEditorConstructor = function () {
        return this.genericEditorConstructor;
    };
    /* @ngInject */ GenericEditorFactoryService = __decorate([
        SeDowngradeService(),
        __param(0, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [Function, utils.RestServiceFactory,
            LanguageService,
            utils.ISharedDataService,
            SystemEventService,
            utils.LogService,
            _static.UpgradeModule,
            SeValidationMessageParser,
            EditorFieldMappingService])
    ], /* @ngInject */ GenericEditorFactoryService);
    return /* @ngInject */ GenericEditorFactoryService;
}());

var changeTriggeringInputs = new Set([
    'id',
    'smarteditComponentId',
    'smarteditComponentType',
    'structureApi',
    'structure',
    'contentApi',
    'content',
    'uriContext',
    'updateCallback',
    'customOnSubmit',
    'editorStackId',
    'modalHeaderTitle'
]);
window.__smartedit__.addDecoratorPayload("Component", "GenericEditorComponent", {
    selector: 'se-generic-editor',
    template: "<ng-template let-state [formBuilder]=\"{schema$: editor.schema$, data$: editor.data$}\" (stateCreated)=\"setFormState($event)\"><div class=\"se-generic-editor\"><se-generic-editor-breadcrumb></se-generic-editor-breadcrumb><ng-container *ngIf=\"state; else noSupport\"><form novalidate #nativeForm class=\"no-enter-submit se-generic-editor__form\" [contentManager]=\"{onSave: editor.submit$}\" (onSuccess)=\"editor.onSuccess($event)\" (onError)=\"editor.onFailure($event)\"><div class=\"modal-header se-generic-editor__header\" *ngIf=\"modalHeaderTitle\"><h4 class=\"modal-title\">{{modalHeaderTitle| translate}}</h4></div><div class=\"se-generic-editor__body\"><ng-template [formRenderer]=\"state.group\"></ng-template></div><div class=\"se-generic-editor__footer modal-footer\" *ngIf=\"editor && showCommands()\"><button fd-button id=\"cancel\" type=\"button\" options=\"light\" *ngIf=\"showCancel()\" (click)=\"_reset()\">{{editor.cancelButtonText | translate}}</button> <button fd-button id=\"submit\" name=\"submit\" options=\"emphasized\" *ngIf=\"showSubmit()\" [seSubmitBtn]=\"editor.isSubmitDisabled\">{{editor.submitButtonText | translate}}</button></div></form></ng-container><ng-template #noSupport><div class=\"se-generic-editor__body\"><se-message type=\"info\" id=\"GenericEditor.NoEditingSupportDisclaimer\"><ng-container se-message-description>{{ 'se.editor.notification.editing.not.supported' | translate }}</ng-container></se-message></div></ng-template></div></ng-template>"
});
var /* @ngInject */ GenericEditorComponent$1 = /** @class */ (function () {
    GenericEditorComponent.$inject = ["elementRef", "genericEditorFactoryService", "yjQuery"];
    function /* @ngInject */ GenericEditorComponent(elementRef, genericEditorFactoryService, yjQuery) {
        var _this = this;
        this.elementRef = elementRef;
        this.genericEditorFactoryService = genericEditorFactoryService;
        this.yjQuery = yjQuery;
        this.submit = null;
        this.reset = null;
        this.isDirty = null;
        this.isValid = null;
        this.getApi = new core.EventEmitter();
        this.submitChange = new core.EventEmitter();
        this.resetChange = new core.EventEmitter();
        this.isValidChange = new core.EventEmitter();
        this.isDirtyChange = new core.EventEmitter();
        this.editor = null;
        this.componentForm = new forms.FormGroup({});
        this.formInitialized$ = new rxjs.BehaviorSubject(null);
        this.formSet$ = new rxjs.BehaviorSubject(false);
        this.isSubmitDisabled = function () { return _this.editor.isSubmitDisabled(); };
    }
    Object.defineProperty(/* @ngInject */ GenericEditorComponent.prototype, "nativeForm", {
        set: function (element) {
            if (!element) {
                return;
            }
            this.formInitialized$.next(element.nativeElement);
        },
        enumerable: false,
        configurable: true
    });
    /* @ngInject */ GenericEditorComponent.prototype.ngOnChanges = function (changes) {
        var hasRelevantChange = !!Object.keys(changes).find(function (key) {
            return changeTriggeringInputs.has(key);
        });
        if (!hasRelevantChange) {
            return;
        }
        if (this.editor) {
            this.editor._finalize();
        }
        var genericEditorConstructor = this.genericEditorFactoryService.getGenericEditorConstructor();
        this.editor = new genericEditorConstructor({
            id: this.id || stringUtils.generateIdentifier(),
            smarteditComponentType: this.smarteditComponentType,
            smarteditComponentId: this.smarteditComponentId,
            editorStackId: this.editorStackId,
            structureApi: this.structureApi,
            structure: this.structure,
            contentApi: this.contentApi,
            updateCallback: this.updateCallback,
            content: this.content,
            uriContext: this.uriContext,
            customOnSubmit: this.customOnSubmit,
            element: this.elementRef.nativeElement
        });
        this.getApi.emit(this.editor.api);
        this.editor.init();
    };
    GenericEditorComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ GenericEditorComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.showResetButton = lodash.isNull(this.reset);
        this.showSubmitButton = lodash.isNull(this.submit);
        setTimeout(function () {
            _this.submitChange.emit(function () {
                return _this.contentManager
                    .save()
                    .toPromise()
                    .then(function (result) { return result.response; });
            });
            _this.isValidChange.emit(function () { return _this._isValid(); });
            _this.isDirtyChange.emit(function () { return _this._isDirty(); });
            _this.resetChange.emit(function () { return _this._reset(); });
        });
        rxjs.combineLatest(this.formSet$, this.formInitialized$)
            .pipe(operators.filter(function (values) { return values.every(function (value) { return !!value; }); }), operators.take(1))
            .subscribe(function (_a) {
            var _ = _a[0], el = _a[1];
            return _this.editor.watchFormErrors(el);
        });
    };
    /* @ngInject */ GenericEditorComponent.prototype.ngOnDestroy = function () {
        this.editor._finalize();
    };
    /* @ngInject */ GenericEditorComponent.prototype.ngAfterViewInit = function () {
        this.yjQuery(this.yjQuery('.no-enter-submit')[0]).bind('keypress', function (key) { return key.key !== 'Enter'; });
    };
    /* @ngInject */ GenericEditorComponent.prototype.setFormState = function (state) {
        this.editor.setForm(state);
        this.formSet$.next(true);
    };
    GenericEditorComponent.prototype.setFormState.$inject = ["state"];
    /* @ngInject */ GenericEditorComponent.prototype.showCommands = function () {
        return this.showCancel() || this.showSubmit();
    };
    /* @ngInject */ GenericEditorComponent.prototype.showCancel = function () {
        return (this.editor.alwaysShowReset ||
            (this.showResetButton === true && this.editor.isDirty() && this.editor.isValid()));
    };
    /* @ngInject */ GenericEditorComponent.prototype.showSubmit = function () {
        return (this.editor.alwaysShowSubmit ||
            (this.showSubmitButton === true && this.editor.isDirty() && this.editor.isValid()));
    };
    /* @ngInject */ GenericEditorComponent.prototype._reset = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.editor.onReset && this.editor.onReset() === false) {
                    return [2 /*return*/];
                }
                return [2 /*return*/, this.editor.reset()];
            });
        });
    };
    /* @ngInject */ GenericEditorComponent.prototype._isValid = function () {
        return this.editor.isValid();
    };
    /* @ngInject */ GenericEditorComponent.prototype._isDirty = function () {
        return this.editor ? this.editor.isDirty() : false;
    };
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "id", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "smarteditComponentId", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "smarteditComponentType", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "structureApi", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorComponent.prototype, "structure", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "contentApi", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorComponent.prototype, "content", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Promise)
    ], /* @ngInject */ GenericEditorComponent.prototype, "uriContext", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "submit", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "reset", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "isDirty", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "isValid", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "updateCallback", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Function)
    ], /* @ngInject */ GenericEditorComponent.prototype, "customOnSubmit", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "editorStackId", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorComponent.prototype, "modalHeaderTitle", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ GenericEditorComponent.prototype, "getApi", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ GenericEditorComponent.prototype, "submitChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ GenericEditorComponent.prototype, "resetChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ GenericEditorComponent.prototype, "isValidChange", void 0);
    __decorate([
        core.Output(),
        __metadata("design:type", core.EventEmitter)
    ], /* @ngInject */ GenericEditorComponent.prototype, "isDirtyChange", void 0);
    __decorate([
        core.ViewChild('nativeForm', { static: false, read: core.ElementRef }),
        __metadata("design:type", core.ElementRef),
        __metadata("design:paramtypes", [core.ElementRef])
    ], /* @ngInject */ GenericEditorComponent.prototype, "nativeForm", null);
    __decorate([
        core.ViewChild(ContentManager, { static: false }),
        __metadata("design:type", ContentManager)
    ], /* @ngInject */ GenericEditorComponent.prototype, "contentManager", void 0);
    /* @ngInject */ GenericEditorComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-generic-editor',
            template: "<ng-template let-state [formBuilder]=\"{schema$: editor.schema$, data$: editor.data$}\" (stateCreated)=\"setFormState($event)\"><div class=\"se-generic-editor\"><se-generic-editor-breadcrumb></se-generic-editor-breadcrumb><ng-container *ngIf=\"state; else noSupport\"><form novalidate #nativeForm class=\"no-enter-submit se-generic-editor__form\" [contentManager]=\"{onSave: editor.submit$}\" (onSuccess)=\"editor.onSuccess($event)\" (onError)=\"editor.onFailure($event)\"><div class=\"modal-header se-generic-editor__header\" *ngIf=\"modalHeaderTitle\"><h4 class=\"modal-title\">{{modalHeaderTitle| translate}}</h4></div><div class=\"se-generic-editor__body\"><ng-template [formRenderer]=\"state.group\"></ng-template></div><div class=\"se-generic-editor__footer modal-footer\" *ngIf=\"editor && showCommands()\"><button fd-button id=\"cancel\" type=\"button\" options=\"light\" *ngIf=\"showCancel()\" (click)=\"_reset()\">{{editor.cancelButtonText | translate}}</button> <button fd-button id=\"submit\" name=\"submit\" options=\"emphasized\" *ngIf=\"showSubmit()\" [seSubmitBtn]=\"editor.isSubmitDisabled\">{{editor.submitButtonText | translate}}</button></div></form></ng-container><ng-template #noSupport><div class=\"se-generic-editor__body\"><se-message type=\"info\" id=\"GenericEditor.NoEditingSupportDisclaimer\"><ng-container se-message-description>{{ 'se.editor.notification.editing.not.supported' | translate }}</ng-container></se-message></div></ng-template></div></ng-template>"
        }),
        __param(2, core.Inject(YJQUERY_TOKEN)),
        __metadata("design:paramtypes", [core.ElementRef,
            GenericEditorFactoryService, Function])
    ], /* @ngInject */ GenericEditorComponent);
    return /* @ngInject */ GenericEditorComponent;
}());

/**
 * The genericEditorTabService is used to configure the way in which the tabs in the
 * {@link GenericEditorComponent} component are rendered.
 */
var /* @ngInject */ GenericEditorTabService = /** @class */ (function () {
    function /* @ngInject */ GenericEditorTabService() {
        // --------------------------------------------------------------------------------------
        // Variables
        // --------------------------------------------------------------------------------------
        this._tabsConfiguration = {};
        this._defaultTabPredicates = [];
    }
    /* @ngInject */ GenericEditorTabService_1 = /* @ngInject */ GenericEditorTabService;
    // --------------------------------------------------------------------------------------
    // Public Methods
    // --------------------------------------------------------------------------------------
    /**
     * This method stores the configuration of the tab identified by the provided ID.
     *
     * @param tabId The ID of the tab to configure.
     * @param tabConfiguration The object containing the configuration of the tab.
     * @param tabConfiguration.priority The priority of the tab. Higher numbers represent higher priority. This property is used to
     * sort tabs.
     *
     */
    /* @ngInject */ GenericEditorTabService.prototype.configureTab = function (tabId, tabConfiguration) {
        this._tabsConfiguration[tabId] = tabConfiguration;
    };
    GenericEditorTabService.prototype.configureTab.$inject = ["tabId", "tabConfiguration"];
    /**
     * This method retrieves the configuration of a tab.
     *
     * @param tabId The ID of the tab for which to retrieve its configuration.
     * @returns The configuration of the tab. Can be null if no tab with the provided ID has been configured.
     *
     */
    /* @ngInject */ GenericEditorTabService.prototype.getTabConfiguration = function (tabId) {
        var result = this._tabsConfiguration[tabId];
        return result ? result : null;
    };
    GenericEditorTabService.prototype.getTabConfiguration.$inject = ["tabId"];
    /**
     * This method sorts in place the list of tabs provided. Sorting starts with tab priority. If two or more tabs have the same priority they
     * will be sorted alphabetically by ID.
     *
     * @param tabsToSort The list of tabs to sort.
     */
    /* @ngInject */ GenericEditorTabService.prototype.sortTabs = function (tabsToSort) {
        var _this = this;
        return tabsToSort.sort(function (tab1, tab2) {
            var tab1Priority = _this.getTabPriority(tab1);
            var tab2Priority = _this.getTabPriority(tab2);
            if (tab2Priority - tab1Priority !== 0) {
                return tab2Priority - tab1Priority; // Sort descending priority
            }
            else {
                // Sort alphabetically
                if (tab1.id < tab2.id) {
                    return -1;
                }
                else if (tab1.id > tab2.id) {
                    return 1;
                }
                return 0;
            }
        });
    };
    GenericEditorTabService.prototype.sortTabs.$inject = ["tabsToSort"];
    // Meant to be used internally. No ng-doc.
    /* @ngInject */ GenericEditorTabService.prototype.getComponentTypeDefaultTab = function (componentTypeStructure) {
        var result = null;
        this._defaultTabPredicates.some(function (predicate) {
            result = predicate(componentTypeStructure);
            return result !== null;
        });
        return result !== null ? result : /* @ngInject */ GenericEditorTabService_1.DEFAULT_TAB_ID;
    };
    GenericEditorTabService.prototype.getComponentTypeDefaultTab.$inject = ["componentTypeStructure"];
    // Meant to be used internally. No ng-doc.
    /* @ngInject */ GenericEditorTabService.prototype.addComponentTypeDefaultTabPredicate = function (predicate) {
        if (!predicate || typeof predicate !== 'function') {
            throw new Error('genericEditorTabService - provided predicate must be a function.');
        }
        this._defaultTabPredicates.push(predicate);
    };
    GenericEditorTabService.prototype.addComponentTypeDefaultTabPredicate.$inject = ["predicate"];
    // --------------------------------------------------------------------------------------
    // Helper Methods
    // --------------------------------------------------------------------------------------
    /* @ngInject */ GenericEditorTabService.prototype.getTabPriority = function (tab) {
        var tabId = tab.id;
        if (!tabId) {
            throw new Error('genericEditorTabService - Every tab must have an id.');
        }
        var tabPriority = /* @ngInject */ GenericEditorTabService_1.MIN_PRIORITY;
        if (this._tabsConfiguration[tabId] && this._tabsConfiguration[tabId].priority) {
            tabPriority = this._tabsConfiguration[tabId].priority;
        }
        return tabPriority;
    };
    GenericEditorTabService.prototype.getTabPriority.$inject = ["tab"];
    var /* @ngInject */ GenericEditorTabService_1;
    // --------------------------------------------------------------------------------------
    // Constants
    // --------------------------------------------------------------------------------------
    /* @ngInject */ GenericEditorTabService.MIN_PRIORITY = 0;
    /* @ngInject */ GenericEditorTabService.DEFAULT_TAB_ID = 'default';
    /* @ngInject */ GenericEditorTabService = /* @ngInject */ GenericEditorTabService_1 = __decorate([
        SeDowngradeService(),
        core.Injectable()
    ], /* @ngInject */ GenericEditorTabService);
    return /* @ngInject */ GenericEditorTabService;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/*
 * Custom Web Element class Factory aimed at hiding behing a framework agnostic <se-template-ge-widget> tag
 * the legacy AngularJS / ng-include / template based implementations of old Generic editor custom widgets.
 *
 */
function genericEditorAngularJSTemplateBasedCustomElementClassFactory(upgrade) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _this = _super.call(this, upgrade) || this;
            _this.angularJSBody = "\n            <div\n                class=\"ySEGenericEditorField ySEGenericEditorField__input-page-name--color\"\n                data-ng-include=\"field.template\"\n            ></div>\n        ";
            return _this;
        }
        class_1.prototype.internalConnectedCallback = function () {
            var parent = this.parentElement.closest("se-generic-editor-field") ||
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                this.parentElement.closest("generic-editor-field");
            if (!parent || !parent.field) {
                return;
            }
            this.markAsProcessed();
            var editor = parent.editor, model = parent.model, field = parent.field, qualifier = parent.qualifier, id = parent.id, editorStackId = parent.editorStackId, isFieldDisabled = parent.isFieldDisabled, $ctrl = parent.$ctrl;
            while (this.firstChild) {
                this.removeChild(this.firstChild);
            }
            this.appendChild(window.smarteditJQuery(this.angularJSBody)[0]);
            this.scope = this.$rootScope.$new(false);
            var scope = this
                .scope;
            scope.editor = editor;
            scope.model = model;
            scope.field = field;
            scope.qualifier = qualifier;
            scope.id = id;
            scope.editorStackId = editorStackId;
            scope.isFieldDisabled = isFieldDisabled;
            scope.$ctrl = $ctrl;
            this.$compile(this)(this.scope)[0];
        };
        return class_1;
    }(AbstractAngularJSBasedCustomElement));
}
var /* @ngInject */ LegacyGEWidgetToCustomElementConverter = /** @class */ (function () {
    LegacyGEWidgetToCustomElementConverter.$inject = ["upgrade", "windowUtils"];
    function /* @ngInject */ LegacyGEWidgetToCustomElementConverter(upgrade, windowUtils) {
        this.upgrade = upgrade;
        this.windowUtils = windowUtils;
    }
    /* @ngInject */ LegacyGEWidgetToCustomElementConverter_1 = /* @ngInject */ LegacyGEWidgetToCustomElementConverter;
    /*
     * must only happen in the container, and only once, where generic editor is eligible.
     * If it happens first in smarteditloader or smartedit then the injection of those
     * will be used and the app will miss dependencies and template cache.
     */
    /* @ngInject */ LegacyGEWidgetToCustomElementConverter.prototype.convert = function () {
        if (!this.windowUtils.isIframe() &&
            !customElements.get(/* @ngInject */ LegacyGEWidgetToCustomElementConverter_1.TEMPLATE_WIDGET_NAME)) {
            var CustomComponentClass = genericEditorAngularJSTemplateBasedCustomElementClassFactory(this.upgrade);
            customElements.define(/* @ngInject */ LegacyGEWidgetToCustomElementConverter_1.TEMPLATE_WIDGET_NAME, CustomComponentClass);
        }
    };
    var /* @ngInject */ LegacyGEWidgetToCustomElementConverter_1;
    /* @ngInject */ LegacyGEWidgetToCustomElementConverter.TEMPLATE_WIDGET_NAME = "se-template-ge-widget";
    /* @ngInject */ LegacyGEWidgetToCustomElementConverter = /* @ngInject */ LegacyGEWidgetToCustomElementConverter_1 = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [_static.UpgradeModule, WindowUtils])
    ], /* @ngInject */ LegacyGEWidgetToCustomElementConverter);
    return /* @ngInject */ LegacyGEWidgetToCustomElementConverter;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorBreadcrumbComponent", {
    selector: 'se-generic-editor-breadcrumb',
    template: "\n        <div class=\"se-ge-breadcrumb\">\n            <ng-container *ngIf=\"showBreadcrumb()\">\n                <div\n                    *ngFor=\"let breadcrumbItem of getEditorsStack(); let i = index\"\n                    class=\"se-ge-breadcrumb__item\"\n                >\n                    <div class=\"se-ge-breadcrumb__data\">\n                        <span class=\"se-ge-breadcrumb__title\">\n                            {{ getComponentName(breadcrumbItem) | translate }}\n                        </span>\n                        <span class=\"se-ge-breadcrumb__info\">\n                            {{ breadcrumbItem.componentType | translate }}\n                        </span>\n                    </div>\n\n                    <div\n                        class=\"se-ge-breadcrumb__divider sap-icon--navigation-right-arrow\"\n                        *ngIf=\"i < getEditorsStack().length - 1\"\n                    ></div>\n                </div>\n            </ng-container>\n        </div>\n    "
});
/**
 * Component responsible for rendering a breadcrumb on top of the generic editor
 * when there is more than one editor opened on top of each other.
 * This will happen when editing nested components.
 *
 * @param editorStackId The string that identifies the stack of editors being edited together.
 */
var GenericEditorBreadcrumbComponent = /** @class */ (function () {
    function GenericEditorBreadcrumbComponent(genericEditorStackService, ge) {
        this.genericEditorStackService = genericEditorStackService;
        this.ge = ge;
    }
    GenericEditorBreadcrumbComponent.prototype.getEditorsStack = function () {
        if (!this.editorsStack) {
            this.editorsStack = this.genericEditorStackService.getEditorsStack(this.ge.editorStackId);
        }
        return this.editorsStack;
    };
    GenericEditorBreadcrumbComponent.prototype.showBreadcrumb = function () {
        return this.getEditorsStack() && this.getEditorsStack().length > 1;
    };
    GenericEditorBreadcrumbComponent.prototype.getComponentName = function (breadcrumbItem) {
        if (!breadcrumbItem.component.name) {
            return 'se.breadcrumb.name.empty';
        }
        return breadcrumbItem.component.name;
    };
    GenericEditorBreadcrumbComponent = __decorate([
        core.Component({
            selector: 'se-generic-editor-breadcrumb',
            template: "\n        <div class=\"se-ge-breadcrumb\">\n            <ng-container *ngIf=\"showBreadcrumb()\">\n                <div\n                    *ngFor=\"let breadcrumbItem of getEditorsStack(); let i = index\"\n                    class=\"se-ge-breadcrumb__item\"\n                >\n                    <div class=\"se-ge-breadcrumb__data\">\n                        <span class=\"se-ge-breadcrumb__title\">\n                            {{ getComponentName(breadcrumbItem) | translate }}\n                        </span>\n                        <span class=\"se-ge-breadcrumb__info\">\n                            {{ breadcrumbItem.componentType | translate }}\n                        </span>\n                    </div>\n\n                    <div\n                        class=\"se-ge-breadcrumb__divider sap-icon--navigation-right-arrow\"\n                        *ngIf=\"i < getEditorsStack().length - 1\"\n                    ></div>\n                </div>\n            </ng-container>\n        </div>\n    "
        }),
        __param(1, core.Inject(core.forwardRef(function () { return GenericEditorComponent$1; }))),
        __metadata("design:paramtypes", [GenericEditorStackService,
            GenericEditorComponent$1])
    ], GenericEditorBreadcrumbComponent);
    return GenericEditorBreadcrumbComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorDynamicFieldComponent", {
    selector: 'se-ge-dynamic-field',
    styles: [
        "\n            :host {\n                display: block;\n            }\n        "
    ],
    template: "\n        <se-generic-editor-field\n            [formControl]=\"form\"\n            [field]=\"field\"\n            [model]=\"component\"\n            [qualifier]=\"qualifier\"\n            [id]=\"id\"\n        ></se-generic-editor-field>\n    "
});
/**
 * TODO: Some parts of the generic editor field can be moved up to this component.
 * and then we could dynamic inject which form we should put the control in.
 */
var GenericEditorDynamicFieldComponent = /** @class */ (function () {
    function GenericEditorDynamicFieldComponent() {
    }
    __decorate([
        utils.DynamicForm(),
        __metadata("design:type", utils.FormField)
    ], GenericEditorDynamicFieldComponent.prototype, "form", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Object)
    ], GenericEditorDynamicFieldComponent.prototype, "component", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Object)
    ], GenericEditorDynamicFieldComponent.prototype, "field", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", String)
    ], GenericEditorDynamicFieldComponent.prototype, "qualifier", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", String)
    ], GenericEditorDynamicFieldComponent.prototype, "id", void 0);
    GenericEditorDynamicFieldComponent = __decorate([
        core.Component({
            selector: 'se-ge-dynamic-field',
            styles: [
                "\n            :host {\n                display: block;\n            }\n        "
            ],
            template: "\n        <se-generic-editor-field\n            [formControl]=\"form\"\n            [field]=\"field\"\n            [model]=\"component\"\n            [qualifier]=\"qualifier\"\n            [id]=\"id\"\n        ></se-generic-editor-field>\n    "
        })
    ], GenericEditorDynamicFieldComponent);
    return GenericEditorDynamicFieldComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorTabComponent", {
    selector: 'se-ge-tab',
    template: "<div class=\"se-generic-editor__row ySErow\" *ngFor=\"let field of fields\" [ngClass]=\"'se-generic-editor__row--' + field.qualifier\"><label [id]=\"field.qualifier + '-label'\" class=\"se-control-label\" *ngIf=\"!field.hidePrefixLabel && field.i18nKey\" [ngClass]=\"{ required: field.required }\">{{ field.i18nKey | lowercase | translate }}</label><div class=\"ySEGenericEditorFieldStructure\" [id]=\"field.qualifier\" [attr.data-cms-field-qualifier]=\"field.qualifier\" [attr.data-cms-structure-type]=\"field.cmsStructureType\"><ng-template [formRenderer]=\"getForm(field.qualifier)\"></ng-template></div></div>"
});
var GenericEditorTabComponent = /** @class */ (function () {
    function GenericEditorTabComponent(ge, data) {
        this.ge = ge;
        this.data = data;
    }
    GenericEditorTabComponent.prototype.ngOnInit = function () {
        var _this = this;
        var _a = this.data, master = _a.model, tabId = _a.tabId;
        this.fields = master.getInput('fieldsMap')[tabId];
        var group = master.controls[tabId];
        this.forms = group.controls;
        this._subscription = group.statusChanges.subscribe(function () {
            var hasErrorMessages = lodash.values(_this.forms).some(function (form) {
                var field = form.getInput('field');
                return field.messages && field.messages.length > 0;
            });
            _this.data.tab.hasErrors = hasErrorMessages;
        });
        Object.keys(this.forms).forEach(function (key) {
            _this.forms[key].setInput('id', _this.ge.editor.id);
        });
    };
    GenericEditorTabComponent.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    GenericEditorTabComponent.prototype.getForm = function (id) {
        return this.forms[id];
    };
    GenericEditorTabComponent = __decorate([
        core.Component({
            selector: 'se-ge-tab',
            template: "<div class=\"se-generic-editor__row ySErow\" *ngFor=\"let field of fields\" [ngClass]=\"'se-generic-editor__row--' + field.qualifier\"><label [id]=\"field.qualifier + '-label'\" class=\"se-control-label\" *ngIf=\"!field.hidePrefixLabel && field.i18nKey\" [ngClass]=\"{ required: field.required }\">{{ field.i18nKey | lowercase | translate }}</label><div class=\"ySEGenericEditorFieldStructure\" [id]=\"field.qualifier\" [attr.data-cms-field-qualifier]=\"field.qualifier\" [attr.data-cms-structure-type]=\"field.cmsStructureType\"><ng-template [formRenderer]=\"getForm(field.qualifier)\"></ng-template></div></div>"
        }),
        __param(1, core.Inject(TAB_DATA)),
        __metadata("design:paramtypes", [GenericEditorComponent$1, Object])
    ], GenericEditorTabComponent);
    return GenericEditorTabComponent;
}());

var createValidatorMap = function (validators, id, structure, required, component) {
    return Object.keys(validators || {}).reduce(function (acc, item) {
        var _a;
        return (__assign(__assign({}, acc), (_a = {}, _a[item] = validators[item](id, structure, required, component), _a)));
    }, {});
};
/**
 * A schema and data mapper for the GenericEditorRootTabsComponent.
 */
var RootSchemaDataMapper = /** @class */ (function () {
    function RootSchemaDataMapper(mappers, tabs, fieldsMap) {
        this.mappers = mappers;
        this.tabs = tabs;
        this.fieldsMap = fieldsMap;
    }
    RootSchemaDataMapper.prototype.toValue = function () {
        return this.mappers.reduce(function (acc, mapper) {
            acc[mapper.id] = mapper.toValue();
            return acc;
        }, {});
    };
    RootSchemaDataMapper.prototype.toSchema = function () {
        return {
            type: 'group',
            component: 'tabs',
            schemas: this.mappers.reduce(function (acc, mapper) {
                acc[mapper.id] = mapper.toSchema();
                return acc;
            }, {}),
            inputs: {
                tabs: this.tabs,
                fieldsMap: this.fieldsMap
            }
        };
    };
    return RootSchemaDataMapper;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * @internal
 */
var INTERNAL_PROP_NAME = '$$internal';
/**
 * @internal
 * Adds an internal property on the component model for
 * watching property changes on an object.
 */
var InternalProperty = /** @class */ (function () {
    function InternalProperty() {
        this._map = new Map();
    }
    /**
     * Watch property changes.
     */
    InternalProperty.prototype.watch = function (property, fn) {
        var _this = this;
        this._map.set(property, fn);
        return function () {
            _this._map.delete(property);
        };
    };
    /**
     * Trigger prop change.
     *
     * @param property
     * @param value New value
     */
    InternalProperty.prototype.trigger = function (property, value) {
        if (this._map.has(property)) {
            this._map.get(property)(value);
        }
    };
    return InternalProperty;
}());
/**
 * @internal
 * Creates a proxied object to listen on property changes
 * for backwards compatibility with object mutations made by
 * widgets. This is used to proxy the model data called component in the
 * generic editor. The component data is the model that is
 * used for submitting to the backend. Old widgets mutate the
 * properties of component object, thus there is not way to
 * listen on properties changes except for the use of the ES6 Proxy
 * API. Some properties that are watched inside of the GenericEditorField
 * update the value of the AbstractForm of Angular used for validation.
 *
 * NOTE:
 * This function uses Proxy which is not supported in IE.
 */
var proxifyDataObject = function (obj) {
    var internal = new InternalProperty();
    Object.defineProperty(obj, INTERNAL_PROP_NAME, {
        get: function () { return internal; }
    });
    return new Proxy(obj, {
        set: function (target, prop, value) {
            target[prop] = value;
            target[INTERNAL_PROP_NAME].trigger(prop, value);
            return true;
        }
    });
};

var VALIDATION_MESSAGE_TYPES_SET = new Set(lodash.values(VALIDATION_MESSAGE_TYPES));
var CMS_STRUCTURE_TYPE = {
    SHORT_STRING: 'ShortString',
    LONG_STRING: 'LongString'
};
/**
 * @internal
 * Holds the entire state of the generic editor.
 * Provides method to query and mutate the generic editor state.
 * The GenericEditorState is created by the GenericEditorStateBuilderService.
 */
var GenericEditorState = /** @class */ (function () {
    function GenericEditorState(id, group, component, proxiedComponent, pristine, tabs, fields, languages, parameters) {
        var _this = this;
        this.id = id;
        this.group = group;
        this.component = component;
        this.proxiedComponent = proxiedComponent;
        this.pristine = pristine;
        this.tabs = tabs;
        this.fields = fields;
        this.languages = languages;
        this.parameters = parameters;
        /**
         * Removes all validation (local, outside or server) errors from fieds and tabs.
         */
        this.removeValidationMessages = function () {
            _this.fields.forEach(function (field) {
                field.messages = undefined;
                field.hasErrors = false;
                field.hasWarnings = false;
            });
        };
        this._qualifierFieldMap = this.fields.reduce(function (acc, field) {
            acc.set(field.qualifier, field);
            return acc;
        }, new Map());
        this._formFields = this._buildFormFieldsArray(this.group);
    }
    /**
     * Removes validation errors generated in frontend, not the ones sent by outside or server.
     * Removes errors only from fields, not tabs.
     */
    GenericEditorState.prototype.removeFrontEndValidationMessages = function () {
        var _this = this;
        this.fields.forEach(function (field) {
            if (!Array.isArray(field.messages)) {
                return;
            }
            var messages = (field.messages || []).filter(function (message) {
                return message.fromSubmit === undefined ? true : message.fromSubmit;
            });
            field.messages = messages.length ? messages : undefined;
            field.hasErrors = _this._containsValidationMessageType(field.messages, VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR);
            field.hasWarnings = _this._containsValidationMessageType(field.messages, VALIDATION_MESSAGE_TYPES.WARNING);
        });
    };
    /**
     * Checks if this validation message belongs to the current generic editor by seeing if the generic editor
     * has the qualifier.
     *
     * TODO: It assumes that the qualifier is unique in every genericeditor.
     *
     * @param {GenericEditorFieldMessage} validationMessage
     * @return {boolean}
     */
    GenericEditorState.prototype.validationMessageBelongsToCurrentInstance = function (validationMessage) {
        return this._qualifierFieldMap.has(validationMessage.subject);
    };
    /**
     * @param {GenericEditorFieldMessage[]} messages
     * @return {GenericEditorFieldMessage[]}
     */
    GenericEditorState.prototype.collectUnrelatedValidationMessages = function (messages) {
        var _this = this;
        return messages.filter(function (message) {
            return _this._isValidationMessageType(message.type) &&
                !_this.validationMessageBelongsToCurrentInstance(message);
        });
    };
    /**
     * Collects validation errors on all the form fields.
     * Returns the list of errors or empty list.
     * Each error contains the following properties:
     * type - VALIDATION_MESSAGE_TYPES
     * subject - the field qualifier.
     * message - error message.
     * fromSubmit - contains true if the error is related to submit operation, false otherwise.
     * isNonPristine - contains true if the field was modified (at least once) by the user, false otherwise.
     * language - optional language iso code.
     */
    GenericEditorState.prototype.watchErrors = function (formElement) {
        var _this = this;
        var formChangeStream = this._formFields.map(function (form) {
            return form.statusChanges.pipe(operators.startWith(null));
        });
        rxjs.combineLatest(__spreadArrays(formChangeStream, [this.group.statusChanges.pipe(operators.startWith(null))]))
            .pipe(operators.distinctUntilChanged(function (prev, curr) { return lodash.isEqual(prev, curr); }), operators.map(function () { return _this.collectFrontEndValidationErrors(false, formElement); }))
            .subscribe(function (messages) {
            _this.removeFrontEndValidationMessages();
            _this.displayValidationMessages(messages, false);
        });
    };
    GenericEditorState.prototype.collectFrontEndValidationErrors = function (comesFromSubmit, formElement) {
        var _this = this;
        comesFromSubmit = comesFromSubmit || false;
        return this._formFields.reduce(function (acc, form) {
            var field = form.getInput('field');
            if ((function () {
                var fieldNativeElement = Array.from(formElement || []).find(function (elem) { return elem.getAttribute('name') === field.qualifier; });
                return !!fieldNativeElement && !fieldNativeElement.checkValidity();
            })()) {
                acc.push({
                    type: VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR,
                    subject: field.qualifier,
                    message: 'se.editor.htmlo.validation.error',
                    fromSubmit: comesFromSubmit,
                    isNonPristine: _this.isDirty(field.qualifier)
                });
            }
            // Could get more specific errors.
            if (form.getError('required') && form.touched) {
                if (field.localized) {
                    var id = form.getInput('id');
                    acc.push({
                        type: VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR,
                        subject: field.qualifier,
                        message: 'se.componentform.required.field',
                        language: id,
                        fromSubmit: comesFromSubmit,
                        isNonPristine: _this.isDirty(field.qualifier, id // Isocode
                        )
                    });
                }
                else {
                    acc.push({
                        type: VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR,
                        subject: field.qualifier,
                        message: 'se.componentform.required.field',
                        fromSubmit: comesFromSubmit,
                        isNonPristine: _this.isDirty(field.qualifier)
                    });
                }
            }
            return acc;
        }, []);
    };
    /**
     * Displays validation errors for fields and changes error states for all tabs.
     * TODO: move validation to fields.
     */
    GenericEditorState.prototype.displayValidationMessages = function (validationMessages, keepAllErrors) {
        var _this = this;
        validationMessages
            .filter(function (message) {
            return _this._isValidationMessageType(message.type) &&
                (keepAllErrors || message.isNonPristine);
        })
            .forEach(function (validation) {
            validation.type = validation.type || VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR;
            var field = _this._qualifierFieldMap.get(validation.subject);
            if (!field) {
                return;
            }
            if (!field.messages) {
                field.messages = [];
            }
            var message = lodash.merge(validation, _this._getParseValidationMessage(validation.message));
            message.marker = field.localized ? message.language : field.qualifier;
            message.type = validation.type;
            message.uniqId = stringUtils.encode(message);
            var existing = field.messages.find(function (msg) { return msg.uniqId === message.uniqId; });
            if (!existing) {
                field.messages.push(message);
                if (message.type === VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR) {
                    field.hasErrors = true;
                }
                else if (message.type === VALIDATION_MESSAGE_TYPES.WARNING) {
                    field.hasWarnings = true;
                }
            }
            else {
                // Update existing message.
                lodash.merge(existing, message);
            }
        });
        /**
         * Need to trigger onStatusChanges for each tab because these messages are added after
         * validation is triggered inside of AbstractFormControls. Messages will dictate for now
         * if a field is invalid.
         */
        lodash.values(this.group.controls).forEach(function (tab) {
            tab.updateValueAndValidity({ emitEvent: true });
        });
        return Promise.resolve();
    };
    GenericEditorState.prototype.isDirty = function (qualifier, language) {
        this._bcPristine = this._buildComparable(this.fields, this.pristine);
        var bcComponent = this._buildComparable(this.fields, this.component);
        var subPristine = qualifier
            ? language
                ? this._bcPristine[qualifier][language]
                : this._bcPristine[qualifier]
            : this._bcPristine;
        var subComponent = qualifier
            ? language
                ? bcComponent[qualifier][language]
                : bcComponent[qualifier]
            : bcComponent;
        return !lodash.isEqual(subPristine, subComponent);
    };
    GenericEditorState.prototype.fieldsAreUserChecked = function () {
        return this.fields.every(function (field) {
            var requiresUserCheck = false;
            for (var qualifier in field.requiresUserCheck) {
                if (field.requiresUserCheck.hasOwnProperty(qualifier)) {
                    requiresUserCheck = requiresUserCheck || field.requiresUserCheck[qualifier];
                }
            }
            return !requiresUserCheck || field.isUserChecked;
        });
    };
    /**
     * Updates the component with the patching component.
     */
    GenericEditorState.prototype.patchComponent = function (value) {
        // Proxify the localized objects.
        this._qualifierFieldMap.forEach(function (_a) {
            var localized = _a.localized, qualifier = _a.qualifier;
            if (localized && value[qualifier]) {
                value[qualifier] = proxifyDataObject(value[qualifier]);
            }
        });
        Object.assign(this.proxiedComponent, value);
    };
    /**
     * Get sanitized payload to be sent to the backend.
     *
     * **Deprecated since 2105. It will be removed in next release.**
     *
     * @deprecated
     */
    GenericEditorState.prototype.sanitizedPayload = function (payload) {
        if (payload === void 0) { payload = this.component; }
        this.fields
            .filter(function (field) {
            return field.cmsStructureType === CMS_STRUCTURE_TYPE.LONG_STRING ||
                field.cmsStructureType === CMS_STRUCTURE_TYPE.SHORT_STRING ||
                typeof field.customSanitize === 'function';
        })
            .forEach(function (_a) {
            var qualifier = _a.qualifier, localized = _a.localized, customSanitize = _a.customSanitize;
            if (payload[qualifier] !== undefined && qualifier in payload) {
                if (customSanitize) {
                    payload[qualifier] = customSanitize(payload[qualifier], stringUtils.sanitize);
                    return;
                }
            }
        });
        return payload;
    };
    /*
     * Switches to tab with qualifier.
     * Causes the genericEditor to switch to the tab containing a qualifier of the given name.
     */
    GenericEditorState.prototype.switchToTabContainingQualifier = function (targetedQualifier) {
        var _this = this;
        if (!targetedQualifier) {
            return;
        }
        this.tabs.forEach(function (tab) {
            tab.active = !!_this.group.get([tab.id, targetedQualifier]);
        });
    };
    GenericEditorState.prototype._getParseValidationMessage = function (message) {
        return parseValidationMessage(message);
    };
    /**
     * @internal
     * Sees if it contains validation message type.
     */
    GenericEditorState.prototype._containsValidationMessageType = function (validationMessages, messageType) {
        var _this = this;
        if (!Array.isArray(validationMessages)) {
            return false;
        }
        return validationMessages.some(function (message) {
            return message.type === messageType &&
                _this.validationMessageBelongsToCurrentInstance(message);
        });
    };
    /**
     * @internal
     * Checks if validation message type is of type ValidationError or Warning.
     */
    GenericEditorState.prototype._isValidationMessageType = function (messageType) {
        return VALIDATION_MESSAGE_TYPES_SET.has(messageType);
    };
    /**
     * @internal
     * Builds a comparable data object.
     */
    GenericEditorState.prototype._buildComparable = function (fields, source) {
        var _this = this;
        if (!source) {
            return source;
        }
        var comparable = {};
        fields.forEach(function (field) {
            var fieldValue = source[field.qualifier];
            if (field.localized) {
                fieldValue = fieldValue;
                var sub_1 = {};
                lodash.forEach(fieldValue, function (langValue, lang) {
                    if (!lodash.isUndefined(langValue)) {
                        sub_1[lang] = _this._buildFieldComparable(langValue, field);
                    }
                });
                comparable[field.qualifier] = sub_1;
            }
            else {
                fieldValue = source[field.qualifier];
                comparable[field.qualifier] = _this._buildFieldComparable(fieldValue, field);
            }
        });
        // sometimes, such as in navigationNodeEntryEditor, we update properties not part of the fields and still want the editor to turn dirty
        lodash.forEach(source, function (value, key) {
            var notDisplayed = !fields.some(function (field) { return field.qualifier === key; });
            if (notDisplayed) {
                comparable[key] = value;
            }
        });
        return lodash.omitBy(comparable, lodash.isUndefined);
    };
    /**
     * @internal
     */
    GenericEditorState.prototype._buildFieldComparable = function (fieldValue, field) {
        switch (field.cmsStructureType) {
            case 'RichText':
                return fieldValue !== undefined ? stringUtils.sanitizeHTML(fieldValue) : null;
            case 'Boolean':
                return fieldValue !== undefined ? fieldValue : false;
            default:
                return fieldValue;
        }
    };
    /**
     * @internal
     * Get all leaf nodes of the form.
     */
    GenericEditorState.prototype._buildFormFieldsArray = function (form, array) {
        var _this = this;
        if (array === void 0) { array = []; }
        if (form instanceof utils.FormField) {
            array.push(form);
            return array;
        }
        if (form instanceof utils.FormGrouping) {
            Object.keys(form.controls).forEach(function (key) {
                var field = form.controls[key];
                _this._buildFormFieldsArray(field, array);
            });
            return array;
        }
        return array;
    };
    return GenericEditorState;
}());

/**
 * A schema and data mapper for the GenericEditorDynamicFieldComponent.
 */
var FieldSchemaDataMapper = /** @class */ (function () {
    function FieldSchemaDataMapper(id, structure, required, component) {
        this.id = id;
        this.structure = structure;
        this.required = required;
        this.component = component;
    }
    FieldSchemaDataMapper.prototype.toValue = function () {
        return this.component[this.id];
    };
    FieldSchemaDataMapper.prototype.toSchema = function () {
        return {
            type: 'field',
            component: 'field',
            validators: __assign({ required: (this.required && this.structure.editable) || undefined }, createValidatorMap(this.structure.validators, this.id, this.structure, this.required, this.component)),
            inputs: {
                id: this.id,
                field: this.structure,
                qualifier: this.id,
                component: this.component
            }
        };
    };
    return FieldSchemaDataMapper;
}());

/**
 * A schema and data mapper for the LocalizedElementComponent.
 */
var LocalizedSchemaDataMapper = /** @class */ (function () {
    function LocalizedSchemaDataMapper(id, mappers, structure, languages, component) {
        this.id = id;
        this.mappers = mappers;
        this.structure = structure;
        this.languages = languages;
        this.component = component;
    }
    LocalizedSchemaDataMapper.prototype.toValue = function () {
        return this.mappers.reduce(function (acc, mapper) {
            acc[mapper.id] = mapper.toValue();
            return acc;
        }, {});
    };
    LocalizedSchemaDataMapper.prototype.toSchema = function () {
        return {
            type: 'group',
            component: 'localized',
            schemas: this.mappers.reduce(function (acc, mapper) {
                acc[mapper.id] = mapper.toSchema();
                return acc;
            }, {}),
            inputs: {
                field: this.structure,
                languages: this.languages,
                component: this.component
            }
        };
    };
    return LocalizedSchemaDataMapper;
}());

/**
 * A schema and data mapper for the GenericEditorTabComponent.
 */
var TabSchemaDataMapper = /** @class */ (function () {
    function TabSchemaDataMapper(id, mappers) {
        this.id = id;
        this.mappers = mappers;
    }
    TabSchemaDataMapper.prototype.toValue = function () {
        return this.mappers.reduce(function (acc, field) {
            acc[field.id] = field.toValue();
            return acc;
        }, {});
    };
    TabSchemaDataMapper.prototype.toSchema = function () {
        return {
            type: 'group',
            persist: false,
            schemas: this.mappers.reduce(function (acc, field) {
                acc[field.id] = field.toSchema();
                return acc;
            }, {})
        };
    };
    return TabSchemaDataMapper;
}());

var createFieldMapper = function (qualifier, field, required, component) { return new FieldSchemaDataMapper(qualifier, field, required, component); };
var createLocalizedMapper = function (field, languages, component) {
    if (component[field.qualifier] === undefined) {
        component[field.qualifier] = {};
    }
    component[field.qualifier] = proxifyDataObject(component[field.qualifier]);
    var localMappers = languages.map(function (_a) {
        var isocode = _a.isocode, required = _a.required;
        return createFieldMapper(isocode, field, field.required && required, component[field.qualifier]);
    });
    return new LocalizedSchemaDataMapper(field.qualifier, localMappers, field, languages, component);
};
var createTabMapper = function (id, fields, languages, component) {
    var fieldMappers = fields.map(function (field) {
        if (field.localized) {
            return createLocalizedMapper(field, languages, component);
        }
        return createFieldMapper(field.qualifier, field, field.required, component);
    });
    return new TabSchemaDataMapper(id, fieldMappers);
};
/**
 * @internal
 * The createRootMapper is an entry factory to creating the RootSchemaDataMapper and
 * the subsequent the nested mappers for tabs, localized fields, and dynamic fields components.
 * The returning instance is of type RootSchemaDataMapper which contains
 * two methods for building the data and schema object that will be passed
 * to the form builder's schema compiler service to build the FormGrouping.
 *
 * @param {GenericEditorFieldsMap} fieldsMap
 * @param {Payload} component
 * @param {ILanguage[]} languages
 * @param {GenericEditorTab[]} tabs
 * @return {RootSchemaDataMapper} A mapper for building data and schema for it to be
 * consumed by the SchemaCompilerService in the FormBuilder module.
 */
var createRootMapper = function (fieldsMap, component, languages, tabs) {
    var rootMappers = lodash.toPairs(fieldsMap).map(function (_a) {
        var id = _a[0], fields = _a[1];
        return createTabMapper(id, fields, languages, component);
    });
    return new RootSchemaDataMapper(rootMappers, tabs, fieldsMap);
};

/**
 * @internal
 * GenericEditorStateBuilderService generates a GenericEditorState.
 */
var /* @ngInject */ GenericEditorStateBuilderService = /** @class */ (function () {
    GenericEditorStateBuilderService.$inject = ["editorFieldMappingService", "genericEditorTabService", "translateService", "schemaCompiler"];
    function /* @ngInject */ GenericEditorStateBuilderService(
    /** @internal */
    editorFieldMappingService, 
    /** @internal */
    genericEditorTabService, 
    /** @internal */
    translateService, 
    /** @internal */
    schemaCompiler) {
        this.editorFieldMappingService = editorFieldMappingService;
        this.genericEditorTabService = genericEditorTabService;
        this.translateService = translateService;
        this.schemaCompiler = schemaCompiler;
    }
    /**
     * Compiles a GenericEditorState from schema and data. Whenever a new state
     * is provided the entire form is recompiled.
     */
    /* @ngInject */ GenericEditorStateBuilderService.prototype.buildState = function (data, schema) {
        var _this = this;
        var fields = this._fieldAdaptor(schema);
        var tabs = [];
        var fieldsMap = fields.reduce(function (seed, field) {
            var tab = _this.editorFieldMappingService.getFieldTabMapping(field, schema.structure);
            if (!tab) {
                tab = _this.genericEditorTabService.getComponentTypeDefaultTab(schema.structure);
            }
            if (!seed[tab]) {
                seed[tab] = [];
                tabs.push({
                    id: tab,
                    title: 'se.genericeditor.tab.' + tab + '.title',
                    component: GenericEditorTabComponent
                });
            }
            seed[tab].push(field);
            return seed;
        }, {});
        this.genericEditorTabService.sortTabs(tabs);
        // for setting uri params into custom widgets
        var parameters = {
            siteId: schema.uriContext[CONTEXT_SITE_ID],
            catalogId: schema.uriContext[CONTEXT_CATALOG],
            catalogVersion: schema.uriContext[CONTEXT_CATALOG_VERSION]
        };
        var component = objectUtils.copy(data);
        var proxied = proxifyDataObject(component);
        var mapper = this._createMapper(fieldsMap, proxied, schema.languages, tabs);
        var form = this.schemaCompiler.compileGroup(mapper.toValue(), mapper.toSchema());
        // Create central state handler.
        var state = new GenericEditorState(schema.id, form, component, proxied, objectUtils.copy(data), // Pristine form.
        tabs, fields, schema.languages, parameters);
        state.switchToTabContainingQualifier(schema.targetedQualifier);
        return state;
    };
    GenericEditorStateBuilderService.prototype.buildState.$inject = ["data", "schema"];
    /** @internal */
    /* @ngInject */ GenericEditorStateBuilderService.prototype._createMapper = function (fieldsMap, component, languages, tabs) {
        return createRootMapper(fieldsMap, component, languages, tabs);
    };
    GenericEditorStateBuilderService.prototype._createMapper.$inject = ["fieldsMap", "component", "languages", "tabs"];
    /** @internal */
    /* @ngInject */ GenericEditorStateBuilderService.prototype._fieldAdaptor = function (schema) {
        var _this = this;
        var structure = schema.structure;
        return structure.attributes.map(function (field) {
            var fieldMapping = _this.editorFieldMappingService.getEditorFieldMapping(field, structure);
            var genericField = Object.assign(field, fieldMapping);
            if (genericField.editable === undefined) {
                genericField.editable = true;
            }
            if (!genericField.postfixText) {
                var key = (structure.type ? structure.type.toLowerCase() : '') +
                    '.' +
                    field.qualifier.toLowerCase() +
                    '.postfix.text';
                var translated = _this.translateService.instant(key);
                genericField.postfixText = translated !== key ? translated : '';
            }
            genericField.smarteditComponentType = schema.smarteditComponentType;
            return genericField;
        });
    };
    GenericEditorStateBuilderService.prototype._fieldAdaptor.$inject = ["schema"];
    /* @ngInject */ GenericEditorStateBuilderService = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [EditorFieldMappingService,
            GenericEditorTabService,
            core$1.TranslateService,
            utils.SchemaCompilerService])
    ], /* @ngInject */ GenericEditorStateBuilderService);
    return /* @ngInject */ GenericEditorStateBuilderService;
}());

var FormBuilderDirective = /** @class */ (function () {
    function FormBuilderDirective(templateRef, viewContainer, stateBuilderService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.stateBuilderService = stateBuilderService;
        this.stateCreated = new core.EventEmitter();
    }
    Object.defineProperty(FormBuilderDirective.prototype, "formBuilder", {
        set: function (input) {
            this._dispose();
            this._subscription = rxjs.combineLatest(input.data$, input.schema$).subscribe(this._onDataStream.bind(this));
        },
        enumerable: false,
        configurable: true
    });
    FormBuilderDirective.prototype.ngOnDestroy = function () {
        this._dispose();
    };
    FormBuilderDirective.prototype._onDataStream = function (_a) {
        var data = _a[0], schema = _a[1];
        if (!data || !schema) {
            return;
        }
        /**
         * Destroys all views and recreate the embeddedview.
         */
        this.viewContainer.clear();
        /**
         * No form supported.
         */
        if (!schema.structure) {
            this.viewContainer.createEmbeddedView(this.templateRef, {
                $implicit: null
            });
            return;
        }
        /**
         * Build state, and emit state.
         */
        var state = this.stateBuilderService.buildState(data, schema);
        this.stateCreated.emit(state);
        this.viewContainer.createEmbeddedView(this.templateRef, {
            $implicit: state
        });
    };
    /**
     * @internal
     * Removes subscription and destroyes all views.
     */
    FormBuilderDirective.prototype._dispose = function () {
        this._subscription && this._subscription.unsubscribe();
        this.viewContainer.clear();
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], FormBuilderDirective.prototype, "formBuilder", null);
    __decorate([
        core.Output(),
        __metadata("design:type", Object)
    ], FormBuilderDirective.prototype, "stateCreated", void 0);
    FormBuilderDirective = __decorate([
        core.Directive({ selector: '[formBuilder]' }),
        __metadata("design:paramtypes", [core.TemplateRef,
            core.ViewContainerRef,
            GenericEditorStateBuilderService])
    ], FormBuilderDirective);
    return FormBuilderDirective;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorFieldComponent", {
    selector: 'se-generic-editor-field',
    providers: [
        {
            provide: forms.NG_VALUE_ACCESSOR,
            useExisting: core.forwardRef(function () { return /* @ngInject */ GenericEditorFieldComponent_1; }),
            multi: true
        }
    ],
    template: "<div [attr.validation-id]=\"field.qualifier\" class=\"ySEField\"><div *ngIf=\"field.template\"><div #widget></div></div><ng-container *ngIf=\"field.component\"><ng-container *ngComponentOutlet=\"field.component; injector: widgetInjector\"></ng-container></ng-container><se-generic-editor-field-messages [field]=\"field\" [qualifier]=\"qualifier\"></se-generic-editor-field-messages><div *ngIf=\"field.postfix\" class=\"ySEText ySEFieldPostfix\">{{ field.postfix | translate }}</div></div>"
});
var /* @ngInject */ GenericEditorFieldComponent = /** @class */ (function () {
    GenericEditorFieldComponent.$inject = ["elementRef", "injector", "ge"];
    function /* @ngInject */ GenericEditorFieldComponent(elementRef, injector, ge) {
        this.elementRef = elementRef;
        this.injector = injector;
        this.ge = ge;
    }
    /* @ngInject */ GenericEditorFieldComponent_1 = /* @ngInject */ GenericEditorFieldComponent;
    /* @ngInject */ GenericEditorFieldComponent.prototype.writeValue = function (value) {
        this.model[this.qualifier] = value;
    };
    GenericEditorFieldComponent.prototype.writeValue.$inject = ["value"];
    /* @ngInject */ GenericEditorFieldComponent.prototype.registerOnChange = function (fn) {
        this._onChange = fn;
    };
    GenericEditorFieldComponent.prototype.registerOnChange.$inject = ["fn"];
    /* @ngInject */ GenericEditorFieldComponent.prototype.registerOnTouched = function (fn) {
        this._onTouched = fn;
    };
    GenericEditorFieldComponent.prototype.registerOnTouched.$inject = ["fn"];
    /* @ngInject */ GenericEditorFieldComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.createInjector();
        this._unWatch = this.model[INTERNAL_PROP_NAME].watch(this.qualifier, function (value) {
            if (_this._onChange && _this._onTouched) {
                _this._onTouched();
                _this._onChange(value);
            }
        });
    };
    /* @ngInject */ GenericEditorFieldComponent.prototype.ngOnDestroy = function () {
        this._unWatch();
    };
    /* @ngInject */ GenericEditorFieldComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!this.field.template) {
            return;
        }
        var element = document.createElement('se-template-ge-widget');
        this.elementRef.nativeElement.editor = this.ge.editor;
        this.elementRef.nativeElement.model = this.model;
        this.elementRef.nativeElement.field = this.field;
        this.elementRef.nativeElement.qualifier = this.qualifier;
        this.elementRef.nativeElement.id = this.id;
        this.elementRef.nativeElement.editorStackId = this.ge.editor.editorStackId;
        this.elementRef.nativeElement.isFieldDisabled = function () { return _this.isFieldDisabled(); };
        this.elementRef.nativeElement.$ctrl = this;
        this.geWidget.nativeElement.appendChild(element);
    };
    /* @ngInject */ GenericEditorFieldComponent.prototype.isFieldDisabled = function () {
        var isEnabled = this.field.editable;
        if (this.field.localized) {
            isEnabled = this.field.editable && this.field.isLanguageEnabledMap[this.qualifier];
        }
        return !isEnabled;
    };
    /* @ngInject */ GenericEditorFieldComponent.prototype.createInjector = function () {
        var _this = this;
        this.widgetInjector = core.Injector.create({
            parent: this.injector,
            providers: [
                {
                    provide: GENERIC_EDITOR_WIDGET_DATA,
                    useValue: {
                        id: this.id,
                        field: this.field,
                        model: this.model,
                        editor: this.ge.editor,
                        qualifier: this.qualifier,
                        isFieldDisabled: function () { return _this.isFieldDisabled(); }
                    }
                }
            ]
        });
    };
    var /* @ngInject */ GenericEditorFieldComponent_1;
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorFieldComponent.prototype, "field", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ GenericEditorFieldComponent.prototype, "model", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorFieldComponent.prototype, "qualifier", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ GenericEditorFieldComponent.prototype, "id", void 0);
    __decorate([
        core.ViewChild('widget', { read: core.ElementRef, static: false }),
        __metadata("design:type", core.ElementRef)
    ], /* @ngInject */ GenericEditorFieldComponent.prototype, "geWidget", void 0);
    /* @ngInject */ GenericEditorFieldComponent = /* @ngInject */ GenericEditorFieldComponent_1 = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-generic-editor-field',
            providers: [
                {
                    provide: forms.NG_VALUE_ACCESSOR,
                    useExisting: core.forwardRef(function () { return /* @ngInject */ GenericEditorFieldComponent_1; }),
                    multi: true
                }
            ],
            template: "<div [attr.validation-id]=\"field.qualifier\" class=\"ySEField\"><div *ngIf=\"field.template\"><div #widget></div></div><ng-container *ngIf=\"field.component\"><ng-container *ngComponentOutlet=\"field.component; injector: widgetInjector\"></ng-container></ng-container><se-generic-editor-field-messages [field]=\"field\" [qualifier]=\"qualifier\"></se-generic-editor-field-messages><div *ngIf=\"field.postfix\" class=\"ySEText ySEFieldPostfix\">{{ field.postfix | translate }}</div></div>"
        }),
        __param(2, core.Inject(core.forwardRef(function () { return GenericEditorComponent$1; }))),
        __metadata("design:paramtypes", [core.ElementRef,
            core.Injector,
            GenericEditorComponent$1])
    ], /* @ngInject */ GenericEditorFieldComponent);
    return /* @ngInject */ GenericEditorFieldComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorFieldMessagesComponent", {
    selector: 'se-generic-editor-field-messages',
    template: "<div *ngIf=\"errors.length > 0\"><span *ngFor=\"let error of errors\" class=\"se-help-block--has-error help-block fd-form__message fd-form__message--error\">{{ error | translate}}</span></div><div *ngIf=\"warnings.length > 0\"><span *ngFor=\"let warning of warnings\" class=\"se-help-block--has-warning help-block fd-form__message fd-form__message--warning\">{{ warning | translate }}</span></div>"
});
var GenericEditorFieldMessagesComponent = /** @class */ (function () {
    function GenericEditorFieldMessagesComponent() {
        this.previousMessages = null;
    }
    GenericEditorFieldMessagesComponent.prototype.ngDoCheck = function () {
        if (this.field) {
            var currentMessages = JSON.stringify(this.field.messages);
            if (this.previousMessages !== currentMessages) {
                this.previousMessages = currentMessages;
                this.errors = this.getFilteredMessagesByType(VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR);
                this.warnings = this.getFilteredMessagesByType(VALIDATION_MESSAGE_TYPES.WARNING);
            }
        }
    };
    GenericEditorFieldMessagesComponent.prototype.getFilteredMessagesByType = function (messageType) {
        var _this = this;
        return (this.field.messages || [])
            .filter(function (validationMessage) {
            return validationMessage.marker === _this.qualifier &&
                !validationMessage.format &&
                validationMessage.type === messageType;
        })
            .map(function (validationMessage) { return validationMessage.message; });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], GenericEditorFieldMessagesComponent.prototype, "field", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], GenericEditorFieldMessagesComponent.prototype, "qualifier", void 0);
    GenericEditorFieldMessagesComponent = __decorate([
        core.Component({
            selector: 'se-generic-editor-field-messages',
            template: "<div *ngIf=\"errors.length > 0\"><span *ngFor=\"let error of errors\" class=\"se-help-block--has-error help-block fd-form__message fd-form__message--error\">{{ error | translate}}</span></div><div *ngIf=\"warnings.length > 0\"><span *ngFor=\"let warning of warnings\" class=\"se-help-block--has-warning help-block fd-form__message fd-form__message--warning\">{{ warning | translate }}</span></div>"
        })
    ], GenericEditorFieldMessagesComponent);
    return GenericEditorFieldMessagesComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorFieldWrapperComponent", {
    selector: 'se-generic-editor-field-wrapper',
    template: " <ng-template [formRenderer]=\"form\"></ng-template> "
});
var GenericEditorFieldWrapperComponent = /** @class */ (function () {
    function GenericEditorFieldWrapperComponent(_a) {
        var form = _a.model, tabId = _a.tabId, tab = _a.tab;
        this.form = form.controls[tabId];
        this._subscription = this.form.statusChanges.subscribe(function (status) {
            tab.hasErrors = status === 'INVALID';
        });
    }
    GenericEditorFieldWrapperComponent.prototype.ngOnDestroy = function () {
        this._subscription.unsubscribe();
    };
    GenericEditorFieldWrapperComponent = __decorate([
        core.Component({
            selector: 'se-generic-editor-field-wrapper',
            template: " <ng-template [formRenderer]=\"form\"></ng-template> "
        }),
        __param(0, core.Inject(TAB_DATA)),
        __metadata("design:paramtypes", [Object])
    ], GenericEditorFieldWrapperComponent);
    return GenericEditorFieldWrapperComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "LocalizedElementComponent", {
    selector: 'se-localized-element',
    styles: [
        "\n            :host {\n                display: block;\n            }\n        "
    ],
    template: "<se-tabs *ngIf=\"tabs\" class=\"multi-tabs-editor\" [model]=\"form\" [tabsList]=\"tabs\" [numTabsDisplayed]=\"6\"></se-tabs>"
});
var LocalizedElementComponent = /** @class */ (function () {
    function LocalizedElementComponent(sessionService) {
        this.sessionService = sessionService;
    }
    LocalizedElementComponent.prototype.onDynamicInputChange = function () {
        this._createLocalizedTabs();
    };
    LocalizedElementComponent.prototype.ngDoCheck = function () {
        if (this.tabs && this.field.messages !== this._previousMessages) {
            this._previousMessages = this.field.messages;
            var messageMap_1 = this.field.messages
                ? this.field.messages
                    .filter(function (message) {
                    return message.type === VALIDATION_MESSAGE_TYPES.VALIDATION_ERROR;
                })
                    .reduce(function (holder, next) {
                    holder[next.language] = true;
                    return holder;
                }, {})
                : {};
            this.tabs = this.tabs.map(function (tab) {
                var message = messageMap_1[tab.id];
                tab.hasErrors = message !== undefined ? message : false;
                return tab;
            });
        }
    };
    LocalizedElementComponent.prototype._createLocalizedTabs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, readableLanguages, writeableLanguages, readableSet, writeable;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.field.isLanguageEnabledMap = {};
                        return [4 /*yield*/, this.sessionService.getCurrentUser()];
                    case 1:
                        _a = _b.sent(), readableLanguages = _a.readableLanguages, writeableLanguages = _a.writeableLanguages;
                        readableSet = new Set(readableLanguages);
                        writeable = new Set(writeableLanguages);
                        this.tabs = this.languages
                            .filter(function (language) { return readableSet.has(language.isocode); })
                            .map(function (_a) {
                            var isocode = _a.isocode, required = _a.required;
                            _this.field.isLanguageEnabledMap[isocode] = writeable.has(isocode);
                            var title = "" + isocode.toUpperCase() + (_this.field.editable && required ? '*' : '');
                            return {
                                title: title,
                                id: isocode,
                                component: GenericEditorFieldWrapperComponent
                            };
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    __decorate([
        utils.DynamicForm(),
        __metadata("design:type", utils.FormGrouping)
    ], LocalizedElementComponent.prototype, "form", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Object)
    ], LocalizedElementComponent.prototype, "field", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Object)
    ], LocalizedElementComponent.prototype, "component", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Array)
    ], LocalizedElementComponent.prototype, "languages", void 0);
    LocalizedElementComponent = __decorate([
        core.Component({
            selector: 'se-localized-element',
            styles: [
                "\n            :host {\n                display: block;\n            }\n        "
            ],
            template: "<se-tabs *ngIf=\"tabs\" class=\"multi-tabs-editor\" [model]=\"form\" [tabsList]=\"tabs\" [numTabsDisplayed]=\"6\"></se-tabs>"
        }),
        __metadata("design:paramtypes", [utils.ISessionService])
    ], LocalizedElementComponent);
    return LocalizedElementComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "GenericEditorRootTabsComponent", {
    selector: 'se-ge-root-tabs',
    styles: [
        "\n            :host {\n                display: block;\n            }\n        "
    ],
    template: "\n        <se-tabs\n            class=\"se-generic-editor__tabs\"\n            [model]=\"form\"\n            [tabsList]=\"tabs\"\n            [numTabsDisplayed]=\"3\"\n        ></se-tabs>\n    "
});
var GenericEditorRootTabsComponent = /** @class */ (function () {
    function GenericEditorRootTabsComponent() {
    }
    __decorate([
        utils.DynamicForm(),
        __metadata("design:type", utils.FormGrouping)
    ], GenericEditorRootTabsComponent.prototype, "form", void 0);
    __decorate([
        utils.DynamicInput(),
        __metadata("design:type", Array)
    ], GenericEditorRootTabsComponent.prototype, "tabs", void 0);
    GenericEditorRootTabsComponent = __decorate([
        core.Component({
            selector: 'se-ge-root-tabs',
            styles: [
                "\n            :host {\n                display: block;\n            }\n        "
            ],
            template: "\n        <se-tabs\n            class=\"se-generic-editor__tabs\"\n            [model]=\"form\"\n            [tabsList]=\"tabs\"\n            [numTabsDisplayed]=\"3\"\n        ></se-tabs>\n    "
        })
    ], GenericEditorRootTabsComponent);
    return GenericEditorRootTabsComponent;
}());

/**
 * Applied on a DOM element, this Directive will trigger a submit of the data stored in
 * the parent {@link ContentManager} upon cliking.
 *
 * ### Example
 *
 *      <form [contentManager]="{onSave: editor.someSubmit}">
 *          <button [seSubmitBtn]="editor.isSubmitDisabled">Submit </button>
 *      </form>
 *
 * @param seSubmitBtn The optional callback returning a boolean to add more cases for disablement
 */
var SubmitBtnDirective = /** @class */ (function () {
    function SubmitBtnDirective(cm) {
        this.cm = cm;
    }
    Object.defineProperty(SubmitBtnDirective.prototype, "disabled", {
        /**
         * Modifies the disabled attribute to be disabled when saving.
         */
        get: function () {
            return this.cm.submitting || (this.isDisabled && this.isDisabled());
        },
        enumerable: false,
        configurable: true
    });
    /**
     * When the element is clicked the save operation is called in the content manager direcitve.
     */
    SubmitBtnDirective.prototype.save = function ($event) {
        $event.preventDefault();
        this.cm.save().subscribe();
    };
    __decorate([
        core.Input('seSubmitBtn'),
        __metadata("design:type", Function)
    ], SubmitBtnDirective.prototype, "isDisabled", void 0);
    __decorate([
        core.HostBinding('disabled'),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [])
    ], SubmitBtnDirective.prototype, "disabled", null);
    __decorate([
        core.HostListener('click', ['$event']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Event]),
        __metadata("design:returntype", void 0)
    ], SubmitBtnDirective.prototype, "save", null);
    SubmitBtnDirective = __decorate([
        core.Directive({
            selector: '[seSubmitBtn]'
        }),
        __metadata("design:paramtypes", [ContentManager])
    ], SubmitBtnDirective);
    return SubmitBtnDirective;
}());

var GenericEditorWidgetModule = /** @class */ (function () {
    function GenericEditorWidgetModule() {
    }
    GenericEditorWidgetModule = __decorate([
        core.NgModule({
            imports: [
                common.CommonModule,
                DateTimePickerModule,
                BooleanModule,
                utils.TranslationModule.forChild(),
                forms.FormsModule,
                RichTextFieldModule,
                SelectModule,
                FloatModule,
                NumberModule,
                EmailModule,
                EditableDropdownModule
            ],
            declarations: [
                ShortStringComponent,
                LongStringComponent,
                EnumComponent,
                EnumItemPrinterComponent,
                DropdownComponent,
                DropdownItemPrinterComponent,
                TextComponent
            ],
            entryComponents: [
                ShortStringComponent,
                LongStringComponent,
                EnumComponent,
                EnumItemPrinterComponent,
                DropdownComponent,
                DropdownItemPrinterComponent,
                TextComponent
            ]
        })
    ], GenericEditorWidgetModule);
    return GenericEditorWidgetModule;
}());

/**
 * Form Builder Setup
 */
var SeGenericEditorModule = /** @class */ (function () {
    function SeGenericEditorModule() {
    }
    SeGenericEditorModule = __decorate([
        core.NgModule({
            schemas: [core.CUSTOM_ELEMENTS_SCHEMA],
            imports: [
                common.CommonModule,
                YjqueryModule,
                forms.FormsModule,
                forms.ReactiveFormsModule,
                FundamentalsModule,
                SharedComponentsModule,
                GenericEditorWidgetModule,
                SelectModule,
                GenericEditorDropdownModule,
                utils.TranslationModule.forChild(),
                utils.FormBuilderModule.forRoot({
                    validators: {
                        required: function () {
                            return forms.Validators.required;
                        },
                        email: function () { return forms.Validators.email; }
                    },
                    types: {
                        tabs: GenericEditorRootTabsComponent,
                        localized: LocalizedElementComponent,
                        field: GenericEditorDynamicFieldComponent
                    }
                })
            ],
            providers: [
                GenericEditorFactoryService,
                EditorFieldMappingService,
                FetchEnumDataHandler,
                GenericEditorStackService,
                GenericEditorTabService,
                SeValidationMessageParser,
                GenericEditorStateBuilderService
            ],
            declarations: [
                GenericEditorDynamicFieldComponent,
                GenericEditorComponent$1,
                GenericEditorTabComponent,
                LocalizedElementComponent,
                GenericEditorFieldComponent,
                GenericEditorFieldMessagesComponent,
                GenericEditorFieldWrapperComponent,
                GenericEditorBreadcrumbComponent,
                FormBuilderDirective,
                ContentManager,
                GenericEditorRootTabsComponent,
                SubmitBtnDirective
            ],
            entryComponents: [
                GenericEditorComponent$1,
                GenericEditorTabComponent,
                LocalizedElementComponent,
                GenericEditorFieldComponent,
                GenericEditorFieldMessagesComponent,
                GenericEditorFieldWrapperComponent,
                GenericEditorBreadcrumbComponent
            ],
            exports: [GenericEditorComponent$1, GenericEditorWidgetModule, GenericEditorDropdownModule]
        })
    ], SeGenericEditorModule);
    return SeGenericEditorModule;
}());

/**
 * **Deprecated, since 2005, use {@link HasOperationPermissionDirective}.**
 *
 * Use this directive for AngularJS templates.
 */
var /* @ngInject */ LegacyHasOperationPermissionDirective = /** @class */ (function (_super) {
    __extends(/* @ngInject */ LegacyHasOperationPermissionDirective, _super);
    LegacyHasOperationPermissionDirective.$inject = ["systemEventService", "permissionService", "logService"];
    function /* @ngInject */ LegacyHasOperationPermissionDirective(systemEventService, permissionService, logService) {
        var _this = _super.call(this, systemEventService, permissionService, logService) || this;
        _this.isPermissionGrantedHandler = _this.getIsPermissionGrantedHandler();
        return _this;
    }
    /* @ngInject */ LegacyHasOperationPermissionDirective.prototype.$onInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    /* @ngInject */ LegacyHasOperationPermissionDirective.prototype.$onChanges = function (changes) {
        if (changes.hasOperationPermission && changes.hasOperationPermission.currentValue) {
            this.isPermissionGrantedFlag = false;
            _super.prototype.ngOnChanges.call(this, {
                hasOperationPermission: new core.SimpleChange(changes.hasOperationPermission.previousValue, changes.hasOperationPermission.currentValue, changes.hasOperationPermission.isFirstChange())
            });
        }
    };
    LegacyHasOperationPermissionDirective.prototype.$onChanges.$inject = ["changes"];
    /* @ngInject */ LegacyHasOperationPermissionDirective.prototype.$onDestroy = function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    /* @ngInject */ LegacyHasOperationPermissionDirective.prototype.getIsPermissionGrantedHandler = function () {
        var _this = this;
        return function (isPermissionGranted) {
            _this.isPermissionGrantedFlag = isPermissionGranted;
        };
    };
    /* @ngInject */ LegacyHasOperationPermissionDirective = __decorate([
        SeDirective({
            transclude: true,
            templateUrl: 'legacyHasOperationPermissionTemplate.html',
            controllerAs: 'ctrl',
            selector: '[has-operation-permission]',
            inputs: ['hasOperationPermission']
        }),
        __metadata("design:paramtypes", [SystemEventService,
            IPermissionService,
            utils.LogService])
    ], /* @ngInject */ LegacyHasOperationPermissionDirective);
    return /* @ngInject */ LegacyHasOperationPermissionDirective;
}(HasOperationPermissionBaseDirective));

window.__smartedit__.addDecoratorPayload("Component", "HeaderLanguageDropdownComponent", {
    selector: 'header-language-dropdown',
    template: "\n        <ul role=\"menu\" class=\"fd-menu__list se-language-selector\">\n            <li *ngIf=\"selectedLanguage\">\n                <a\n                    class=\"yToolbarActions__dropdown-element fd-menu__item se-language-selector__element--selected\"\n                >\n                    {{ selectedLanguage.name }}\n                </a>\n            </li>\n            <ng-container *ngFor=\"let language of items\">\n                <li *ngIf=\"selectedLanguage.isoCode !== language.value.isoCode\">\n                    <a\n                        class=\"yToolbarActions__dropdown-element fd-menu__item se-language-selector__element\"\n                        (click)=\"onSelectedLanguage(language)\"\n                    >\n                        {{ language.value.name }}\n                    </a>\n                </li>\n            </ng-container>\n        </ul>\n    "
});
var /* @ngInject */ HeaderLanguageDropdownComponent = /** @class */ (function (_super) {
    __extends(/* @ngInject */ HeaderLanguageDropdownComponent, _super);
    HeaderLanguageDropdownComponent.$inject = ["languageService", "crossFrameEventService"];
    function /* @ngInject */ HeaderLanguageDropdownComponent(languageService, crossFrameEventService) {
        var _this = _super.call(this, languageService, crossFrameEventService) || this;
        _this.languageService = languageService;
        _this.crossFrameEventService = crossFrameEventService;
        _this.languageSortStrategy = 'none';
        return _this;
    }
    /* @ngInject */ HeaderLanguageDropdownComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'header-language-dropdown',
            template: "\n        <ul role=\"menu\" class=\"fd-menu__list se-language-selector\">\n            <li *ngIf=\"selectedLanguage\">\n                <a\n                    class=\"yToolbarActions__dropdown-element fd-menu__item se-language-selector__element--selected\"\n                >\n                    {{ selectedLanguage.name }}\n                </a>\n            </li>\n            <ng-container *ngFor=\"let language of items\">\n                <li *ngIf=\"selectedLanguage.isoCode !== language.value.isoCode\">\n                    <a\n                        class=\"yToolbarActions__dropdown-element fd-menu__item se-language-selector__element\"\n                        (click)=\"onSelectedLanguage(language)\"\n                    >\n                        {{ language.value.name }}\n                    </a>\n                </li>\n            </ng-container>\n        </ul>\n    "
        }),
        __metadata("design:paramtypes", [LanguageService,
            CrossFrameEventService])
    ], /* @ngInject */ HeaderLanguageDropdownComponent);
    return /* @ngInject */ HeaderLanguageDropdownComponent;
}(utils.LanguageDropdown));

window.__smartedit__.addDecoratorPayload("Component", "ConfirmDialogComponent", {
    selector: 'se-confirm-dialog',
    template: "\n        <div id=\"confirmationModalDescription\">\n            {{ (modalData | async).description | translate: (descriptionPlaceholders | async) }}\n        </div>\n    "
});
var ConfirmDialogComponent = /** @class */ (function () {
    function ConfirmDialogComponent(modalManager) {
        this.modalManager = modalManager;
    }
    Object.defineProperty(ConfirmDialogComponent.prototype, "modalData", {
        get: function () {
            return this.modalManager.getModalData();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConfirmDialogComponent.prototype, "descriptionPlaceholders", {
        get: function () {
            return this.modalManager
                .getModalData()
                .pipe(operators.map(function (data) { return data.descriptionPlaceholders || {}; }));
        },
        enumerable: false,
        configurable: true
    });
    ConfirmDialogComponent = __decorate([
        core.Component({
            selector: 'se-confirm-dialog',
            template: "\n        <div id=\"confirmationModalDescription\">\n            {{ (modalData | async).description | translate: (descriptionPlaceholders | async) }}\n        </div>\n    "
        }),
        __metadata("design:paramtypes", [utils.FundamentalModalManagerService])
    ], ConfirmDialogComponent);
    return ConfirmDialogComponent;
}());

/* forbiddenNameSpaces angular.module:false */
/**
 * This object defines injectable Angular constants that store the default configuration and CSS class names used in the controller to define the rendering and animation of the collapsible container.
 */
var COLLAPSIBLE_CONTAINER_CONSTANTS = {
    /**
     * A JSON object defining the configuration applied by default to each collapsible container.
     *
     * @param expandedByDefault Specifies if the collapsible container is expanded by default.
     * @param iconAlignment Specifies if the expand-collapse icon is to be displayed to the left or to the right of the container header.
     * @param iconVisible Specifies if the expand-collapse icon is to be rendered.
     */
    DEFAULT_CONFIGURATION: COLLAPSIBLE_DEFAULT_CONFIGURATION,
    /**
     * A classname allowing for the display of a CSS-based icon positioned to the left of the collapsible container's header
     */
    ICON_LEFT: 'icon-left',
    /**
     * A classname allowing for the display of a CSS-based icon positioned to the right of the collapsible container's header
     */
    ICON_RIGHT: 'icon-right'
};
/**
 * # Module
 *
 * **Deprecated since 2005, use {@link CollapsibleContainerModule}.**
 *
 * This module defines the collapsible container Angular component and its associated constants and controller.
 *
 * ## Requires
 * - ui.bootstrap
 * - yLoDashModule
 *
 * ## Basic Implementation
 *
 * To define a new collapsible container, you must make some basic modifications to your Angular module and controller, as well
 * as to your HTML template. You can also customize the rendering of your collapsible container in your controller.
 *
 * ### Angular Module
 *
 * You must add the smarteditCommonsModule as a dependency to your Angular module.
 *
 *      angular.module('yourApp', ['smarteditCommonsModule']) { ... }
 *
 * ### HTML template
 *
 * To include HTML content in the collapsible panel, you must embed it within a `<y-collapsible-container> </y-collapsible-container>` tag.<br />
 *
 *    <y-collapsible-container>
 *       <header>
 *           Your title here
 *       </header>
 *      <content>
 *           Your content here
 *       </content>
 *    </y-collapsible-container>
 *
 * ### Angular Controller
 *
 * Within your Angular controller, you can define configurations which will get applied on the collapsible container.
 *
 *      angular.module('yourApp', ['sliderPanelModule'])
 *        .controller('yourController', function() {
 *                 ...
 *                 this.configuration = { ... };
 *                 ...
 *      });
 *
 * The configurations are passed and applied to the collapsible container through the binded variable 'configuration'
 *
 *      <y-collapsible-container data-configuration="$yourCtrl.configuration">
 *        ...
 *      </y-collapsible-container>
 *
 *
 * # Component
 *
 * **Deprecated since 2005, use {@link CollapsibleContainerComponent}.**
 *
 * The component allows for the dynamic display of any HTML content on a collapsible container.
 *
 * ### Parameters
 *
 * `configuration` - See {@link CollapsibleContainerConfig}
 *
 * `getApi` - Exposes the collapsible container's api object
 *
 * @deprecated
 */
var /* @ngInject */ YCollapsibleContainerComponent = /** @class */ (function () {
    function /* @ngInject */ YCollapsibleContainerComponent() {
        var _this = this;
        this.isExpanded = true;
        this.api = {
            isExpanded: function () { return _this.isExpanded; }
        };
    }
    /* @ngInject */ YCollapsibleContainerComponent.prototype.$onInit = function () {
        this.configuration = lodash.defaultsDeep(this.configuration, COLLAPSIBLE_CONTAINER_CONSTANTS.DEFAULT_CONFIGURATION);
        this.isExpanded = this.configuration.expandedByDefault
            ? this.configuration.expandedByDefault
            : false;
        if (typeof this.getApi === 'function') {
            this.getApi({
                $api: this.api
            });
        }
    };
    /* @ngInject */ YCollapsibleContainerComponent.prototype.getIconRelatedClassname = function () {
        if (this.configuration.iconVisible) {
            var key = "ICON_" + this.configuration.iconAlignment.toUpperCase();
            return COLLAPSIBLE_CONTAINER_CONSTANTS[key];
        }
        return '';
    };
    /* @ngInject */ YCollapsibleContainerComponent = __decorate([
        SeComponent({
            selector: 'y-collapsible-container',
            templateUrl: 'yCollapsibleContainer.html',
            transclude: {
                'collapsible-container-content': 'content',
                'collapsible-container-title': '?header'
            },
            inputs: ['configuration', 'getApi:&']
        })
    ], /* @ngInject */ YCollapsibleContainerComponent);
    return /* @ngInject */ YCollapsibleContainerComponent;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * An Injection Token used to retrieve information about "item" and "key" from within rendered component.
 */
var CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN = new core.InjectionToken('CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN');

window.__smartedit__.addDecoratorPayload("Component", "ClientPagedListCellComponent", {
    selector: 'se-client-paged-list-cell',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    template: "<ng-container *ngIf=\"key.component; else cellText\"><ng-container *ngComponentOutlet=\"key.component; injector: componentInjector\"></ng-container></ng-container><ng-template #cellText><span>{{ item[key.property] }}</span></ng-template>"
});
var /* @ngInject */ ClientPagedListCellComponent = /** @class */ (function () {
    ClientPagedListCellComponent.$inject = ["injector"];
    function /* @ngInject */ ClientPagedListCellComponent(injector) {
        this.injector = injector;
    }
    /* @ngInject */ ClientPagedListCellComponent.prototype.ngOnInit = function () {
        this.createComponentInjector();
    };
    /* @ngInject */ ClientPagedListCellComponent.prototype.createComponentInjector = function () {
        this.componentInjector = core.Injector.create({
            parent: this.injector,
            providers: [
                {
                    provide: CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN,
                    useValue: {
                        item: this.item,
                        key: this.key
                    }
                }
            ]
        });
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ ClientPagedListCellComponent.prototype, "item", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ ClientPagedListCellComponent.prototype, "key", void 0);
    /* @ngInject */ ClientPagedListCellComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-client-paged-list-cell',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            template: "<ng-container *ngIf=\"key.component; else cellText\"><ng-container *ngComponentOutlet=\"key.component; injector: componentInjector\"></ng-container></ng-container><ng-template #cellText><span>{{ item[key.property] }}</span></ng-template>"
        }),
        __metadata("design:paramtypes", [core.Injector])
    ], /* @ngInject */ ClientPagedListCellComponent);
    return /* @ngInject */ ClientPagedListCellComponent;
}());

window.__smartedit__.addDecoratorPayload("Component", "ClientPagedListComponent", {
    selector: 'se-client-paged-list',
    changeDetection: core.ChangeDetectionStrategy.OnPush,
    providers: [FilterByFieldPipe, StartFromPipe, common.SlicePipe],
    template: "<div class=\"fluid-container se-paged-list-result\"><p class=\"se-page-list__page-count\" *ngIf=\"displayCount\"><span>({{ totalItems }} {{ 'se.pagelist.countsearchresult' | translate }})</span></p><table class=\"se-paged-list-table table table-striped table-hover techne-table\"><thead><tr><th *ngFor=\"let key of keys; trackBy: keysTrackBy\" (click)=\"onOrderByColumn(key.property)\" [ngStyle]=\"{ 'width': columnWidth + '%' }\" class=\"se-paged-list__header\" [ngClass]=\"'se-paged-list__header-' + key.property\"><ng-container *ngIf=\"key.i18n\">{{ key.i18n | translate }} <span class=\"header-icon\" [hidden]=\"visibleSortingHeader !== key.property\" [ngClass]=\"{\n                          'sap-icon--navigation-down-arrow': headersSortingState[key.property],\n                          'sap-icon--navigation-up-arrow': !headersSortingState[key.property]\n                      }\"></span></ng-container></th><th class=\"se-paged-list__header\"></th><th class=\"se-paged-list__header\" *ngIf=\"dropdownItems\"></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of filteredItems\" class=\"techne-table-xs-right techne-table-xs-left se-paged-list-item\"><td *ngFor=\"let key of keys\" [ngClass]=\"'se-paged-list-item-' + key.property\"><se-client-paged-list-cell [item]=\"item\" [key]=\"key\"></se-client-paged-list-cell></td><td><se-tooltip *ngIf=\"item.icon\" [triggers]=\"['mouseenter', 'mouseleave']\" [placement]=\"'bottom'\" [title]=\"'se.icon.tooltip.visibility' | translate: { numberOfRestrictions: item.icon.numberOfRestrictions }\" [isChevronVisible]=\"true\"><img [src]=\"item.icon.src\" se-tooltip-trigger/></se-tooltip></td><ng-container *ngIf=\"dropdownItems\"><td *seHasOperationPermission=\"'se.edit.page'\" class=\"paged-list-table__body__td paged-list-table__body__td-menu\"><se-dropdown-menu [dropdownItems]=\"dropdownItems\" [selectedItem]=\"item\" class=\"pull-right\"></se-dropdown-menu></td></ng-container></tr></tbody></table><div class=\"pagination-container\"><se-pagination [totalItems]=\"totalItems < itemsPerPage ? itemsPerPage : totalItems\" [itemsPerPage]=\"itemsPerPage\" (onChange)=\"onCurrentPageChange($event)\" [currentPage]=\"currentPage\" class=\"pagination-lg\"></se-pagination></div></div>"
});
var /* @ngInject */ ClientPagedListComponent = /** @class */ (function () {
    ClientPagedListComponent.$inject = ["cdr", "filterByFieldPipe", "startFromPipe", "slicePipe"];
    function /* @ngInject */ ClientPagedListComponent(cdr, filterByFieldPipe, startFromPipe, slicePipe) {
        this.cdr = cdr;
        this.filterByFieldPipe = filterByFieldPipe;
        this.startFromPipe = startFromPipe;
        this.slicePipe = slicePipe;
        this.reversed = false;
        this.displayCount = false;
        this.totalItems = 0;
        this.currentPage = 1;
        this.headersSortingState = {};
    }
    /* @ngInject */ ClientPagedListComponent.prototype.ngOnChanges = function (changes) {
        var _a;
        if (changes.items || changes.query || changes.itemFilterKeys || changes.itemsPerPage) {
            if (changes.query) {
                this.currentPage = 1;
            }
            this.filteredItems = this.filterItems();
            this.totalItems =
                changes.query && changes.query.currentValue
                    ? this.filteredItems.length
                    : this.items.length;
        }
        if (changes.keys) {
            this.columnWidth = 100 / (this.keys.length || 1);
        }
        if (changes.reversed) {
            this.columnToggleReversed = this.reversed;
        }
        if (changes.sortBy) {
            this.headersSortingState = __assign(__assign({}, this.headersSortingState), (_a = {}, _a[this.sortBy] = this.columnToggleReversed, _a));
            this.visibleSortingHeader = this.sortBy;
            this.items = objectUtils.sortBy(this.items, this.sortBy, this.columnToggleReversed);
            this.filteredItems = this.filterItems();
        }
    };
    ClientPagedListComponent.prototype.ngOnChanges.$inject = ["changes"];
    /* @ngInject */ ClientPagedListComponent.prototype.keysTrackBy = function (_index, key) {
        return key.property;
    };
    ClientPagedListComponent.prototype.keysTrackBy.$inject = ["_index", "key"];
    /* @ngInject */ ClientPagedListComponent.prototype.onOrderByColumn = function (columnKeyProp) {
        this.columnToggleReversed = !this.columnToggleReversed;
        this.headersSortingState[columnKeyProp] = this.columnToggleReversed;
        this.visibleSortingHeader = columnKeyProp;
        this.items = objectUtils.sortBy(this.items, columnKeyProp, this.columnToggleReversed);
        this.filteredItems = this.filterItems();
        this.cdr.detectChanges();
    };
    ClientPagedListComponent.prototype.onOrderByColumn.$inject = ["columnKeyProp"];
    /* @ngInject */ ClientPagedListComponent.prototype.onCurrentPageChange = function (page) {
        this.currentPage = page;
        this.filteredItems = this.filterItems();
        this.cdr.detectChanges();
    };
    ClientPagedListComponent.prototype.onCurrentPageChange.$inject = ["page"];
    /* @ngInject */ ClientPagedListComponent.prototype.filterItems = function () {
        var filterKeys = this.itemFilterKeys || [];
        var filteredItems = this.filterByFieldPipe.transform(this.items, this.query, filterKeys);
        var startFromIndex = (this.currentPage - 1) * this.itemsPerPage;
        var startFromItems = this.startFromPipe.transform(filteredItems, startFromIndex);
        var slicedItems = this.slicePipe.transform(startFromItems, 0, this.itemsPerPage);
        return slicedItems;
    };
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "items", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "itemFilterKeys", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "keys", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Number)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "itemsPerPage", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "sortBy", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "reversed", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", String)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "query", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Object)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "displayCount", void 0);
    __decorate([
        core.Input(),
        __metadata("design:type", Array)
    ], /* @ngInject */ ClientPagedListComponent.prototype, "dropdownItems", void 0);
    /* @ngInject */ ClientPagedListComponent = __decorate([
        SeDowngradeComponent(),
        core.Component({
            selector: 'se-client-paged-list',
            changeDetection: core.ChangeDetectionStrategy.OnPush,
            providers: [FilterByFieldPipe, StartFromPipe, common.SlicePipe],
            template: "<div class=\"fluid-container se-paged-list-result\"><p class=\"se-page-list__page-count\" *ngIf=\"displayCount\"><span>({{ totalItems }} {{ 'se.pagelist.countsearchresult' | translate }})</span></p><table class=\"se-paged-list-table table table-striped table-hover techne-table\"><thead><tr><th *ngFor=\"let key of keys; trackBy: keysTrackBy\" (click)=\"onOrderByColumn(key.property)\" [ngStyle]=\"{ 'width': columnWidth + '%' }\" class=\"se-paged-list__header\" [ngClass]=\"'se-paged-list__header-' + key.property\"><ng-container *ngIf=\"key.i18n\">{{ key.i18n | translate }} <span class=\"header-icon\" [hidden]=\"visibleSortingHeader !== key.property\" [ngClass]=\"{\n                          'sap-icon--navigation-down-arrow': headersSortingState[key.property],\n                          'sap-icon--navigation-up-arrow': !headersSortingState[key.property]\n                      }\"></span></ng-container></th><th class=\"se-paged-list__header\"></th><th class=\"se-paged-list__header\" *ngIf=\"dropdownItems\"></th></tr></thead><tbody class=\"se-paged-list__table-body\"><tr *ngFor=\"let item of filteredItems\" class=\"techne-table-xs-right techne-table-xs-left se-paged-list-item\"><td *ngFor=\"let key of keys\" [ngClass]=\"'se-paged-list-item-' + key.property\"><se-client-paged-list-cell [item]=\"item\" [key]=\"key\"></se-client-paged-list-cell></td><td><se-tooltip *ngIf=\"item.icon\" [triggers]=\"['mouseenter', 'mouseleave']\" [placement]=\"'bottom'\" [title]=\"'se.icon.tooltip.visibility' | translate: { numberOfRestrictions: item.icon.numberOfRestrictions }\" [isChevronVisible]=\"true\"><img [src]=\"item.icon.src\" se-tooltip-trigger/></se-tooltip></td><ng-container *ngIf=\"dropdownItems\"><td *seHasOperationPermission=\"'se.edit.page'\" class=\"paged-list-table__body__td paged-list-table__body__td-menu\"><se-dropdown-menu [dropdownItems]=\"dropdownItems\" [selectedItem]=\"item\" class=\"pull-right\"></se-dropdown-menu></td></ng-container></tr></tbody></table><div class=\"pagination-container\"><se-pagination [totalItems]=\"totalItems < itemsPerPage ? itemsPerPage : totalItems\" [itemsPerPage]=\"itemsPerPage\" (onChange)=\"onCurrentPageChange($event)\" [currentPage]=\"currentPage\" class=\"pagination-lg\"></se-pagination></div></div>"
        }),
        __metadata("design:paramtypes", [core.ChangeDetectorRef,
            FilterByFieldPipe,
            StartFromPipe,
            common.SlicePipe])
    ], /* @ngInject */ ClientPagedListComponent);
    return /* @ngInject */ ClientPagedListComponent;
}());

/**
 * Provides a component to display a paginated list of items with custom renderers.
 *
 * Allows the user to search and sort the list.
 */
var ClientPagedListModule = /** @class */ (function () {
    function ClientPagedListModule() {
    }
    ClientPagedListModule = __decorate([
        core.NgModule({
            imports: [
                common.CommonModule,
                PaginationModule,
                FundamentalsModule,
                TooltipModule,
                DropdownMenuModule,
                HasOperationPermissionDirectiveModule,
                CompileHtmlModule,
                FilterByFieldPipeModule,
                StartFromPipeModule,
                utils.TranslationModule.forChild()
            ],
            entryComponents: [ClientPagedListComponent],
            declarations: [ClientPagedListComponent, ClientPagedListCellComponent],
            exports: [ClientPagedListComponent]
        })
    ], ClientPagedListModule);
    return ClientPagedListModule;
}());

/**
 * A HTTP request interceptor which intercepts all 'cmswebservices/catalogs' requests and adds the current catalog and version
 * from any URI which define the variables 'CURRENT_CONTEXT_CATALOG' and 'CURRENT_CONTEXT_CATALOG_VERSION' in the URL.
 */
var /* @ngInject */ ExperienceInterceptor = /** @class */ (function () {
    ExperienceInterceptor.$inject = ["sharedDataService", "stringUtils", "httpUtils"];
    function /* @ngInject */ ExperienceInterceptor(sharedDataService, stringUtils, httpUtils) {
        this.sharedDataService = sharedDataService;
        this.stringUtils = stringUtils;
        this.httpUtils = httpUtils;
    }
    /**
     * Interceptor method which gets called with a http config object, intercepts any 'cmswebservices/catalogs' requests and adds
     * the current catalog and version
     * from any URI which define the variables 'CURRENT_CONTEXT_CATALOG' and 'CURRENT_CONTEXT_CATALOG_VERSION' in the URL.
     * If the request URI contains any of 'PAGE_CONTEXT_SITE_ID', 'PAGE_CONTEXT_CATALOG' or 'PAGE_CONTEXT_CATALOG_VERSION',
     * then it is replaced by the siteId/catalogId/catalogVersion of the current page in context.
     *
     * The catalog name and catalog versions of the current experience and the page loaded are stored in the shared data service object called 'experience' during preview initialization
     * and here we retrieve those details and set it to headers.
     */
    /* @ngInject */ ExperienceInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        if (CMSWEBSERVICES_PATH.test(request.url)) {
            return rxjs.from(this.sharedDataService.get(EXPERIENCE_STORAGE_KEY)).pipe(operators.switchMap(function (data) {
                if (data) {
                    var keys = {};
                    keys.CONTEXT_SITE_ID_WITH_COLON = data.siteDescriptor.uid;
                    keys.CONTEXT_CATALOG_VERSION_WITH_COLON =
                        data.catalogDescriptor.catalogVersion;
                    keys.CONTEXT_CATALOG_WITH_COLON = data.catalogDescriptor.catalogId;
                    keys[CONTEXT_SITE_ID] = data.siteDescriptor.uid;
                    keys[CONTEXT_CATALOG_VERSION] = data.catalogDescriptor.catalogVersion;
                    keys[CONTEXT_CATALOG] = data.catalogDescriptor.catalogId;
                    keys[PAGE_CONTEXT_SITE_ID] = data.pageContext
                        ? data.pageContext.siteId
                        : data.siteDescriptor.uid;
                    keys[PAGE_CONTEXT_CATALOG_VERSION] = data.pageContext
                        ? data.pageContext.catalogVersion
                        : data.catalogDescriptor.catalogVersion;
                    keys[PAGE_CONTEXT_CATALOG] = data.pageContext
                        ? data.pageContext.catalogId
                        : data.catalogDescriptor.catalogId;
                    var newRequest = request.clone({
                        url: _this.stringUtils.replaceAll(request.url, keys),
                        params: request.params && typeof request.params === 'object'
                            ? _this.httpUtils.transformHttpParams(request.params, keys)
                            : request.params
                    });
                    return next.handle(newRequest);
                }
                return next.handle(request);
            }));
        }
        else {
            return next.handle(request);
        }
    };
    ExperienceInterceptor.prototype.intercept.$inject = ["request", "next"];
    /* @ngInject */ ExperienceInterceptor = __decorate([
        core.Injectable(),
        __metadata("design:paramtypes", [utils.ISharedDataService,
            utils.StringUtils,
            utils.HttpUtils])
    ], /* @ngInject */ ExperienceInterceptor);
    return /* @ngInject */ ExperienceInterceptor;
}());

var IAnimateService = /** @class */ (function () {
    function IAnimateService() {
    }
    IAnimateService.prototype.addClass = function (element, className, options) {
        return undefined;
    };
    IAnimateService.prototype.animate = function (element, from, to, className, options) {
        return undefined;
    };
    IAnimateService.prototype.cancel = function (animationPromise) {
        return undefined;
    };
    IAnimateService.prototype.closeAndFlush = function () {
        return undefined;
    };
    IAnimateService.prototype.enabled = function (element, value) {
        return false;
    };
    IAnimateService.prototype.enter = function (element, parentElement, afterElement, options) {
        return undefined;
    };
    IAnimateService.prototype.flush = function () {
        return undefined;
    };
    IAnimateService.prototype.leave = function (element, options) {
        return undefined;
    };
    IAnimateService.prototype.move = function (element, parentElement, afterElement) {
        return undefined;
    };
    IAnimateService.prototype.off = function (event, container, callback) {
        return undefined;
    };
    IAnimateService.prototype.on = function (event, container, callback) {
        return undefined;
    };
    IAnimateService.prototype.pin = function (element, parentElement) {
        return undefined;
    };
    IAnimateService.prototype.removeClass = function (element, className, options) {
        return undefined;
    };
    IAnimateService.prototype.setClass = function (element, add, remove, options) {
        return undefined;
    };
    return IAnimateService;
}());

var SmarteditConstantsModule = /** @class */ (function () {
    function SmarteditConstantsModule() {
    }
    SmarteditConstantsModule = __decorate([
        core.NgModule({
            providers: [
                {
                    provide: EXTENDED_VIEW_PORT_MARGIN_TOKEN,
                    useValue: EXTENDED_VIEW_PORT_MARGIN
                },
                {
                    provide: HEART_BEAT_TIMEOUT_THRESHOLD_MS_TOKEN,
                    useValue: HEART_BEAT_TIMEOUT_THRESHOLD_MS
                }
            ]
        })
    ], SmarteditConstantsModule);
    return SmarteditConstantsModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/**
 * Overrides AngularJS {@link https://docs.angularjs.org/api/ng/directive/ngHref ngHref} directive.
 *
 * When navigating from Angular route to AngularJS route, the controller that is registered for that AngularJS route is called twice (should be once).
 * It results in `ng-view` being rendered twice.
 *
 * @internal
 * @ignore
 */
angular$1.module('ngHrefDirectiveModule', [])
    .directive('ngHref', ["smarteditRoutingService", "logService", function (smarteditRoutingService, logService) {
    'ngInject';
    return {
        restrict: 'A',
        replace: false,
        link: function (scope, element, attrs) {
            var href = attrs.ngHref.replace('#!', ''); // remove shebang
            logService.debug('Navigating via overridden ngHref Directive', 'attrs.ngHref', attrs.ngHref, 'href', href);
            // Native directive does set the "href"
            element.attr('href', attrs.ngHref);
            element.bind('click', function (event) {
                event.preventDefault();
                smarteditRoutingService.go(href);
            });
        }
    };
}]);

var _a;
var gatewayProxiedAnnotationFactoryToken = new core.InjectionToken('gatewayProxiedAnnotationFactoryToKen');
var cachedAnnotationFactoryToken = new core.InjectionToken('cachedAnnotationFactoryToken');
var cacheConfigAnnotationFactoryToken = new core.InjectionToken('cacheConfigAnnotationFactoryToken');
var invalidateCacheAnnotationFactoryToken = new core.InjectionToken('invalidateCacheAnnotationFactoryToken');
var operationContextAnnotationFactoryToken = new core.InjectionToken('operationContextAnnotationFactoryToken');
/**
 * Module containing all the services shared within the smartedit commons.
 */
var SmarteditCommonsModule = /** @class */ (function () {
    function SmarteditCommonsModule() {
    }
    SmarteditCommonsModule = __decorate([
        core.NgModule({
            imports: [
                FundamentalsModule,
                upgrade.LocationUpgradeModule.config(),
                YjqueryModule,
                SeGenericEditorModule,
                WizardModule,
                SmarteditConstantsModule
            ],
            providers: [
                diBridgeUtils.upgradeProvider('$animate', IAnimateService),
                diBridgeUtils.upgradeProvider('$uibModal', IUIBootstrapModalService),
                diBridgeUtils.upgradeProvider('$uibModalStack', IUIBootstrapModalStackService),
                diBridgeUtils.upgradeProvider('$templateCache', ITemplateCacheService),
                SmarteditBootstrapGateway,
                AngularJSLazyDependenciesService,
                AngularJSBootstrapIndicatorService,
                LanguageServiceGateway,
                LanguageService,
                {
                    provide: utils.LANGUAGE_SERVICE,
                    useClass: LanguageService
                },
                TimerService,
                DiscardablePromiseUtils,
                moduleUtils.provideValues((_a = {
                        SSO_LOGOUT_ENTRY_POINT: SSO_LOGOUT_ENTRY_POINT,
                        SSO_AUTHENTICATION_ENTRY_POINT: SSO_AUTHENTICATION_ENTRY_POINT,
                        SSO_OAUTH2_AUTHENTICATION_ENTRY_POINT: SSO_OAUTH2_AUTHENTICATION_ENTRY_POINT,
                        SMARTEDIT_RESOURCE_URI_REGEXP: SMARTEDIT_RESOURCE_URI_REGEXP,
                        SMARTEDIT_ROOT: SMARTEDIT_ROOT,
                        SMARTEDIT_INNER_FILES: SMARTEDIT_INNER_FILES,
                        SMARTEDIT_INNER_FILES_POST: SMARTEDIT_INNER_FILES_POST
                    },
                    _a[utils.OPERATION_CONTEXT_TOKEN] = OPERATION_CONTEXT,
                    _a[utils.WHO_AM_I_RESOURCE_URI_TOKEN] = WHO_AM_I_RESOURCE_URI,
                    _a[utils.I18N_RESOURCE_URI_TOKEN] = I18N_RESOURCE_URI,
                    _a)),
                {
                    provide: http.HTTP_INTERCEPTORS,
                    useClass: ExperienceInterceptor,
                    multi: true
                },
                { provide: utils.IModalService, useClass: ModalService },
                { provide: utils.ISettingsService, useClass: SettingsService },
                SliderPanelServiceFactory,
                utils.LogService,
                utils.BrowserService,
                utils.FingerPrintingService,
                utils.CacheEngine,
                utils.CacheService,
                utils.CloneableUtils,
                CrossFrameEventService,
                /* forbiddenNameSpaces:false */
                {
                    provide: utils.LoginDialogResourceProvider,
                    useValue: SMARTEDIT_LOGIN_DIALOG_RESOURCES
                },
                {
                    provide: utils.LANGUAGE_SERVICE_CONSTANTS,
                    useValue: {
                        LANGUAGE_RESOURCE_URI: LANGUAGE_RESOURCE_URI,
                        I18N_LANGUAGES_RESOURCE_URI: I18N_LANGUAGES_RESOURCE_URI
                    }
                },
                {
                    provide: utils.EVENT_SERVICE,
                    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                    useFactory: function (crossFrameEventService) { return crossFrameEventService; },
                    deps: [CrossFrameEventService]
                },
                {
                    provide: CrossFrameEventServiceGateway.crossFrameEventServiceGatewayToken,
                    useClass: CrossFrameEventServiceGateway
                },
                utils.OperationContextService,
                utils.BooleanUtils,
                utils.CryptographicUtils,
                utils.FunctionsUtils,
                utils.HttpUtils,
                NodeUtils,
                utils.PromiseUtils,
                JQueryUtilsService,
                {
                    provide: utils.StringUtils,
                    useClass: StringUtils
                },
                StringUtils,
                utils.UrlUtils,
                {
                    provide: utils.WindowUtils,
                    useClass: WindowUtils
                },
                WindowUtils,
                SystemEventService,
                PriorityService,
                TestModeService,
                {
                    provide: utils.TESTMODESERVICE,
                    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                    useFactory: function (testModeService) { return testModeService; },
                    deps: [TestModeService]
                },
                GatewayFactory,
                GatewayProxy,
                InterceptorHelper,
                {
                    provide: gatewayProxiedAnnotationFactoryToken,
                    useFactory: GatewayProxiedAnnotationFactory,
                    deps: [GatewayProxy]
                },
                {
                    provide: cachedAnnotationFactoryToken,
                    useFactory: utils.CachedAnnotationFactory,
                    deps: [utils.CacheService]
                },
                {
                    provide: cacheConfigAnnotationFactoryToken,
                    useFactory: utils.CacheConfigAnnotationFactory,
                    deps: [utils.LogService]
                },
                {
                    provide: invalidateCacheAnnotationFactoryToken,
                    useFactory: utils.InvalidateCacheAnnotationFactory,
                    deps: [utils.CacheService]
                },
                {
                    provide: operationContextAnnotationFactoryToken,
                    useFactory: utils.OperationContextAnnotationFactory,
                    deps: [core.Injector, utils.OperationContextService, utils.OPERATION_CONTEXT_TOKEN]
                },
                utils.RestServiceFactory,
                PermissionsRestService,
                AuthorizationService,
                utils.FileMimeTypeService,
                utils.FileReaderService,
                utils.FileValidationService,
                utils.FileValidatorFactory,
                // TODO: remove when all consumers in cmssmartedit has replaced DI with import
                {
                    provide: 'seFileValidationServiceConstants',
                    useValue: utils.FILE_VALIDATION_CONFIG
                },
                moduleUtils.initialize(function (gatewayProxiedAnnotationFactory, cachedAnnotationFactory, cacheConfigAnnotationFactory, invalidateCacheAnnotationFactory, operationContextAnnotationFactory) {
                    diBridgeUtils.downgradeService('translateService', core$1.TranslateService);
                    diBridgeUtils.downgradeService('browserService', utils.BrowserService);
                    diBridgeUtils.downgradeService('httpBackendService', utils.HttpBackendService);
                    diBridgeUtils.downgradeService('operationContextService', utils.OperationContextService);
                    diBridgeUtils.downgradeService('retryInterceptor', utils.RetryInterceptor);
                    diBridgeUtils.downgradeService('httpErrorInterceptorService', utils.HttpErrorInterceptorService);
                    diBridgeUtils.downgradeService('fileMimeTypeService', utils.FileMimeTypeService);
                    diBridgeUtils.downgradeService('fileReaderService', utils.FileReaderService);
                    diBridgeUtils.downgradeService('fileValidationService', utils.FileValidationService);
                    diBridgeUtils.downgradeService('fileValidatorFactory', utils.FileValidatorFactory);
                    // TODO: remove when all consumers in cmssmartedit has replaced DI with import
                    diBridgeUtils.downgradeService('seFileValidationServiceConstants', null, 'seFileValidationServiceConstants');
                }, [
                    gatewayProxiedAnnotationFactoryToken,
                    cachedAnnotationFactoryToken,
                    cacheConfigAnnotationFactoryToken,
                    invalidateCacheAnnotationFactoryToken,
                    operationContextAnnotationFactoryToken
                ]),
                moduleUtils.bootstrap(function (retryInterceptor, defaultRetryStrategy, exponentialRetryStrategy, linearRetryStrategy, operationContextService) {
                    retryInterceptor
                        .register(utils.booleanUtils.areAllTruthy(operationContextInteractivePredicate, utils.retriableErrorPredicate), defaultRetryStrategy)
                        .register(utils.booleanUtils.areAllTruthy(operationContextNonInteractivePredicate, utils.retriableErrorPredicate), exponentialRetryStrategy)
                        .register(utils.booleanUtils.areAllTruthy(operationContextCMSPredicate, utils.timeoutErrorPredicate, utils.updatePredicate), exponentialRetryStrategy)
                        .register(utils.booleanUtils.areAllTruthy(operationContextToolingPredicate, utils.timeoutErrorPredicate, utils.updatePredicate), linearRetryStrategy);
                    operationContextService.register(LANGUAGE_RESOURCE_URI, OPERATION_CONTEXT.TOOLING);
                }, [
                    utils.RetryInterceptor,
                    utils.DefaultRetryStrategy,
                    utils.ExponentialRetryStrategy,
                    utils.LinearRetryStrategy,
                    utils.OperationContextService,
                    utils.LogService
                ])
            ]
        })
    ], SmarteditCommonsModule);
    return SmarteditCommonsModule;
}());

/*
 * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.
 */
/*
 * Backwards compatibility for partners and downstream teams
 * The deprecated modules below were moved to smarteditCommonsModule
 *
 * IMPORTANT: THE DEPRECATED MODULES WILL NOT BE AVAILABLE IN FUTURE RELEASES
 * @deprecated since 1811
 */
/* @internal */
function deprecatedSince1811() {
    angular$1.module('permissionServiceInterfaceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('FetchDataHandlerInterfaceModule', ['genericEditorServicesModule']);
    angular$1.module('fetchEnumDataHandlerModule', ['genericEditorServicesModule']);
    angular$1.module('dateFormatterModule', ['dateTimePickerModule']);
    angular$1.module('DropdownPopulatorInterface', ['dropdownPopulatorModule']);
    angular$1.module('optionsDropdownPopulatorModule', ['dropdownPopulatorModule']);
    angular$1.module('uriDropdownPopulatorModule', ['dropdownPopulatorModule']);
    angular$1.module('editorFieldMappingServiceModule', ['genericEditorServicesModule']);
    angular$1.module('genericEditorStackServiceModule', ['genericEditorServicesModule']);
    angular$1.module('genericEditorTabServiceModule', ['genericEditorServicesModule']);
    angular$1.module('seValidationMessageParserModule', ['genericEditorServicesModule']);
    angular$1.module('seGenericEditorFieldMessagesModule', ['genericEditorModule']);
    angular$1.module('genericEditorTabModule', ['genericEditorModule']);
    angular$1.module('genericEditorFieldModule', ['genericEditorModule']);
    angular$1.module('authorizationModule', ['legacySmarteditCommonsModule']);
}
function deprecatedSince1905() {
    angular$1.module('smarteditCommonsModule', ['legacySmarteditCommonsModule']);
    angular$1.module('browserServiceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('loadConfigModule', ['legacySmarteditCommonsModule']);
}
function deprecatedSince2005() {
    angular$1.module('yDataTableModule', ['legacySmarteditCommonsModule']);
    angular$1.module('interceptorHelperModule', ['legacySmarteditCommonsModule']);
    angular$1.module('yjqueryModule', ['legacySmarteditCommonsModule']);
    angular$1.module('includeReplaceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('timerModule', ['legacySmarteditCommonsModule']);
    angular$1.module('sliderPanelModule', ['legacySmarteditCommonsModule']);
    angular$1.module('toolbarInterfaceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('yPaginationModule', ['legacySmarteditCommonsModule']);
    angular$1.module('paginationFilterModule', ['legacySmarteditCommonsModule']);
    angular$1.module('yActionableSearchItemModule', [YSelectModule.name]);
    angular$1.module('genericEditorServicesModule', ['legacySmarteditCommonsModule']);
    angular$1.module('hasOperationPermissionModule', ['legacySmarteditCommonsModule']);
    angular$1.module('dragAndDropServiceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('recompileDomModule', ['legacySmarteditCommonsModule']);
    angular$1.module('yDropDownMenuModule', ['legacySmarteditCommonsModule']);
    angular$1.module('wizardServiceModule', ['legacySmarteditCommonsModule']);
    angular$1.module('yMessageModule', ['legacySmarteditCommonsModule']);
    angular$1.module('dynamicPagedListModule', ['legacySmarteditCommonsModule']);
    angular$1.module('commonsRestServiceModule', []);
}
function deprecatedSince2105() {
    angular$1.module('dropdownPopulatorModule', []);
}
var deprecate = function () {
    deprecatedSince1811();
    deprecatedSince1905();
    deprecatedSince2005();
    deprecatedSince2105();
};

/*!
 * ui-select
 * http://github.com/angular-ui/ui-select
 * Version: 0.19.8 - 2017-04-18T05:43:43.673Z
 * License: MIT
 */


(function () { 
var KEY = {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HOME: 36,
    END: 35,
    BACKSPACE: 8,
    DELETE: 46,
    COMMAND: 91,

    MAP: { 91 : "COMMAND", 8 : "BACKSPACE" , 9 : "TAB" , 13 : "ENTER" , 16 : "SHIFT" , 17 : "CTRL" , 18 : "ALT" , 19 : "PAUSEBREAK" , 20 : "CAPSLOCK" , 27 : "ESC" , 32 : "SPACE" , 33 : "PAGE_UP", 34 : "PAGE_DOWN" , 35 : "END" , 36 : "HOME" , 37 : "LEFT" , 38 : "UP" , 39 : "RIGHT" , 40 : "DOWN" , 43 : "+" , 44 : "PRINTSCREEN" , 45 : "INSERT" , 46 : "DELETE", 48 : "0" , 49 : "1" , 50 : "2" , 51 : "3" , 52 : "4" , 53 : "5" , 54 : "6" , 55 : "7" , 56 : "8" , 57 : "9" , 59 : ";", 61 : "=" , 65 : "A" , 66 : "B" , 67 : "C" , 68 : "D" , 69 : "E" , 70 : "F" , 71 : "G" , 72 : "H" , 73 : "I" , 74 : "J" , 75 : "K" , 76 : "L", 77 : "M" , 78 : "N" , 79 : "O" , 80 : "P" , 81 : "Q" , 82 : "R" , 83 : "S" , 84 : "T" , 85 : "U" , 86 : "V" , 87 : "W" , 88 : "X" , 89 : "Y" , 90 : "Z", 96 : "0" , 97 : "1" , 98 : "2" , 99 : "3" , 100 : "4" , 101 : "5" , 102 : "6" , 103 : "7" , 104 : "8" , 105 : "9", 106 : "*" , 107 : "+" , 109 : "-" , 110 : "." , 111 : "/", 112 : "F1" , 113 : "F2" , 114 : "F3" , 115 : "F4" , 116 : "F5" , 117 : "F6" , 118 : "F7" , 119 : "F8" , 120 : "F9" , 121 : "F10" , 122 : "F11" , 123 : "F12", 144 : "NUMLOCK" , 145 : "SCROLLLOCK" , 186 : ";" , 187 : "=" , 188 : "," , 189 : "-" , 190 : "." , 191 : "/" , 192 : "`" , 219 : "[" , 220 : "\\" , 221 : "]" , 222 : "'"
    },

    isControl: function (e) {
        var k = e.which;
        switch (k) {
        case KEY.COMMAND:
        case KEY.SHIFT:
        case KEY.CTRL:
        case KEY.ALT:
            return true;
        }

        if (e.metaKey || e.ctrlKey || e.altKey) return true;

        return false;
    },
    isFunctionKey: function (k) {
        k = k.which ? k.which : k;
        return k >= 112 && k <= 123;
    },
    isVerticalMovement: function (k){
      return ~[KEY.UP, KEY.DOWN].indexOf(k);
    },
    isHorizontalMovement: function (k){
      return ~[KEY.LEFT,KEY.RIGHT,KEY.BACKSPACE,KEY.DELETE].indexOf(k);
    },
    toSeparator: function (k) {
      var sep = {ENTER:"\n",TAB:"\t",SPACE:" "}[k];
      if (sep) return sep;
      // return undefined for special keys other than enter, tab or space.
      // no way to use them to cut strings.
      return KEY[k] ? undefined : k;
    }
  };

function isNil(value) {
  return angular.isUndefined(value) || value === null;
}

/**
 * Add querySelectorAll() to jqLite.
 *
 * jqLite find() is limited to lookups by tag name.
 * TODO This will change with future versions of AngularJS, to be removed when this happens
 *
 * See jqLite.find - why not use querySelectorAll? https://github.com/angular/angular.js/issues/3586
 * See feat(jqLite): use querySelectorAll instead of getElementsByTagName in jqLite.find https://github.com/angular/angular.js/pull/3598
 */
if (angular.element.prototype.querySelectorAll === undefined) {
  angular.element.prototype.querySelectorAll = function(selector) {
    return angular.element(this[0].querySelectorAll(selector));
  };
}

/**
 * Add closest() to jqLite.
 */
if (angular.element.prototype.closest === undefined) {
  angular.element.prototype.closest = function( selector) {
    var elem = this[0];
    var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;

    while (elem) {
      if (matchesSelector.bind(elem)(selector)) {
        return elem;
      } else {
        elem = elem.parentElement;
      }
    }
    return false;
  };
}

var latestId = 0;

var uis = angular.module('ui.select', [])

.constant('uiSelectConfig', {
  theme: 'bootstrap',
  searchEnabled: true,
  sortable: false,
  placeholder: '', // Empty by default, like HTML tag <select>
  refreshDelay: 1000, // In milliseconds
  closeOnSelect: true,
  skipFocusser: false,
  dropdownPosition: 'auto',
  removeSelected: true,
  resetSearchInput: true,
  generateId: function() {
    return latestId++;
  },
  appendToBody: false,
  spinnerEnabled: false,
  spinnerClass: 'glyphicon glyphicon-refresh ui-select-spin',
  backspaceReset: true
})

// See Rename minErr and make it accessible from outside https://github.com/angular/angular.js/issues/6913
.service('uiSelectMinErr', function() {
  var minErr = angular.$$minErr('ui.select');
  return function() {
    var error = minErr.apply(this, arguments);
    var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
    return new Error(message);
  };
})

// Recreates old behavior of ng-transclude. Used internally.
.directive('uisTranscludeAppend', function () {
  return {
    link: function (scope, element, attrs, ctrl, transclude) {
        transclude(scope, function (clone) {
          element.append(clone);
        });
      }
    };
})

/**
 * Highlights text that matches $select.search.
 *
 * Taken from AngularUI Bootstrap Typeahead
 * See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L340
 */
.filter('highlight', function() {
  function escapeRegexp(queryToEscape) {
    return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
  }

  return function(matchItem, query) {
    return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
  };
})

/**
 * A read-only equivalent of jQuery's offset function: http://api.jquery.com/offset/
 *
 * Taken from AngularUI Bootstrap Position:
 * See https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js#L70
 */
.factory('uisOffset',
  ['$document', '$window',
  function ($document, $window) {

  return function(element) {
    var boundingClientRect = element[0].getBoundingClientRect();
    return {
      width: boundingClientRect.width || element.prop('offsetWidth'),
      height: boundingClientRect.height || element.prop('offsetHeight'),
      top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
      left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
    };
  };
}]);

uis.directive('uiSelectChoices',
  ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window',
  function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {

  return {
    restrict: 'EA',
    require: '^uiSelect',
    replace: true,
    transclude: true,
    templateUrl: function(tElement) {
      // Needed so the uiSelect can detect the transcluded content
      tElement.addClass('ui-select-choices');

      // Gets theme attribute from parent (ui-select)
      var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
      return theme + '/choices.tpl.html';
    },

    compile: function(tElement, tAttrs) {

      if (!tAttrs.repeat) throw uiSelectMinErr('repeat', "Expected 'repeat' expression.");

      // var repeat = RepeatParser.parse(attrs.repeat);
      var groupByExp = tAttrs.groupBy;
      var groupFilterExp = tAttrs.groupFilter;

      if (groupByExp) {
        var groups = tElement.querySelectorAll('.ui-select-choices-group');
        if (groups.length !== 1) throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
        groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
      }

      var parserResult = RepeatParser.parse(tAttrs.repeat);

      var choices = tElement.querySelectorAll('.ui-select-choices-row');
      if (choices.length !== 1) {
        throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
      }

      choices.attr('ng-repeat', parserResult.repeatExpression(groupByExp))
             .attr('ng-if', '$select.open'); //Prevent unnecessary watches when dropdown is closed


      var rowsInner = tElement.querySelectorAll('.ui-select-choices-row-inner');
      if (rowsInner.length !== 1) {
        throw uiSelectMinErr('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
      }
      rowsInner.attr('uis-transclude-append', ''); //Adding uisTranscludeAppend directive to row element after choices element has ngRepeat

      // If IE8 then need to target rowsInner to apply the ng-click attr as choices will not capture the event.
      var clickTarget = $window.document.addEventListener ? choices : rowsInner;
      clickTarget.attr('ng-click', '$select.select(' + parserResult.itemName + ',$select.skipFocusser,$event)');

      return function link(scope, element, attrs, $select) {


        $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp); //Result ready at $select.parserResult
        $select.disableChoiceExpression = attrs.uiDisableChoice;
        $select.onHighlightCallback = attrs.onHighlight;
        $select.minimumInputLength = parseInt(attrs.minimumInputLength) || 0;
        $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;

        scope.$watch('$select.search', function(newValue) {
          if(newValue && !$select.open && $select.multiple) $select.activate(false, true);
          $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
          if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
            $select.refresh(attrs.refresh);
          } else {
            $select.items = [];
          }
        });

        attrs.$observe('refreshDelay', function() {
          // $eval() is needed otherwise we get a string instead of a number
          var refreshDelay = scope.$eval(attrs.refreshDelay);
          $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
        });

        scope.$watch('$select.open', function(open) {
          if (open) {
            tElement.attr('role', 'listbox');
            $select.refresh(attrs.refresh);
          } else {
            element.removeAttr('role');
          }
        });
      };
    }
  };
}]);

/**
 * Contains ui-select "intelligence".
 *
 * The goal is to limit dependency on the DOM whenever possible and
 * put as much logic in the controller (instead of the link functions) as possible so it can be easily tested.
 */
uis.controller('uiSelectCtrl',
  ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window',
  function($scope, $element, $timeout, $filter, $$uisDebounce, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {

  var ctrl = this;

  var EMPTY_SEARCH = '';

  ctrl.placeholder = uiSelectConfig.placeholder;
  ctrl.searchEnabled = uiSelectConfig.searchEnabled;
  ctrl.sortable = uiSelectConfig.sortable;
  ctrl.refreshDelay = uiSelectConfig.refreshDelay;
  ctrl.paste = uiSelectConfig.paste;
  ctrl.resetSearchInput = uiSelectConfig.resetSearchInput;
  ctrl.refreshing = false;
  ctrl.spinnerEnabled = uiSelectConfig.spinnerEnabled;
  ctrl.spinnerClass = uiSelectConfig.spinnerClass;
  ctrl.removeSelected = uiSelectConfig.removeSelected; //If selected item(s) should be removed from dropdown list
  ctrl.closeOnSelect = true; //Initialized inside uiSelect directive link function
  ctrl.skipFocusser = false; //Set to true to avoid returning focus to ctrl when item is selected
  ctrl.search = EMPTY_SEARCH;

  ctrl.activeIndex = 0; //Dropdown of choices
  ctrl.items = []; //All available choices

  ctrl.open = false;
  ctrl.focus = false;
  ctrl.disabled = false;
  ctrl.selected = undefined;

  ctrl.dropdownPosition = 'auto';

  ctrl.focusser = undefined; //Reference to input element used to handle focus events
  ctrl.multiple = undefined; // Initialized inside uiSelect directive link function
  ctrl.disableChoiceExpression = undefined; // Initialized inside uiSelectChoices directive link function
  ctrl.tagging = {isActivated: false, fct: undefined};
  ctrl.taggingTokens = {isActivated: false, tokens: undefined};
  ctrl.lockChoiceExpression = undefined; // Initialized inside uiSelectMatch directive link function
  ctrl.clickTriggeredSelect = false;
  ctrl.$filter = $filter;
  ctrl.$element = $element;

  // Use $injector to check for $animate and store a reference to it
  ctrl.$animate = (function () {
    try {
      return $injector.get('$animate');
    } catch (err) {
      // $animate does not exist
      return null;
    }
  })();

  ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
  if (ctrl.searchInput.length !== 1) {
    throw uiSelectMinErr('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", ctrl.searchInput.length);
  }

  ctrl.isEmpty = function() {
    return isNil(ctrl.selected) || ctrl.selected === '' || (ctrl.multiple && ctrl.selected.length === 0);
  };

  function _findIndex(collection, predicate, thisArg){
    if (collection.findIndex){
      return collection.findIndex(predicate, thisArg);
    } else {
      var list = Object(collection);
      var length = list.length >>> 0;
      var value;

      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return i;
        }
      }
      return -1;
    }
  }

  // Most of the time the user does not want to empty the search input when in typeahead mode
  function _resetSearchInput() {
    if (ctrl.resetSearchInput) {
      ctrl.search = EMPTY_SEARCH;
      //reset activeIndex
      if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
        ctrl.activeIndex = _findIndex(ctrl.items, function(item){
          return angular.equals(this, item);
        }, ctrl.selected);
      }
    }
  }

    function _groupsFilter(groups, groupNames) {
      var i, j, result = [];
      for(i = 0; i < groupNames.length ;i++){
        for(j = 0; j < groups.length ;j++){
          if(groups[j].name == [groupNames[i]]){
            result.push(groups[j]);
          }
        }
      }
      return result;
    }

  // When the user clicks on ui-select, displays the dropdown list
  ctrl.activate = function(initSearchValue, avoidReset) {
    if (!ctrl.disabled  && !ctrl.open) {
      if(!avoidReset) _resetSearchInput();

      $scope.$broadcast('uis:activate');
      ctrl.open = true;
      ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
      // ensure that the index is set to zero for tagging variants
      // that where first option is auto-selected
      if ( ctrl.activeIndex === -1 && ctrl.taggingLabel !== false ) {
        ctrl.activeIndex = 0;
      }

      var container = $element.querySelectorAll('.ui-select-choices-content');
      var searchInput = $element.querySelectorAll('.ui-select-search');
      if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {
        var animateHandler = function(elem, phase) {
          if (phase === 'start' && ctrl.items.length === 0) {
            // Only focus input after the animation has finished
            ctrl.$animate.off('removeClass', searchInput[0], animateHandler);
            $timeout(function () {
              ctrl.focusSearchInput(initSearchValue);
            });
          } else if (phase === 'close') {
            // Only focus input after the animation has finished
            ctrl.$animate.off('enter', container[0], animateHandler);
            $timeout(function () {
              ctrl.focusSearchInput(initSearchValue);
            });
          }
        };

        if (ctrl.items.length > 0) {
          ctrl.$animate.on('enter', container[0], animateHandler);
        } else {
          ctrl.$animate.on('removeClass', searchInput[0], animateHandler);
        }
      } else {
        $timeout(function () {
          ctrl.focusSearchInput(initSearchValue);
          if(!ctrl.tagging.isActivated && ctrl.items.length > 1) {
            _ensureHighlightVisible();
          }
        });
      }
    }
    else if (ctrl.open && !ctrl.searchEnabled) {
      // Close the selection if we don't have search enabled, and we click on the select again
      ctrl.close();
    }
  };

  ctrl.focusSearchInput = function (initSearchValue) {
    ctrl.search = initSearchValue || ctrl.search;
    ctrl.searchInput[0].focus();
  };

  ctrl.findGroupByName = function(name) {
    return ctrl.groups && ctrl.groups.filter(function(group) {
      return group.name === name;
    })[0];
  };

  ctrl.parseRepeatAttr = function(repeatAttr, groupByExp, groupFilterExp) {
    function updateGroups(items) {
      var groupFn = $scope.$eval(groupByExp);
      ctrl.groups = [];
      angular.forEach(items, function(item) {
        var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
        var group = ctrl.findGroupByName(groupName);
        if(group) {
          group.items.push(item);
        }
        else {
          ctrl.groups.push({name: groupName, items: [item]});
        }
      });
      if(groupFilterExp){
        var groupFilterFn = $scope.$eval(groupFilterExp);
        if( angular.isFunction(groupFilterFn)){
          ctrl.groups = groupFilterFn(ctrl.groups);
        } else if(angular.isArray(groupFilterFn)){
          ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
        }
      }
      ctrl.items = [];
      ctrl.groups.forEach(function(group) {
        ctrl.items = ctrl.items.concat(group.items);
      });
    }

    function setPlainItems(items) {
      ctrl.items = items || [];
    }

    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;

    ctrl.parserResult = RepeatParser.parse(repeatAttr);

    ctrl.isGrouped = !!groupByExp;
    ctrl.itemProperty = ctrl.parserResult.itemName;

    //If collection is an Object, convert it to Array

    var originalSource = ctrl.parserResult.source;

    //When an object is used as source, we better create an array and use it as 'source'
    var createArrayFromObject = function(){
      var origSrc = originalSource($scope);
      $scope.$uisSource = Object.keys(origSrc).map(function(v){
        var result = {};
        result[ctrl.parserResult.keyName] = v;
        result.value = origSrc[v];
        return result;
      });
    };

    if (ctrl.parserResult.keyName){ // Check for (key,value) syntax
      createArrayFromObject();
      ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
      $scope.$watch(originalSource, function(newVal, oldVal){
        if (newVal !== oldVal) createArrayFromObject();
      }, true);
    }

    ctrl.refreshItems = function (data){
      data = data || ctrl.parserResult.source($scope);
      var selectedItems = ctrl.selected;
      //TODO should implement for single mode removeSelected
      if (ctrl.isEmpty() || (angular.isArray(selectedItems) && !selectedItems.length) || !ctrl.multiple || !ctrl.removeSelected) {
        ctrl.setItemsFn(data);
      }else {
        if ( data !== undefined && data !== null ) {
          var filteredItems = data.filter(function(i) {
            return angular.isArray(selectedItems) ? selectedItems.every(function(selectedItem) {
              return !angular.equals(i, selectedItem);
            }) : !angular.equals(i, selectedItems);
          });
          ctrl.setItemsFn(filteredItems);
        }
      }
      if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up'){
        $scope.calculateDropdownPos();
      }
      $scope.$broadcast('uis:refresh');
    };

    // See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L259
    $scope.$watchCollection(ctrl.parserResult.source, function(items) {
      if (items === undefined || items === null) {
        // If the user specifies undefined or null => reset the collection
        // Special case: items can be undefined if the user did not initialized the collection on the scope
        // i.e $scope.addresses = [] is missing
        ctrl.items = [];
      } else {
        if (!angular.isArray(items)) {
          throw uiSelectMinErr('items', "Expected an array but got '{0}'.", items);
        } else {
          //Remove already selected items (ex: while searching)
          //TODO Should add a test
          ctrl.refreshItems(items);

          //update the view value with fresh data from items, if there is a valid model value
          if(angular.isDefined(ctrl.ngModel.$modelValue)) {
            ctrl.ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
          }
        }
      }
    });

  };

  var _refreshDelayPromise;

  /**
   * Typeahead mode: lets the user refresh the collection using his own function.
   *
   * See Expose $select.search for external / remote filtering https://github.com/angular-ui/ui-select/pull/31
   */
  ctrl.refresh = function(refreshAttr) {
    if (refreshAttr !== undefined) {
      // Debounce
      // See https://github.com/angular-ui/bootstrap/blob/0.10.0/src/typeahead/typeahead.js#L155
      // FYI AngularStrap typeahead does not have debouncing: https://github.com/mgcrea/angular-strap/blob/v2.0.0-rc.4/src/typeahead/typeahead.js#L177
      if (_refreshDelayPromise) {
        $timeout.cancel(_refreshDelayPromise);
      }
      _refreshDelayPromise = $timeout(function() {
        if ($scope.$select.search.length >= $scope.$select.minimumInputLength) {
          var refreshPromise = $scope.$eval(refreshAttr);
          if (refreshPromise && angular.isFunction(refreshPromise.then) && !ctrl.refreshing) {
            ctrl.refreshing = true;
            refreshPromise.finally(function() {
              ctrl.refreshing = false;
            });
          }
        }
      }, ctrl.refreshDelay);
    }
  };

  ctrl.isActive = function(itemScope) {
    if ( !ctrl.open ) {
      return false;
    }
    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
    var isActive =  itemIndex == ctrl.activeIndex;

    if ( !isActive || itemIndex < 0 ) {
      return false;
    }

    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
      itemScope.$eval(ctrl.onHighlightCallback);
    }

    return isActive;
  };

  var _isItemSelected = function (item) {
    return (ctrl.selected && angular.isArray(ctrl.selected) &&
        ctrl.selected.filter(function (selection) { return angular.equals(selection, item); }).length > 0);
  };

  var disabledItems = [];

  function _updateItemDisabled(item, isDisabled) {
    var disabledItemIndex = disabledItems.indexOf(item);
    if (isDisabled && disabledItemIndex === -1) {
      disabledItems.push(item);
    }

    if (!isDisabled && disabledItemIndex > -1) {
      disabledItems.splice(disabledItemIndex, 1);
    }
  }

  function _isItemDisabled(item) {
    return disabledItems.indexOf(item) > -1;
  }

  ctrl.isDisabled = function(itemScope) {

    if (!ctrl.open) return;

    var item = itemScope[ctrl.itemProperty];
    var itemIndex = ctrl.items.indexOf(item);
    var isDisabled = false;

    if (itemIndex >= 0 && (angular.isDefined(ctrl.disableChoiceExpression) || ctrl.multiple)) {

      if (item.isTag) return false;

      if (ctrl.multiple) {
        isDisabled = _isItemSelected(item);
      }

      if (!isDisabled && angular.isDefined(ctrl.disableChoiceExpression)) {
        isDisabled = !!(itemScope.$eval(ctrl.disableChoiceExpression));
      }

      _updateItemDisabled(item, isDisabled);
    }

    return isDisabled;
  };


  // When the user selects an item with ENTER or clicks the dropdown
  ctrl.select = function(item, skipFocusser, $event) {
    if (isNil(item) || !_isItemDisabled(item)) {

      if ( ! ctrl.items && ! ctrl.search && ! ctrl.tagging.isActivated) return;

      if (!item || !_isItemDisabled(item)) {
        // if click is made on existing item, prevent from tagging, ctrl.search does not matter
        ctrl.clickTriggeredSelect = false;
        if($event && ($event.type === 'click' || $event.type === 'touchend') && item)
          ctrl.clickTriggeredSelect = true;

        if(ctrl.tagging.isActivated && ctrl.clickTriggeredSelect === false) {
          // if taggingLabel is disabled and item is undefined we pull from ctrl.search
          if ( ctrl.taggingLabel === false ) {
            if ( ctrl.activeIndex < 0 ) {
              if (item === undefined) {
                item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
              }
              if (!item || angular.equals( ctrl.items[0], item ) ) {
                return;
              }
            } else {
              // keyboard nav happened first, user selected from dropdown
              item = ctrl.items[ctrl.activeIndex];
            }
          } else {
            // tagging always operates at index zero, taggingLabel === false pushes
            // the ctrl.search value without having it injected
            if ( ctrl.activeIndex === 0 ) {
              // ctrl.tagging pushes items to ctrl.items, so we only have empty val
              // for `item` if it is a detected duplicate
              if ( item === undefined ) return;

              // create new item on the fly if we don't already have one;
              // use tagging function if we have one
              if ( ctrl.tagging.fct !== undefined && typeof item === 'string' ) {
                item = ctrl.tagging.fct(item);
                if (!item) return;
              // if item type is 'string', apply the tagging label
              } else if ( typeof item === 'string' ) {
                // trim the trailing space
                item = item.replace(ctrl.taggingLabel,'').trim();
              }
            }
          }
          // search ctrl.selected for dupes potentially caused by tagging and return early if found
          if (_isItemSelected(item)) {
            ctrl.close(skipFocusser);
            return;
          }
        }
        _resetSearchInput();
        $scope.$broadcast('uis:select', item);

        if (ctrl.closeOnSelect) {
          ctrl.close(skipFocusser);
        }
      }
    }
  };

  // Closes the dropdown
  ctrl.close = function(skipFocusser) {
    if (!ctrl.open) return;
    if (ctrl.ngModel && ctrl.ngModel.$setTouched) ctrl.ngModel.$setTouched();
    ctrl.open = false;
    _resetSearchInput();
    $scope.$broadcast('uis:close', skipFocusser);

  };

  ctrl.setFocus = function(){
    if (!ctrl.focus) ctrl.focusInput[0].focus();
  };

  ctrl.clear = function($event) {
    ctrl.select(null);
    $event.stopPropagation();
    $timeout(function() {
      ctrl.focusser[0].focus();
    }, 0, false);
  };

  // Toggle dropdown
  ctrl.toggle = function(e) {
    if (ctrl.open) {
      ctrl.close();
      e.preventDefault();
      e.stopPropagation();
    } else {
      ctrl.activate();
    }
  };

  // Set default function for locked choices - avoids unnecessary
  // logic if functionality is not being used
  ctrl.isLocked = function () {
    return false;
  };

  $scope.$watch(function () {
    return angular.isDefined(ctrl.lockChoiceExpression) && ctrl.lockChoiceExpression !== "";
  }, _initaliseLockedChoices);

  function _initaliseLockedChoices(doInitalise) {
    if(!doInitalise) return;

    var lockedItems = [];

    function _updateItemLocked(item, isLocked) {
      var lockedItemIndex = lockedItems.indexOf(item);
      if (isLocked && lockedItemIndex === -1) {
        lockedItems.push(item);
        }

      if (!isLocked && lockedItemIndex > -1) {
        lockedItems.splice(lockedItemIndex, 1);
      }
    }

    function _isItemlocked(item) {
      return lockedItems.indexOf(item) > -1;
    }

    ctrl.isLocked = function (itemScope, itemIndex) {
      var isLocked = false,
          item = ctrl.selected[itemIndex];

      if(item) {
        if (itemScope) {
          isLocked = !!(itemScope.$eval(ctrl.lockChoiceExpression));
          _updateItemLocked(item, isLocked);
        } else {
          isLocked = _isItemlocked(item);
        }
      }

      return isLocked;
    };
  }


  var sizeWatch = null;
  var updaterScheduled = false;
  ctrl.sizeSearchInput = function() {

    var input = ctrl.searchInput[0],
        container = ctrl.$element[0],
        calculateContainerWidth = function() {
          // Return the container width only if the search input is visible
          return container.clientWidth * !!input.offsetParent;
        },
        updateIfVisible = function(containerWidth) {
          if (containerWidth === 0) {
            return false;
          }
          var inputWidth = containerWidth - input.offsetLeft;
          if (inputWidth < 50) inputWidth = containerWidth;
          ctrl.searchInput.css('width', inputWidth+'px');
          return true;
        };

    ctrl.searchInput.css('width', '10px');
    $timeout(function() { //Give tags time to render correctly
      if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
        sizeWatch = $scope.$watch(function() {
          if (!updaterScheduled) {
            updaterScheduled = true;
            $scope.$$postDigest(function() {
              updaterScheduled = false;
              if (updateIfVisible(calculateContainerWidth())) {
                sizeWatch();
                sizeWatch = null;
              }
            });
          }
        }, angular.noop);
      }
    });
  };

  function _handleDropDownSelection(key) {
    var processed = true;
    switch (key) {
      case KEY.DOWN:
        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
        else if (ctrl.activeIndex < ctrl.items.length - 1) {
          var idx = ++ctrl.activeIndex;
          while(_isItemDisabled(ctrl.items[idx]) && idx < ctrl.items.length) {
            ctrl.activeIndex = ++idx;
          }
        }
        break;
      case KEY.UP:
        var minActiveIndex = (ctrl.search.length === 0 && ctrl.tagging.isActivated) ? -1 : 0;
        if (!ctrl.open && ctrl.multiple) ctrl.activate(false, true); //In case its the search input in 'multiple' mode
        else if (ctrl.activeIndex > minActiveIndex) {
          var idxmin = --ctrl.activeIndex;
          while(_isItemDisabled(ctrl.items[idxmin]) && idxmin > minActiveIndex) {
            ctrl.activeIndex = --idxmin;
          }
        }
        break;
      case KEY.TAB:
        if (!ctrl.multiple || ctrl.open) ctrl.select(ctrl.items[ctrl.activeIndex], true);
        break;
      case KEY.ENTER:
        if(ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)){
          ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser); // Make sure at least one dropdown item is highlighted before adding if not in tagging mode
        } else {
          ctrl.activate(false, true); //In case its the search input in 'multiple' mode
        }
        break;
      case KEY.ESC:
        ctrl.close();
        break;
      default:
        processed = false;
    }
    return processed;
  }

  // Bind to keyboard shortcuts
  ctrl.searchInput.on('keydown', function(e) {

    var key = e.which;

    if (~[KEY.ENTER,KEY.ESC].indexOf(key)){
      e.preventDefault();
      e.stopPropagation();
    }

    $scope.$apply(function() {

      var tagged = false;

      if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
        if(!_handleDropDownSelection(key) && !ctrl.searchEnabled) {
          e.preventDefault();
          e.stopPropagation();
        }
        if ( ctrl.taggingTokens.isActivated ) {
          for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
            if ( ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode] ) {
              // make sure there is a new value to push via tagging
              if ( ctrl.search.length > 0 ) {
                tagged = true;
              }
            }
          }
          if ( tagged ) {
            $timeout(function() {
              ctrl.searchInput.triggerHandler('tagged');
              var newItem = ctrl.search.replace(KEY.MAP[e.keyCode],'').trim();
              if ( ctrl.tagging.fct ) {
                newItem = ctrl.tagging.fct( newItem );
              }
              if (newItem) ctrl.select(newItem, true);
            });
          }
        }
      }

    });

    if(KEY.isVerticalMovement(key) && ctrl.items.length > 0){
      _ensureHighlightVisible();
    }

    if (key === KEY.ENTER || key === KEY.ESC) {
      e.preventDefault();
      e.stopPropagation();
    }

  });

  ctrl.searchInput.on('paste', function (e) {
    var data;

    if (window.clipboardData && window.clipboardData.getData) { // IE
      data = window.clipboardData.getData('Text');
    } else {
      data = (e.originalEvent || e).clipboardData.getData('text/plain');
    }

    // Prepend the current input field text to the paste buffer.
    data = ctrl.search + data;

    if (data && data.length > 0) {
      // If tagging try to split by tokens and add items
      if (ctrl.taggingTokens.isActivated) {
        var items = [];
        for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {  // split by first token that is contained in data
          var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[i]) || ctrl.taggingTokens.tokens[i];
          if (data.indexOf(separator) > -1) {
            items = data.split(separator);
            break;  // only split by one token
          }
        }
        if (items.length === 0) {
          items = [data];
        }
        var oldsearch = ctrl.search;
        angular.forEach(items, function (item) {
          var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
          if (newItem) {
            ctrl.select(newItem, true);
          }
        });
        ctrl.search = oldsearch || EMPTY_SEARCH;
        e.preventDefault();
        e.stopPropagation();
      } else if (ctrl.paste) {
        ctrl.paste(data);
        ctrl.search = EMPTY_SEARCH;
        e.preventDefault();
        e.stopPropagation();
      }
    }
  });

  ctrl.searchInput.on('tagged', function() {
    $timeout(function() {
      _resetSearchInput();
    });
  });

  // See https://github.com/ivaynberg/select2/blob/3.4.6/select2.js#L1431
  function _ensureHighlightVisible() {
    var container = $element.querySelectorAll('.ui-select-choices-content');
    var choices = container.querySelectorAll('.ui-select-choices-row');
    if (choices.length < 1) {
      throw uiSelectMinErr('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
    }

    if (ctrl.activeIndex < 0) {
      return;
    }

    var highlighted = choices[ctrl.activeIndex];
    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
    var height = container[0].offsetHeight;

    if (posY > height) {
      container[0].scrollTop += posY - height;
    } else if (posY < highlighted.clientHeight) {
      if (ctrl.isGrouped && ctrl.activeIndex === 0)
        container[0].scrollTop = 0; //To make group header visible when going all the way up
      else
        container[0].scrollTop -= highlighted.clientHeight - posY;
    }
  }

  var onResize = $$uisDebounce(function() {
    ctrl.sizeSearchInput();
  }, 50);

  angular.element($window).bind('resize', onResize);

  $scope.$on('$destroy', function() {
    ctrl.searchInput.off('keyup keydown tagged blur paste');
    angular.element($window).off('resize', onResize);
  });

  $scope.$watch('$select.activeIndex', function(activeIndex) {
    if (activeIndex)
      $element.find('input').attr(
        'aria-activedescendant',
        'ui-select-choices-row-' + ctrl.generatedId + '-' + activeIndex);
  });

  $scope.$watch('$select.open', function(open) {
    if (!open)
      $element.find('input').removeAttr('aria-activedescendant');
  });
}]);

uis.directive('uiSelect',
  ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout',
  function($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {

  return {
    restrict: 'EA',
    templateUrl: function(tElement, tAttrs) {
      var theme = tAttrs.theme || uiSelectConfig.theme;
      return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
    },
    replace: true,
    transclude: true,
    require: ['uiSelect', '^ngModel'],
    scope: true,

    controller: 'uiSelectCtrl',
    controllerAs: '$select',
    compile: function(tElement, tAttrs) {

      // Allow setting ngClass on uiSelect
      var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
      if(match) {
        var combined = '{'+ match[1] +', '+ match[2] +'}';
        tAttrs.ngClass = combined;
        tElement.attr('ng-class', combined);
      }

      //Multiple or Single depending if multiple attribute presence
      if (angular.isDefined(tAttrs.multiple))
        tElement.append('<ui-select-multiple/>').removeAttr('multiple');
      else
        tElement.append('<ui-select-single/>');

      if (tAttrs.inputId)
        tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;

      return function(scope, element, attrs, ctrls, transcludeFn) {

        var $select = ctrls[0];
        var ngModel = ctrls[1];

        $select.generatedId = uiSelectConfig.generateId();
        $select.baseTitle = attrs.title || 'Select box';
        $select.focusserTitle = $select.baseTitle + ' focus';
        $select.focusserId = 'focusser-' + $select.generatedId;

        $select.closeOnSelect = function() {
          if (angular.isDefined(attrs.closeOnSelect)) {
            return $parse(attrs.closeOnSelect)();
          } else {
            return uiSelectConfig.closeOnSelect;
          }
        }();

        scope.$watch('skipFocusser', function() {
            var skipFocusser = scope.$eval(attrs.skipFocusser);
            $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;
        });

        $select.onSelectCallback = $parse(attrs.onSelect);
        $select.onRemoveCallback = $parse(attrs.onRemove);

        //Set reference to ngModel from uiSelectCtrl
        $select.ngModel = ngModel;

        $select.choiceGrouped = function(group){
          return $select.isGrouped && group && group.name;
        };

        if(attrs.tabindex){
          attrs.$observe('tabindex', function(value) {
            $select.focusInput.attr('tabindex', value);
            element.removeAttr('tabindex');
          });
        }

        scope.$watch(function () { return scope.$eval(attrs.searchEnabled); }, function(newVal) {
          $select.searchEnabled = newVal !== undefined ? newVal : uiSelectConfig.searchEnabled;
        });

        scope.$watch('sortable', function() {
            var sortable = scope.$eval(attrs.sortable);
            $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
        });

        attrs.$observe('backspaceReset', function() {
          // $eval() is needed otherwise we get a string instead of a boolean
          var backspaceReset = scope.$eval(attrs.backspaceReset);
          $select.backspaceReset = backspaceReset !== undefined ? backspaceReset : true;
        });

        attrs.$observe('limit', function() {
          //Limit the number of selections allowed
          $select.limit = (angular.isDefined(attrs.limit)) ? parseInt(attrs.limit, 10) : undefined;
        });

        scope.$watch('removeSelected', function() {
            var removeSelected = scope.$eval(attrs.removeSelected);
            $select.removeSelected = removeSelected !== undefined ? removeSelected : uiSelectConfig.removeSelected;
        });

        attrs.$observe('disabled', function() {
          // No need to use $eval() (thanks to ng-disabled) since we already get a boolean instead of a string
          $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
        });

        attrs.$observe('resetSearchInput', function() {
          // $eval() is needed otherwise we get a string instead of a boolean
          var resetSearchInput = scope.$eval(attrs.resetSearchInput);
          $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
        });

        attrs.$observe('paste', function() {
          $select.paste = scope.$eval(attrs.paste);
        });

        attrs.$observe('tagging', function() {
          if(attrs.tagging !== undefined)
          {
            // $eval() is needed otherwise we get a string instead of a boolean
            var taggingEval = scope.$eval(attrs.tagging);
            $select.tagging = {isActivated: true, fct: taggingEval !== true ? taggingEval : undefined};
          }
          else
          {
            $select.tagging = {isActivated: false, fct: undefined};
          }
        });

        attrs.$observe('taggingLabel', function() {
          if(attrs.tagging !== undefined )
          {
            // check eval for FALSE, in this case, we disable the labels
            // associated with tagging
            if ( attrs.taggingLabel === 'false' ) {
              $select.taggingLabel = false;
            }
            else
            {
              $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
            }
          }
        });

        attrs.$observe('taggingTokens', function() {
          if (attrs.tagging !== undefined) {
            var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [',','ENTER'];
            $select.taggingTokens = {isActivated: true, tokens: tokens };
          }
        });

        attrs.$observe('spinnerEnabled', function() {
          // $eval() is needed otherwise we get a string instead of a boolean
          var spinnerEnabled = scope.$eval(attrs.spinnerEnabled);
          $select.spinnerEnabled = spinnerEnabled !== undefined ? spinnerEnabled : uiSelectConfig.spinnerEnabled;
        });

        attrs.$observe('spinnerClass', function() {
          var spinnerClass = attrs.spinnerClass;
          $select.spinnerClass = spinnerClass !== undefined ? attrs.spinnerClass : uiSelectConfig.spinnerClass;
        });

        //Automatically gets focus when loaded
        if (angular.isDefined(attrs.autofocus)){
          $timeout(function(){
            $select.setFocus();
          });
        }

        //Gets focus based on scope event name (e.g. focus-on='SomeEventName')
        if (angular.isDefined(attrs.focusOn)){
          scope.$on(attrs.focusOn, function() {
              $timeout(function(){
                $select.setFocus();
              });
          });
        }

        function onDocumentClick(e) {
          if (!$select.open) return; //Skip it if dropdown is close

          var contains = false;

          if (window.jQuery) {
            // Firefox 3.6 does not support element.contains()
            // See Node.contains https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
            contains = window.jQuery.contains(element[0], e.target);
          } else {
            contains = element[0].contains(e.target);
          }

          if (!contains && !$select.clickTriggeredSelect) {
            var skipFocusser;
            if (!$select.skipFocusser) {
              //Will lose focus only with certain targets
              var focusableControls = ['input','button','textarea','select'];
              var targetController = angular.element(e.target).controller('uiSelect'); //To check if target is other ui-select
              skipFocusser = targetController && targetController !== $select; //To check if target is other ui-select
              if (!skipFocusser) skipFocusser =  ~focusableControls.indexOf(e.target.tagName.toLowerCase()); //Check if target is input, button or textarea
            } else {
              skipFocusser = true;
            }
            $select.close(skipFocusser);
            scope.$digest();
          }
          $select.clickTriggeredSelect = false;
        }

        // See Click everywhere but here event http://stackoverflow.com/questions/12931369
        $document.on('click', onDocumentClick);

        scope.$on('$destroy', function() {
          $document.off('click', onDocumentClick);
        });

        // Move transcluded elements to their correct position in main template
        transcludeFn(scope, function(clone) {
          // See Transclude in AngularJS http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html

          // One day jqLite will be replaced by jQuery and we will be able to write:
          // var transcludedElement = clone.filter('.my-class')
          // instead of creating a hackish DOM element:
          var transcluded = angular.element('<div>').append(clone);

          var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
          transcludedMatch.removeAttr('ui-select-match'); //To avoid loop in case directive as attr
          transcludedMatch.removeAttr('data-ui-select-match'); // Properly handle HTML5 data-attributes
          if (transcludedMatch.length !== 1) {
            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
          }
          element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);

          var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
          transcludedChoices.removeAttr('ui-select-choices'); //To avoid loop in case directive as attr
          transcludedChoices.removeAttr('data-ui-select-choices'); // Properly handle HTML5 data-attributes
          if (transcludedChoices.length !== 1) {
            throw uiSelectMinErr('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
          }
          element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);

          var transcludedNoChoice = transcluded.querySelectorAll('.ui-select-no-choice');
          transcludedNoChoice.removeAttr('ui-select-no-choice'); //To avoid loop in case directive as attr
          transcludedNoChoice.removeAttr('data-ui-select-no-choice'); // Properly handle HTML5 data-attributes
          if (transcludedNoChoice.length == 1) {
            element.querySelectorAll('.ui-select-no-choice').replaceWith(transcludedNoChoice);
          }
        });

        // Support for appending the select field to the body when its open
        var appendToBody = scope.$eval(attrs.appendToBody);
        if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
          scope.$watch('$select.open', function(isOpen) {
            if (isOpen) {
              positionDropdown();
            } else {
              resetDropdown();
            }
          });

          // Move the dropdown back to its original location when the scope is destroyed. Otherwise
          // it might stick around when the user routes away or the select field is otherwise removed
          scope.$on('$destroy', function() {
            resetDropdown();
          });
        }

        // Hold on to a reference to the .ui-select-container element for appendToBody support
        var placeholder = null,
            originalWidth = '';

        function positionDropdown() {
          // Remember the absolute position of the element
          var offset = uisOffset(element);

          // Clone the element into a placeholder element to take its original place in the DOM
          placeholder = angular.element('<div class="ui-select-placeholder"></div>');
          placeholder[0].style.width = offset.width + 'px';
          placeholder[0].style.height = offset.height + 'px';
          element.after(placeholder);

          // Remember the original value of the element width inline style, so it can be restored
          // when the dropdown is closed
          originalWidth = element[0].style.width;

          // Now move the actual dropdown element to the end of the body
          $document.find('body').append(element);

          element[0].style.position = 'absolute';
          element[0].style.left = offset.left + 'px';
          element[0].style.top = offset.top + 'px';
          element[0].style.width = offset.width + 'px';
        }

        function resetDropdown() {
          if (placeholder === null) {
            // The dropdown has not actually been display yet, so there's nothing to reset
            return;
          }

          // Move the dropdown element back to its original location in the DOM
          placeholder.replaceWith(element);
          placeholder = null;

          element[0].style.position = '';
          element[0].style.left = '';
          element[0].style.top = '';
          element[0].style.width = originalWidth;

          // Set focus back on to the moved element
          $select.setFocus();
        }

        // Hold on to a reference to the .ui-select-dropdown element for direction support.
        var dropdown = null,
            directionUpClassName = 'direction-up';

        // Support changing the direction of the dropdown if there isn't enough space to render it.
        scope.$watch('$select.open', function() {

          if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up'){
            scope.calculateDropdownPos();
          }

        });

        var setDropdownPosUp = function(offset, offsetDropdown){

          offset = offset || uisOffset(element);
          offsetDropdown = offsetDropdown || uisOffset(dropdown);

          dropdown[0].style.position = 'absolute';
          dropdown[0].style.top = (offsetDropdown.height * -1) + 'px';
          element.addClass(directionUpClassName);

        };

        var setDropdownPosDown = function(offset, offsetDropdown){

          element.removeClass(directionUpClassName);

          offset = offset || uisOffset(element);
          offsetDropdown = offsetDropdown || uisOffset(dropdown);

          dropdown[0].style.position = '';
          dropdown[0].style.top = '';

        };

        var calculateDropdownPosAfterAnimation = function() {
          // Delay positioning the dropdown until all choices have been added so its height is correct.
          $timeout(function() {
            if ($select.dropdownPosition === 'up') {
              //Go UP
              setDropdownPosUp();
            } else {
              //AUTO
              element.removeClass(directionUpClassName);

              var offset = uisOffset(element);
              var offsetDropdown = uisOffset(dropdown);

              //https://code.google.com/p/chromium/issues/detail?id=342307#c4
              var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop; //To make it cross browser (blink, webkit, IE, Firefox).

              // Determine if the direction of the dropdown needs to be changed.
              if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
                //Go UP
                setDropdownPosUp(offset, offsetDropdown);
              }else {
                //Go DOWN
                setDropdownPosDown(offset, offsetDropdown);
              }
            }

            // Display the dropdown once it has been positioned.
            dropdown[0].style.opacity = 1;
          });
        };

        var opened = false;
        
        scope.calculateDropdownPos = function() {
          if ($select.open) {
            dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');

            if (dropdown.length === 0) {
              return;
            }

           // Hide the dropdown so there is no flicker until $timeout is done executing.
           if ($select.search === '' && !opened) {
              dropdown[0].style.opacity = 0;
              opened = true;
           }

            if (!uisOffset(dropdown).height && $select.$animate && $select.$animate.on && $select.$animate.enabled(dropdown)) {
              var needsCalculated = true;

              $select.$animate.on('enter', dropdown, function (elem, phase) {
                if (phase === 'close' && needsCalculated) {
                  calculateDropdownPosAfterAnimation();
                  needsCalculated = false;
                }
              });
            } else {
              calculateDropdownPosAfterAnimation();
            }
          } else {
            if (dropdown === null || dropdown.length === 0) {
              return;
            }

            // Reset the position of the dropdown.
            dropdown[0].style.opacity = 0;
            dropdown[0].style.position = '';
            dropdown[0].style.top = '';
            element.removeClass(directionUpClassName);
          }
        };
      };
    }
  };
}]);

uis.directive('uiSelectMatch', ['uiSelectConfig', function(uiSelectConfig) {
  return {
    restrict: 'EA',
    require: '^uiSelect',
    replace: true,
    transclude: true,
    templateUrl: function(tElement) {
      // Needed so the uiSelect can detect the transcluded content
      tElement.addClass('ui-select-match');

      var parent = tElement.parent();
      // Gets theme attribute from parent (ui-select)
      var theme = getAttribute(parent, 'theme') || uiSelectConfig.theme;
      var multi = angular.isDefined(getAttribute(parent, 'multiple'));

      return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');      
    },
    link: function(scope, element, attrs, $select) {
      $select.lockChoiceExpression = attrs.uiLockChoice;
      attrs.$observe('placeholder', function(placeholder) {
        $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
      });

      function setAllowClear(allow) {
        $select.allowClear = (angular.isDefined(allow)) ? (allow === '') ? true : (allow.toLowerCase() === 'true') : false;
      }

      attrs.$observe('allowClear', setAllowClear);
      setAllowClear(attrs.allowClear);

      if($select.multiple){
        $select.sizeSearchInput();
      }

    }
  };

  function getAttribute(elem, attribute) {
    if (elem[0].hasAttribute(attribute))
      return elem.attr(attribute);

    if (elem[0].hasAttribute('data-' + attribute))
      return elem.attr('data-' + attribute);

    if (elem[0].hasAttribute('x-' + attribute))
      return elem.attr('x-' + attribute);
  }
}]);

uis.directive('uiSelectMultiple', ['uiSelectMinErr','$timeout', function(uiSelectMinErr, $timeout) {
  return {
    restrict: 'EA',
    require: ['^uiSelect', '^ngModel'],

    controller: ['$scope','$timeout', function($scope, $timeout){

      var ctrl = this,
          $select = $scope.$select,
          ngModel;

      if (angular.isUndefined($select.selected))
        $select.selected = [];

      //Wait for link fn to inject it
      $scope.$evalAsync(function(){ ngModel = $scope.ngModel; });

      ctrl.activeMatchIndex = -1;

      ctrl.updateModel = function(){
        ngModel.$setViewValue(Date.now()); //Set timestamp as a unique string to force changes
        ctrl.refreshComponent();
      };

      ctrl.refreshComponent = function(){
        //Remove already selected items
        //e.g. When user clicks on a selection, the selected array changes and
        //the dropdown should remove that item
        if($select.refreshItems){
          $select.refreshItems();
        }
        if($select.sizeSearchInput){
          $select.sizeSearchInput();
        }
      };

      // Remove item from multiple select
      ctrl.removeChoice = function(index){

        // if the choice is locked, don't remove it
        if($select.isLocked(null, index)) return false;

        var removedChoice = $select.selected[index];

        var locals = {};
        locals[$select.parserResult.itemName] = removedChoice;

        $select.selected.splice(index, 1);
        ctrl.activeMatchIndex = -1;
        $select.sizeSearchInput();

        // Give some time for scope propagation.
        $timeout(function(){
          $select.onRemoveCallback($scope, {
            $item: removedChoice,
            $model: $select.parserResult.modelMapper($scope, locals)
          });
        });

        ctrl.updateModel();

        return true;
      };

      ctrl.getPlaceholder = function(){
        //Refactor single?
        if($select.selected && $select.selected.length) return;
        return $select.placeholder;
      };


    }],
    controllerAs: '$selectMultiple',

    link: function(scope, element, attrs, ctrls) {

      var $select = ctrls[0];
      var ngModel = scope.ngModel = ctrls[1];
      var $selectMultiple = scope.$selectMultiple;

      //$select.selected = raw selected objects (ignoring any property binding)

      $select.multiple = true;

      //Input that will handle focus
      $select.focusInput = $select.searchInput;

      //Properly check for empty if set to multiple
      ngModel.$isEmpty = function(value) {
        return !value || value.length === 0;
      };

      //From view --> model
      ngModel.$parsers.unshift(function () {
        var locals = {},
            result,
            resultMultiple = [];
        for (var j = $select.selected.length - 1; j >= 0; j--) {
          locals = {};
          locals[$select.parserResult.itemName] = $select.selected[j];
          result = $select.parserResult.modelMapper(scope, locals);
          resultMultiple.unshift(result);
        }
        return resultMultiple;
      });

      // From model --> view
      ngModel.$formatters.unshift(function (inputValue) {
        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
            locals = {},
            result;
        if (!data) return inputValue;
        var resultMultiple = [];
        var checkFnMultiple = function(list, value){
          if (!list || !list.length) return;
          for (var p = list.length - 1; p >= 0; p--) {
            locals[$select.parserResult.itemName] = list[p];
            result = $select.parserResult.modelMapper(scope, locals);
            if($select.parserResult.trackByExp){
                var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
                var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
                if(propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName){
                  if(matches && matches.length>0 && result[matches[1]] == value[matches[1]]){
                      resultMultiple.unshift(list[p]);
                      return true;
                  }
                }
            }
            if (angular.equals(result,value)){
              resultMultiple.unshift(list[p]);
              return true;
            }
          }
          return false;
        };
        if (!inputValue) return resultMultiple; //If ngModel was undefined
        for (var k = inputValue.length - 1; k >= 0; k--) {
          //Check model array of currently selected items
          if (!checkFnMultiple($select.selected, inputValue[k])){
            //Check model array of all items available
            if (!checkFnMultiple(data, inputValue[k])){
              //If not found on previous lists, just add it directly to resultMultiple
              resultMultiple.unshift(inputValue[k]);
            }
          }
        }
        return resultMultiple;
      });

      //Watch for external model changes
      scope.$watchCollection(function(){ return ngModel.$modelValue; }, function(newValue, oldValue) {
        if (oldValue != newValue){
          //update the view value with fresh data from items, if there is a valid model value
          if(angular.isDefined(ngModel.$modelValue)) {
            ngModel.$modelValue = null; //Force scope model value and ngModel value to be out of sync to re-run formatters
          }
          $selectMultiple.refreshComponent();
        }
      });

      ngModel.$render = function() {
        // Make sure that model value is array
        if(!angular.isArray(ngModel.$viewValue)){
          // Have tolerance for null or undefined values
          if (isNil(ngModel.$viewValue)){
            ngModel.$viewValue = [];
          } else {
            throw uiSelectMinErr('multiarr', "Expected model value to be array but got '{0}'", ngModel.$viewValue);
          }
        }
        $select.selected = ngModel.$viewValue;
        $selectMultiple.refreshComponent();
        scope.$evalAsync(); //To force $digest
      };

      scope.$on('uis:select', function (event, item) {
        if($select.selected.length >= $select.limit) {
          return;
        }
        $select.selected.push(item);
        var locals = {};
        locals[$select.parserResult.itemName] = item;

        $timeout(function(){
          $select.onSelectCallback(scope, {
            $item: item,
            $model: $select.parserResult.modelMapper(scope, locals)
          });
        });
        $selectMultiple.updateModel();
      });

      scope.$on('uis:activate', function () {
        $selectMultiple.activeMatchIndex = -1;
      });

      scope.$watch('$select.disabled', function(newValue, oldValue) {
        // As the search input field may now become visible, it may be necessary to recompute its size
        if (oldValue && !newValue) $select.sizeSearchInput();
      });

      $select.searchInput.on('keydown', function(e) {
        var key = e.which;
        scope.$apply(function() {
          var processed = false;
          // var tagged = false; //Checkme
          if(KEY.isHorizontalMovement(key)){
            processed = _handleMatchSelection(key);
          }
          if (processed  && key != KEY.TAB) {
            //TODO Check si el tab selecciona aun correctamente
            //Crear test
            e.preventDefault();
            e.stopPropagation();
          }
        });
      });
      function _getCaretPosition(el) {
        if(angular.isNumber(el.selectionStart)) return el.selectionStart;
        // selectionStart is not supported in IE8 and we don't want hacky workarounds so we compromise
        else return el.value.length;
      }
      // Handles selected options in "multiple" mode
      function _handleMatchSelection(key){
        var caretPosition = _getCaretPosition($select.searchInput[0]),
            length = $select.selected.length,
            // none  = -1,
            first = 0,
            last  = length-1,
            curr  = $selectMultiple.activeMatchIndex,
            next  = $selectMultiple.activeMatchIndex+1,
            prev  = $selectMultiple.activeMatchIndex-1,
            newIndex = curr;

        if(caretPosition > 0 || ($select.search.length && key == KEY.RIGHT)) return false;

        $select.close();

        function getNewActiveMatchIndex(){
          switch(key){
            case KEY.LEFT:
              // Select previous/first item
              if(~$selectMultiple.activeMatchIndex) return prev;
              // Select last item
              else return last;
            case KEY.RIGHT:
              // Open drop-down
              if(!~$selectMultiple.activeMatchIndex || curr === last){
                $select.activate();
                return false;
              }
              // Select next/last item
              else return next;
            case KEY.BACKSPACE:
              // Remove selected item and select previous/first
              if(~$selectMultiple.activeMatchIndex){
                if($selectMultiple.removeChoice(curr)) {
                  return prev;
                } else {
                  return curr;
                }

              } else {
                // If nothing yet selected, select last item
                return last;
              }
            case KEY.DELETE:
              // Remove selected item and select next item
              if(~$selectMultiple.activeMatchIndex){
                $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                return curr;
              }
              else return false;
          }
        }

        newIndex = getNewActiveMatchIndex();

        if(!$select.selected.length || newIndex === false) $selectMultiple.activeMatchIndex = -1;
        else $selectMultiple.activeMatchIndex = Math.min(last,Math.max(first,newIndex));

        return true;
      }

      $select.searchInput.on('keyup', function(e) {

        if ( ! KEY.isVerticalMovement(e.which) ) {
          scope.$evalAsync( function () {
            $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
          });
        }
        // Push a "create new" item into array if there is a search string
        if ( $select.tagging.isActivated && $select.search.length > 0 ) {

          // return early with these keys
          if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which) ) {
            return;
          }
          // always reset the activeIndex to the first item when tagging
          $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
          // taggingLabel === false bypasses all of this
          if ($select.taggingLabel === false) return;

          var items = angular.copy( $select.items );
          var stashArr = angular.copy( $select.items );
          var newItem;
          var item;
          var hasTag = false;
          var dupeIndex = -1;
          var tagItems;
          var tagItem;

          // case for object tagging via transform `$select.tagging.fct` function
          if ( $select.tagging.fct !== undefined) {
            tagItems = $select.$filter('filter')(items,{'isTag': true});
            if ( tagItems.length > 0 ) {
              tagItem = tagItems[0];
            }
            // remove the first element, if it has the `isTag` prop we generate a new one with each keyup, shaving the previous
            if ( items.length > 0 && tagItem ) {
              hasTag = true;
              items = items.slice(1,items.length);
              stashArr = stashArr.slice(1,stashArr.length);
            }
            newItem = $select.tagging.fct($select.search);
            // verify the new tag doesn't match the value of a possible selection choice or an already selected item.
            if (
              stashArr.some(function (origItem) {
                 return angular.equals(origItem, newItem);
              }) ||
              $select.selected.some(function (origItem) {
                return angular.equals(origItem, newItem);
              })
            ) {
              scope.$evalAsync(function () {
                $select.activeIndex = 0;
                $select.items = items;
              });
              return;
            }
            if (newItem) newItem.isTag = true;
          // handle newItem string and stripping dupes in tagging string context
          } else {
            // find any tagging items already in the $select.items array and store them
            tagItems = $select.$filter('filter')(items,function (item) {
              return item.match($select.taggingLabel);
            });
            if ( tagItems.length > 0 ) {
              tagItem = tagItems[0];
            }
            item = items[0];
            // remove existing tag item if found (should only ever be one tag item)
            if ( item !== undefined && items.length > 0 && tagItem ) {
              hasTag = true;
              items = items.slice(1,items.length);
              stashArr = stashArr.slice(1,stashArr.length);
            }
            newItem = $select.search+' '+$select.taggingLabel;
            if ( _findApproxDupe($select.selected, $select.search) > -1 ) {
              return;
            }
            // verify the the tag doesn't match the value of an existing item from
            // the searched data set or the items already selected
            if ( _findCaseInsensitiveDupe(stashArr.concat($select.selected)) ) {
              // if there is a tag from prev iteration, strip it / queue the change
              // and return early
              if ( hasTag ) {
                items = stashArr;
                scope.$evalAsync( function () {
                  $select.activeIndex = 0;
                  $select.items = items;
                });
              }
              return;
            }
            if ( _findCaseInsensitiveDupe(stashArr) ) {
              // if there is a tag from prev iteration, strip it
              if ( hasTag ) {
                $select.items = stashArr.slice(1,stashArr.length);
              }
              return;
            }
          }
          if ( hasTag ) dupeIndex = _findApproxDupe($select.selected, newItem);
          // dupe found, shave the first item
          if ( dupeIndex > -1 ) {
            items = items.slice(dupeIndex+1,items.length-1);
          } else {
            items = [];
            if (newItem) items.push(newItem);
            items = items.concat(stashArr);
          }
          scope.$evalAsync( function () {
            $select.activeIndex = 0;
            $select.items = items;

            if ($select.isGrouped) {
              // update item references in groups, so that indexOf will work after angular.copy
              var itemsWithoutTag = newItem ? items.slice(1) : items;
              $select.setItemsFn(itemsWithoutTag);
              if (newItem) {
                // add tag item as a new group
                $select.items.unshift(newItem);
                $select.groups.unshift({name: '', items: [newItem], tagging: true});
              }
            }
          });
        }
      });
      function _findCaseInsensitiveDupe(arr) {
        if ( arr === undefined || $select.search === undefined ) {
          return false;
        }
        var hasDupe = arr.filter( function (origItem) {
          if ( $select.search.toUpperCase() === undefined || origItem === undefined ) {
            return false;
          }
          return origItem.toUpperCase() === $select.search.toUpperCase();
        }).length > 0;

        return hasDupe;
      }
      function _findApproxDupe(haystack, needle) {
        var dupeIndex = -1;
        if(angular.isArray(haystack)) {
          var tempArr = angular.copy(haystack);
          for (var i = 0; i <tempArr.length; i++) {
            // handle the simple string version of tagging
            if ( $select.tagging.fct === undefined ) {
              // search the array for the match
              if ( tempArr[i]+' '+$select.taggingLabel === needle ) {
              dupeIndex = i;
              }
            // handle the object tagging implementation
            } else {
              var mockObj = tempArr[i];
              if (angular.isObject(mockObj)) {
                mockObj.isTag = true;
              }
              if ( angular.equals(mockObj, needle) ) {
                dupeIndex = i;
              }
            }
          }
        }
        return dupeIndex;
      }

      $select.searchInput.on('blur', function() {
        $timeout(function() {
          $selectMultiple.activeMatchIndex = -1;
        });
      });

    }
  };
}]);

uis.directive('uiSelectNoChoice',
    ['uiSelectConfig', function (uiSelectConfig) {
        return {
            restrict: 'EA',
            require: '^uiSelect',
            replace: true,
            transclude: true,
            templateUrl: function (tElement) {
                // Needed so the uiSelect can detect the transcluded content
                tElement.addClass('ui-select-no-choice');
      
                // Gets theme attribute from parent (ui-select)
                var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
                return theme + '/no-choice.tpl.html';
            }
        };
    }]);

uis.directive('uiSelectSingle', ['$timeout','$compile', function($timeout, $compile) {
  return {
    restrict: 'EA',
    require: ['^uiSelect', '^ngModel'],
    link: function(scope, element, attrs, ctrls) {

      var $select = ctrls[0];
      var ngModel = ctrls[1];

      //From view --> model
      ngModel.$parsers.unshift(function (inputValue) {
        // Keep original value for undefined and null
        if (isNil(inputValue)) {
          return inputValue;
        }

        var locals = {},
            result;
        locals[$select.parserResult.itemName] = inputValue;
        result = $select.parserResult.modelMapper(scope, locals);
        return result;
      });

      //From model --> view
      ngModel.$formatters.unshift(function (inputValue) {
        // Keep original value for undefined and null
        if (isNil(inputValue)) {
          return inputValue;
        }

        var data = $select.parserResult && $select.parserResult.source (scope, { $select : {search:''}}), //Overwrite $search
            locals = {},
            result;
        if (data){
          var checkFnSingle = function(d){
            locals[$select.parserResult.itemName] = d;
            result = $select.parserResult.modelMapper(scope, locals);
            return result === inputValue;
          };
          //If possible pass same object stored in $select.selected
          if ($select.selected && checkFnSingle($select.selected)) {
            return $select.selected;
          }
          for (var i = data.length - 1; i >= 0; i--) {
            if (checkFnSingle(data[i])) return data[i];
          }
        }
        return inputValue;
      });

      //Update viewValue if model change
      scope.$watch('$select.selected', function(newValue) {
        if (ngModel.$viewValue !== newValue) {
          ngModel.$setViewValue(newValue);
        }
      });

      ngModel.$render = function() {
        $select.selected = ngModel.$viewValue;
      };

      scope.$on('uis:select', function (event, item) {
        $select.selected = item;
        var locals = {};
        locals[$select.parserResult.itemName] = item;

        $timeout(function() {
          $select.onSelectCallback(scope, {
            $item: item,
            $model: isNil(item) ? item : $select.parserResult.modelMapper(scope, locals)
          });
        });
      });

      scope.$on('uis:close', function (event, skipFocusser) {
        $timeout(function(){
          $select.focusser.prop('disabled', false);
          if (!skipFocusser) $select.focusser[0].focus();
        },0,false);
      });

      scope.$on('uis:activate', function () {
        focusser.prop('disabled', true); //Will reactivate it on .close()
      });

      //Idea from: https://github.com/ivaynberg/select2/blob/79b5bf6db918d7560bdd959109b7bcfb47edaf43/select2.js#L1954
      var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />");
      $compile(focusser)(scope);
      $select.focusser = focusser;

      //Input that will handle focus
      $select.focusInput = focusser;

      element.parent().append(focusser);
      focusser.bind("focus", function(){
        scope.$evalAsync(function(){
          $select.focus = true;
        });
      });
      focusser.bind("blur", function(){
        scope.$evalAsync(function(){
          $select.focus = false;
        });
      });
      focusser.bind("keydown", function(e){

        if (e.which === KEY.BACKSPACE && $select.backspaceReset !== false) {
          e.preventDefault();
          e.stopPropagation();
          $select.select(undefined);
          scope.$apply();
          return;
        }

        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
          return;
        }

        if (e.which == KEY.DOWN  || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE){
          e.preventDefault();
          e.stopPropagation();
          $select.activate();
        }

        scope.$digest();
      });

      focusser.bind("keyup input", function(e){

        if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
          return;
        }

        $select.activate(focusser.val()); //User pressed some regular key, so we pass it to the search input
        focusser.val('');
        scope.$digest();

      });


    }
  };
}]);

// Make multiple matches sortable
uis.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function($timeout, uiSelectConfig, uiSelectMinErr) {
  return {
    require: ['^^uiSelect', '^ngModel'],
    link: function(scope, element, attrs, ctrls) {
      if (scope[attrs.uiSelectSort] === null) {
        throw uiSelectMinErr('sort', 'Expected a list to sort');
      }

      var $select = ctrls[0];
      var $ngModel = ctrls[1];

      var options = angular.extend({
          axis: 'horizontal'
        },
        scope.$eval(attrs.uiSelectSortOptions));

      var axis = options.axis;
      var draggingClassName = 'dragging';
      var droppingClassName = 'dropping';
      var droppingBeforeClassName = 'dropping-before';
      var droppingAfterClassName = 'dropping-after';

      scope.$watch(function(){
        return $select.sortable;
      }, function(newValue){
        if (newValue) {
          element.attr('draggable', true);
        } else {
          element.removeAttr('draggable');
        }
      });

      element.on('dragstart', function(event) {
        element.addClass(draggingClassName);

        (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());
      });

      element.on('dragend', function() {
        removeClass(draggingClassName);
      });

      var move = function(from, to) {
        /*jshint validthis: true */
        this.splice(to, 0, this.splice(from, 1)[0]);
      };

      var removeClass = function(className) {
        angular.forEach($select.$element.querySelectorAll('.' + className), function(el){
          angular.element(el).removeClass(className);
        });
      };

      var dragOverHandler = function(event) {
        event.preventDefault();

        var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);

        if (offset < (this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2)) {
          removeClass(droppingAfterClassName);
          element.addClass(droppingBeforeClassName);

        } else {
          removeClass(droppingBeforeClassName);
          element.addClass(droppingAfterClassName);
        }
      };

      var dropTimeout;

      var dropHandler = function(event) {
        event.preventDefault();

        var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);

        // prevent event firing multiple times in firefox
        $timeout.cancel(dropTimeout);
        dropTimeout = $timeout(function() {
          _dropHandler(droppedItemIndex);
        }, 20);
      };

      var _dropHandler = function(droppedItemIndex) {
        var theList = scope.$eval(attrs.uiSelectSort);
        var itemToMove = theList[droppedItemIndex];
        var newIndex = null;

        if (element.hasClass(droppingBeforeClassName)) {
          if (droppedItemIndex < scope.$index) {
            newIndex = scope.$index - 1;
          } else {
            newIndex = scope.$index;
          }
        } else {
          if (droppedItemIndex < scope.$index) {
            newIndex = scope.$index;
          } else {
            newIndex = scope.$index + 1;
          }
        }

        move.apply(theList, [droppedItemIndex, newIndex]);

        $ngModel.$setViewValue(Date.now());

        scope.$apply(function() {
          scope.$emit('uiSelectSort:change', {
            array: theList,
            item: itemToMove,
            from: droppedItemIndex,
            to: newIndex
          });
        });

        removeClass(droppingClassName);
        removeClass(droppingBeforeClassName);
        removeClass(droppingAfterClassName);

        element.off('drop', dropHandler);
      };

      element.on('dragenter', function() {
        if (element.hasClass(draggingClassName)) {
          return;
        }

        element.addClass(droppingClassName);

        element.on('dragover', dragOverHandler);
        element.on('drop', dropHandler);
      });

      element.on('dragleave', function(event) {
        if (event.target != element) {
          return;
        }

        removeClass(droppingClassName);
        removeClass(droppingBeforeClassName);
        removeClass(droppingAfterClassName);

        element.off('dragover', dragOverHandler);
        element.off('drop', dropHandler);
      });
    }
  };
}]);

/**
 * Debounces functions
 *
 * Taken from UI Bootstrap $$debounce source code
 * See https://github.com/angular-ui/bootstrap/blob/master/src/debounce/debounce.js
 *
 */
uis.factory('$$uisDebounce', ['$timeout', function($timeout) {
  return function(callback, debounceTime) {
    var timeoutPromise;

    return function() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }

      timeoutPromise = $timeout(function() {
        callback.apply(self, args);
      }, debounceTime);
    };
  };
}]);

uis.directive('uisOpenClose', ['$parse', '$timeout', function ($parse, $timeout) {
  return {
    restrict: 'A',
    require: 'uiSelect',
    link: function (scope, element, attrs, $select) {
      $select.onOpenCloseCallback = $parse(attrs.uisOpenClose);

      scope.$watch('$select.open', function (isOpen, previousState) {
        if (isOpen !== previousState) {
          $timeout(function () {
            $select.onOpenCloseCallback(scope, {
              isOpen: isOpen
            });
          });
        }
      });
    }
  };
}]);

/**
 * Parses "repeat" attribute.
 *
 * Taken from AngularJS ngRepeat source code
 * See https://github.com/angular/angular.js/blob/v1.2.15/src/ng/directive/ngRepeat.js#L211
 *
 * Original discussion about parsing "repeat" attribute instead of fully relying on ng-repeat:
 * https://github.com/angular-ui/ui-select/commit/5dd63ad#commitcomment-5504697
 */

uis.service('uisRepeatParser', ['uiSelectMinErr','$parse', function(uiSelectMinErr, $parse) {
  var self = this;

  /**
   * Example:
   * expression = "address in addresses | filter: {street: $select.search} track by $index"
   * itemName = "address",
   * source = "addresses | filter: {street: $select.search}",
   * trackByExp = "$index",
   */
  self.parse = function(expression) {


    var match;
    //var isObjectCollection = /\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)/.test(expression);
    // If an array is used as collection

    // if (isObjectCollection){
    // 000000000000000000000000000000111111111000000000000000222222222222220033333333333333333333330000444444444444444444000000000000000055555555555000000000000000000000066666666600000000
    match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);

    // 1 Alias
    // 2 Item
    // 3 Key on (key,value)
    // 4 Value on (key,value)
    // 5 Source expression (including filters)
    // 6 Track by

    if (!match) {
      throw uiSelectMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
              expression);
    }
    
    var source = match[5], 
        filters = '';

    // When using (key,value) ui-select requires filters to be extracted, since the object
    // is converted to an array for $select.items 
    // (in which case the filters need to be reapplied)
    if (match[3]) {
      // Remove any enclosing parenthesis
      source = match[5].replace(/(^\()|(\)$)/g, '');
      // match all after | but not after ||
      var filterMatch = match[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/);
      if(filterMatch && filterMatch[1].trim()) {
        filters = filterMatch[1];
        source = source.replace(filters, '');
      }      
    }

    return {
      itemName: match[4] || match[2], // (lhs) Left-hand side,
      keyName: match[3], //for (key, value) syntax
      source: $parse(source),
      filters: filters,
      trackByExp: match[6],
      modelMapper: $parse(match[1] || match[4] || match[2]),
      repeatExpression: function (grouped) {
        var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
        if (this.trackByExp) {
          expression += ' track by ' + this.trackByExp;
        }
        return expression;
      } 
    };

  };

  self.getGroupNgRepeatExpression = function() {
    return '$group in $select.groups track by $group.name';
  };

}]);

}());
angular.module("ui.select").run(["$templateCache", function($templateCache) {$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" ng-show=\"$select.open && $select.items.length > 0\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><span class=\"ui-select-choices-row-inner\"></span></div></li></ul>");
$templateCache.put("bootstrap/match-multiple.tpl.html","<span class=\"ui-select-match\"><span ng-repeat=\"$item in $select.selected track by $index\"><span class=\"ui-select-match-item btn btn-default btn-xs\" tabindex=\"-1\" type=\"button\" ng-disabled=\"$select.disabled\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span class=\"close ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&nbsp;&times;</span> <span uis-transclude-append=\"\"></span></span></span></span>");
$templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open && $select.searchEnabled\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\" ng-click=\"$select.toggle($event)\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i></a></span></div>");
$templateCache.put("bootstrap/no-choice.tpl.html","<ul class=\"ui-select-no-choice dropdown-menu\" ng-show=\"$select.items.length == 0\"><li ng-transclude=\"\"></li></ul>");
$templateCache.put("bootstrap/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control\" ng-class=\"{open: $select.open}\"><div><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" class=\"ui-select-search input-xs\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" ng-model=\"$select.search\" role=\"combobox\" aria-expanded=\"{{$select.open}}\" aria-label=\"{{$select.baseTitle}}\" ng-class=\"{\'spinner\': $select.refreshing}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
$templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><span ng-show=\"$select.open && $select.refreshing && $select.spinnerEnabled\" class=\"ui-select-refreshing {{$select.spinnerClass}}\"></span> <input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" class=\"form-control ui-select-search\" ng-class=\"{ \'ui-select-search-hidden\' : !$select.searchEnabled }\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.open\"><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
$templateCache.put("select2/choices.tpl.html","<ul tabindex=\"-1\" class=\"ui-select-choices ui-select-choices-content select2-results\"><li class=\"ui-select-choices-group\" ng-class=\"{\'select2-result-with-children\': $select.choiceGrouped($group) }\"><div ng-show=\"$select.choiceGrouped($group)\" class=\"ui-select-choices-group-label select2-result-label\" ng-bind=\"$group.name\"></div><ul id=\"ui-select-choices-{{ $select.generatedId }}\" ng-class=\"{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }\"><li role=\"option\" ng-attr-id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}\"><div class=\"select2-result-label ui-select-choices-row-inner\"></div></li></ul></li></ul>");
$templateCache.put("select2/match-multiple.tpl.html","<span class=\"ui-select-match\"><li class=\"ui-select-match-item select2-search-choice\" ng-repeat=\"$item in $select.selected track by $index\" ng-class=\"{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}\" ui-select-sort=\"$select.selected\"><span uis-transclude-append=\"\"></span> <a href=\"javascript:;\" class=\"ui-select-match-close select2-search-choice-close\" ng-click=\"$selectMultiple.removeChoice($index)\" tabindex=\"-1\"></a></li></span>");
$templateCache.put("select2/match.tpl.html","<a class=\"select2-choice ui-select-match\" ng-class=\"{\'select2-default\': $select.isEmpty()}\" ng-click=\"$select.toggle($event)\" aria-label=\"{{ $select.baseTitle }} select\"><span ng-show=\"$select.isEmpty()\" class=\"select2-chosen\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"select2-chosen\" ng-transclude=\"\"></span> <abbr ng-if=\"$select.allowClear && !$select.isEmpty()\" class=\"select2-search-choice-close\" ng-click=\"$select.clear($event)\"></abbr> <span class=\"select2-arrow ui-select-toggle\"><b></b></span></a>");
$templateCache.put("select2/no-choice.tpl.html","<div class=\"ui-select-no-choice dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
$templateCache.put("select2/select-multiple.tpl.html","<div class=\"ui-select-container ui-select-multiple select2 select2-container select2-container-multi\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}\"><ul class=\"select2-choices\"><span class=\"ui-select-match\"></span><li class=\"select2-search-field\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"select2-input ui-select-search\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-disabled=\"$select.disabled\" ng-hide=\"$select.disabled\" ng-model=\"$select.search\" ng-click=\"$select.activate()\" style=\"width: 34px;\" ondrop=\"return false;\"></li></ul><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open || $select.items.length === 0}\"><div class=\"ui-select-choices\"></div></div></div>");
$templateCache.put("select2/select.tpl.html","<div class=\"ui-select-container select2 select2-container\" ng-class=\"{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}\"><div class=\"ui-select-match\"></div><div class=\"ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active\" ng-class=\"{\'select2-display-none\': !$select.open}\"><div class=\"search-container\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled, \'select2-search\':$select.searchEnabled}\"><input type=\"search\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" ng-class=\"{\'select2-active\': $select.refreshing}\" role=\"combobox\" aria-expanded=\"true\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-label=\"{{ $select.baseTitle }}\" class=\"ui-select-search select2-input\" ng-model=\"$select.search\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div></div>");
$templateCache.put("selectize/choices.tpl.html","<div ng-show=\"$select.open\" class=\"ui-select-choices ui-select-dropdown selectize-dropdown\" ng-class=\"{\'single\': !$select.multiple, \'multi\': $select.multiple}\"><div class=\"ui-select-choices-content selectize-dropdown-content\"><div class=\"ui-select-choices-group optgroup\"><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label optgroup-header\" ng-bind=\"$group.name\"></div><div role=\"option\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\"><div class=\"option ui-select-choices-row-inner\" data-selectable=\"\"></div></div></div></div></div>");
$templateCache.put("selectize/match-multiple.tpl.html","<div class=\"ui-select-match\" data-value=\"\" ng-repeat=\"$item in $select.selected track by $index\" ng-click=\"$selectMultiple.activeMatchIndex = $index;\" ng-class=\"{\'active\':$selectMultiple.activeMatchIndex === $index}\" ui-select-sort=\"$select.selected\"><span class=\"ui-select-match-item\" ng-class=\"{\'select-locked\':$select.isLocked(this, $index)}\"><span uis-transclude-append=\"\"></span> <span class=\"remove ui-select-match-close\" ng-hide=\"$select.disabled\" ng-click=\"$selectMultiple.removeChoice($index)\">&times;</span></span></div>");
$templateCache.put("selectize/match.tpl.html","<div ng-hide=\"$select.searchEnabled && ($select.open || $select.isEmpty())\" class=\"ui-select-match\"><span ng-show=\"!$select.searchEnabled && ($select.isEmpty() || $select.open)\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty() || $select.open\" ng-transclude=\"\"></span></div>");
$templateCache.put("selectize/no-choice.tpl.html","<div class=\"ui-select-no-choice selectize-dropdown\" ng-show=\"$select.items.length == 0\"><div class=\"selectize-dropdown-content\"><div data-selectable=\"\" ng-transclude=\"\"></div></div></div>");
$templateCache.put("selectize/select-multiple.tpl.html","<div class=\"ui-select-container selectize-control multi plugin-remove_button\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled}\" placeholder=\"{{$selectMultiple.getPlaceholder()}}\" ng-model=\"$select.search\" ng-disabled=\"$select.disabled\" aria-expanded=\"{{$select.open}}\" aria-label=\"{{ $select.baseTitle }}\" ondrop=\"return false;\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");
$templateCache.put("selectize/select.tpl.html","<div class=\"ui-select-container selectize-control single\" ng-class=\"{\'open\': $select.open}\"><div class=\"selectize-input\" ng-class=\"{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}\" ng-click=\"$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()\"><div class=\"ui-select-match\"></div><input type=\"search\" autocomplete=\"off\" tabindex=\"-1\" class=\"ui-select-search ui-select-toggle\" ng-class=\"{\'ui-select-search-hidden\':!$select.searchEnabled}\" ng-click=\"$select.toggle($event)\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-hide=\"!$select.isEmpty() && !$select.open\" ng-disabled=\"$select.disabled\" aria-label=\"{{ $select.baseTitle }}\"></div><div class=\"ui-select-choices\"></div><div class=\"ui-select-no-choice\"></div></div>");}]);

/**
 * Module acts as a root module of smartedit commons module.
 */
var /* @ngInject */ SmarteditRootModule = /** @class */ (function () {
    /** @internal */
    function /* @ngInject */ SmarteditRootModule() {
    }
    /* @ngInject */ SmarteditRootModule = __decorate([
        SeModule({
            imports: [
                DIBridgeModule,
                'resourceLocationsModule',
                'functionsModule',
                'yLoDashModule',
                SeConstantsModule
            ]
        })
        /** @internal */
    ], /* @ngInject */ SmarteditRootModule);
    return /* @ngInject */ SmarteditRootModule;
}());

/**
 * **Deprecated since 2005, use {@link StartFromPipe}.**
 *
 * @deprecated
 */
var StartFromFilter = /** @class */ (function () {
    function StartFromFilter() {
    }
    StartFromFilter.transform = function () {
        return function (input, start) { return StartFromPipe.transform(input, start); };
    };
    StartFromFilter = __decorate([
        SeFilter()
    ], StartFromFilter);
    return StartFromFilter;
}());

/**
 * **Deprecated since 2005, use {@link PaginationComponent}.**
 *
 * The SmartEdit component that provides pagination by providing a visual pagination bar and buttons/numbers to navigate between pages.
 *
 * You need to bind the current page value to the ng-model property of the component.
 *
 * ### Parameters
 *
 *
 * `totalItems` - The total number of items.
 *
 * `itemsPerPage` - The total number of items per page.
 *
 * `boundaryLinks` - Whether to display First / Last buttons. Defaults to false.
 *
 * `ngModel` - The current page number.
 *
 * `onChange` - The function that is called with the current page number when either a button or page number is clicked.
 * The invoker can bind this to a custom function to act and fetch results based on new page number.
 *
 * @deprecated
 */
var /* @ngInject */ YPaginationComponent = /** @class */ (function () {
    function /* @ngInject */ YPaginationComponent() {
    }
    /* @ngInject */ YPaginationComponent.prototype.$onInit = function () {
        var _this = this;
        // in order to propagate down changes to ngModel from the parent controller
        this.exposedModel.$viewChangeListeners.push(function () { return _this.onPageChange(); });
        this.exposedModel.$render = function () { return _this.onPageChange(); };
    };
    /* @ngInject */ YPaginationComponent.prototype.onPageChange = function () {
        this.currentPage = this.exposedModel.$modelValue;
    };
    /* @ngInject */ YPaginationComponent.prototype.pageChanged = function () {
        this.exposedModel.$setViewValue(this.currentPage);
        this.onChange({
            $currentPage: this.currentPage
        });
    };
    /* @ngInject */ YPaginationComponent = __decorate([
        SeComponent({
            selector: 'y-pagination',
            templateUrl: 'yPaginationTemplate.html',
            require: {
                exposedModel: 'ngModel'
            },
            inputs: ['totalItems', 'itemsPerPage', 'boundaryLinks', 'onChange:&']
        })
    ], /* @ngInject */ YPaginationComponent);
    return /* @ngInject */ YPaginationComponent;
}());

// eslint-disable-next-line @typescript-eslint/no-var-requires
var NgSanitizeModule = require('angular-sanitize'); // Only supports CommonJS
// eslint-disable-next-line @typescript-eslint/no-var-requires
var NgInfiniteScrollModule = require('ng-infinite-scroll'); // Only supports CommonJS
deprecate();
/**
 * Module containing all the services shared within the smartedit commons.
 */
var /* @ngInject */ LegacySmarteditCommonsModule = /** @class */ (function () {
    function /* @ngInject */ LegacySmarteditCommonsModule() {
    }
    /* @ngInject */ LegacySmarteditCommonsModule = __decorate([
        SeModule({
            imports: [
                SmarteditRootModule,
                FunctionsModule,
                NgInfiniteScrollModule,
                L10nModule,
                'resourceLocationsModule',
                'seConstantsModule',
                'yLoDashModule',
                TranslationServiceModule,
                ConfigModule,
                'ui.select',
                NgSanitizeModule
            ],
            providers: [LanguageServiceGateway],
            declarations: [
                CompileHtmlLegacyDirective,
                StartFromFilter,
                LegacyDynamicPagedListComponent,
                YPaginationComponent,
                YSliderPanelComponent,
                YInfiniteScrollingComponent,
                YEventMessageComponent,
                YMoreTextComponent,
                RecompileDomDirective,
                IncludeReplaceDirective,
                YDropDownMenuComponent,
                YMessageComponent,
                LegacyHasOperationPermissionDirective
            ]
        })
    ], /* @ngInject */ LegacySmarteditCommonsModule);
    return /* @ngInject */ LegacySmarteditCommonsModule;
}());

Object.defineProperty(exports, 'ALERT_CONFIG_DEFAULTS', {
    enumerable: true,
    get: function () {
        return utils.ALERT_CONFIG_DEFAULTS;
    }
});
Object.defineProperty(exports, 'ALERT_CONFIG_DEFAULTS_TOKEN', {
    enumerable: true,
    get: function () {
        return utils.ALERT_CONFIG_DEFAULTS_TOKEN;
    }
});
Object.defineProperty(exports, 'AbstractCachedRestService', {
    enumerable: true,
    get: function () {
        return utils.AbstractCachedRestService;
    }
});
Object.defineProperty(exports, 'Alert', {
    enumerable: true,
    get: function () {
        return utils.Alert;
    }
});
Object.defineProperty(exports, 'AuthenticationService', {
    enumerable: true,
    get: function () {
        return utils.AuthenticationService;
    }
});
Object.defineProperty(exports, 'BaseAlertFactory', {
    enumerable: true,
    get: function () {
        return utils.AlertFactory;
    }
});
Object.defineProperty(exports, 'BaseAlertService', {
    enumerable: true,
    get: function () {
        return utils.AlertService;
    }
});
Object.defineProperty(exports, 'BrowserService', {
    enumerable: true,
    get: function () {
        return utils.BrowserService;
    }
});
Object.defineProperty(exports, 'CacheAction', {
    enumerable: true,
    get: function () {
        return utils.CacheAction;
    }
});
Object.defineProperty(exports, 'CacheConfig', {
    enumerable: true,
    get: function () {
        return utils.CacheConfig;
    }
});
Object.defineProperty(exports, 'CacheConfigAnnotationFactory', {
    enumerable: true,
    get: function () {
        return utils.CacheConfigAnnotationFactory;
    }
});
Object.defineProperty(exports, 'CacheService', {
    enumerable: true,
    get: function () {
        return utils.CacheService;
    }
});
Object.defineProperty(exports, 'Cached', {
    enumerable: true,
    get: function () {
        return utils.Cached;
    }
});
Object.defineProperty(exports, 'CachedAnnotationFactory', {
    enumerable: true,
    get: function () {
        return utils.CachedAnnotationFactory;
    }
});
Object.defineProperty(exports, 'CloneableUtils', {
    enumerable: true,
    get: function () {
        return utils.CloneableUtils;
    }
});
Object.defineProperty(exports, 'CryptographicUtils', {
    enumerable: true,
    get: function () {
        return utils.CryptographicUtils;
    }
});
Object.defineProperty(exports, 'DEFAULT_AUTHENTICATION_ENTRY_POINT', {
    enumerable: true,
    get: function () {
        return utils.DEFAULT_AUTHENTICATION_ENTRY_POINT;
    }
});
Object.defineProperty(exports, 'DEFAULT_AUTH_MAP', {
    enumerable: true,
    get: function () {
        return utils.DEFAULT_AUTH_MAP;
    }
});
Object.defineProperty(exports, 'DEFAULT_CREDENTIALS_MAP', {
    enumerable: true,
    get: function () {
        return utils.DEFAULT_CREDENTIALS_MAP;
    }
});
Object.defineProperty(exports, 'DEFAULT_LANGUAGE_ISO', {
    enumerable: true,
    get: function () {
        return utils.DEFAULT_LANGUAGE_ISO;
    }
});
Object.defineProperty(exports, 'EVENTS', {
    enumerable: true,
    get: function () {
        return utils.EVENTS;
    }
});
Object.defineProperty(exports, 'EVENT_SERVICE', {
    enumerable: true,
    get: function () {
        return utils.EVENT_SERVICE;
    }
});
Object.defineProperty(exports, 'EvictionTag', {
    enumerable: true,
    get: function () {
        return utils.EvictionTag;
    }
});
Object.defineProperty(exports, 'FILE_VALIDATION_CONFIG', {
    enumerable: true,
    get: function () {
        return utils.FILE_VALIDATION_CONFIG;
    }
});
Object.defineProperty(exports, 'FileMimeTypeService', {
    enumerable: true,
    get: function () {
        return utils.FileMimeTypeService;
    }
});
Object.defineProperty(exports, 'FileReaderService', {
    enumerable: true,
    get: function () {
        return utils.FileReaderService;
    }
});
Object.defineProperty(exports, 'FileValidationService', {
    enumerable: true,
    get: function () {
        return utils.FileValidationService;
    }
});
Object.defineProperty(exports, 'FileValidatorFactory', {
    enumerable: true,
    get: function () {
        return utils.FileValidatorFactory;
    }
});
Object.defineProperty(exports, 'FingerPrintingService', {
    enumerable: true,
    get: function () {
        return utils.FingerPrintingService;
    }
});
Object.defineProperty(exports, 'FunctionsUtils', {
    enumerable: true,
    get: function () {
        return utils.FunctionsUtils;
    }
});
Object.defineProperty(exports, 'FundamentalModalButtonAction', {
    enumerable: true,
    get: function () {
        return utils.FundamentalModalButtonAction;
    }
});
Object.defineProperty(exports, 'FundamentalModalButtonStyle', {
    enumerable: true,
    get: function () {
        return utils.FundamentalModalButtonStyle;
    }
});
Object.defineProperty(exports, 'FundamentalModalManagerService', {
    enumerable: true,
    get: function () {
        return utils.FundamentalModalManagerService;
    }
});
Object.defineProperty(exports, 'HttpBackendService', {
    enumerable: true,
    get: function () {
        return utils.HttpBackendService;
    }
});
Object.defineProperty(exports, 'HttpErrorInterceptorService', {
    enumerable: true,
    get: function () {
        return utils.HttpErrorInterceptorService;
    }
});
Object.defineProperty(exports, 'HttpInterceptorModule', {
    enumerable: true,
    get: function () {
        return utils.HttpInterceptorModule;
    }
});
Object.defineProperty(exports, 'HttpUtils', {
    enumerable: true,
    get: function () {
        return utils.HttpUtils;
    }
});
Object.defineProperty(exports, 'I18N_RESOURCE_URI_TOKEN', {
    enumerable: true,
    get: function () {
        return utils.I18N_RESOURCE_URI_TOKEN;
    }
});
Object.defineProperty(exports, 'I18N_ROOT_RESOURCE_URI', {
    enumerable: true,
    get: function () {
        return utils.I18N_ROOT_RESOURCE_URI;
    }
});
Object.defineProperty(exports, 'IAlertServiceType', {
    enumerable: true,
    get: function () {
        return utils.IAlertServiceType;
    }
});
Object.defineProperty(exports, 'IAuthenticationManagerService', {
    enumerable: true,
    get: function () {
        return utils.IAuthenticationManagerService;
    }
});
Object.defineProperty(exports, 'IAuthenticationService', {
    enumerable: true,
    get: function () {
        return utils.IAuthenticationService;
    }
});
Object.defineProperty(exports, 'IBaseAlertService', {
    enumerable: true,
    get: function () {
        return utils.IAlertService;
    }
});
Object.defineProperty(exports, 'IBrowserService', {
    enumerable: true,
    get: function () {
        return utils.BrowserService;
    }
});
Object.defineProperty(exports, 'IModalService', {
    enumerable: true,
    get: function () {
        return utils.IModalService;
    }
});
Object.defineProperty(exports, 'ISessionService', {
    enumerable: true,
    get: function () {
        return utils.ISessionService;
    }
});
Object.defineProperty(exports, 'ISettingsService', {
    enumerable: true,
    get: function () {
        return utils.ISettingsService;
    }
});
Object.defineProperty(exports, 'ISharedDataService', {
    enumerable: true,
    get: function () {
        return utils.ISharedDataService;
    }
});
Object.defineProperty(exports, 'IStorageService', {
    enumerable: true,
    get: function () {
        return utils.IStorageService;
    }
});
Object.defineProperty(exports, 'ITranslationsFetchService', {
    enumerable: true,
    get: function () {
        return utils.ITranslationsFetchService;
    }
});
Object.defineProperty(exports, 'InvalidateCache', {
    enumerable: true,
    get: function () {
        return utils.InvalidateCache;
    }
});
Object.defineProperty(exports, 'InvalidateCacheAnnotationFactory', {
    enumerable: true,
    get: function () {
        return utils.InvalidateCacheAnnotationFactory;
    }
});
Object.defineProperty(exports, 'LANDING_PAGE_PATH', {
    enumerable: true,
    get: function () {
        return utils.LANDING_PAGE_PATH;
    }
});
Object.defineProperty(exports, 'LogService', {
    enumerable: true,
    get: function () {
        return utils.LogService;
    }
});
Object.defineProperty(exports, 'ModalButtonActions', {
    enumerable: true,
    get: function () {
        return utils.ModalButtonActions;
    }
});
Object.defineProperty(exports, 'ModalButtonStyles', {
    enumerable: true,
    get: function () {
        return utils.ModalButtonStyles;
    }
});
Object.defineProperty(exports, 'OPERATION_CONTEXT_TOKEN', {
    enumerable: true,
    get: function () {
        return utils.OPERATION_CONTEXT_TOKEN;
    }
});
Object.defineProperty(exports, 'OperationContextAnnotationFactory', {
    enumerable: true,
    get: function () {
        return utils.OperationContextAnnotationFactory;
    }
});
Object.defineProperty(exports, 'OperationContextRegistered', {
    enumerable: true,
    get: function () {
        return utils.OperationContextRegistered;
    }
});
Object.defineProperty(exports, 'OperationContextService', {
    enumerable: true,
    get: function () {
        return utils.OperationContextService;
    }
});
Object.defineProperty(exports, 'ParentWindowUtils', {
    enumerable: true,
    get: function () {
        return utils.WindowUtils;
    }
});
Object.defineProperty(exports, 'PermissionErrorInterceptor', {
    enumerable: true,
    get: function () {
        return utils.PermissionErrorInterceptor;
    }
});
Object.defineProperty(exports, 'PromiseUtils', {
    enumerable: true,
    get: function () {
        return utils.PromiseUtils;
    }
});
Object.defineProperty(exports, 'ResponseAdapterInterceptor', {
    enumerable: true,
    get: function () {
        return utils.ResponseAdapterInterceptor;
    }
});
Object.defineProperty(exports, 'RestServiceFactory', {
    enumerable: true,
    get: function () {
        return utils.RestServiceFactory;
    }
});
Object.defineProperty(exports, 'RetryInterceptor', {
    enumerable: true,
    get: function () {
        return utils.RetryInterceptor;
    }
});
Object.defineProperty(exports, 'SELECTED_LANGUAGE', {
    enumerable: true,
    get: function () {
        return utils.SELECTED_LANGUAGE;
    }
});
Object.defineProperty(exports, 'SSOAuthenticationHelper', {
    enumerable: true,
    get: function () {
        return utils.SSOAuthenticationHelper;
    }
});
Object.defineProperty(exports, 'SWITCH_LANGUAGE_EVENT', {
    enumerable: true,
    get: function () {
        return utils.SWITCH_LANGUAGE_EVENT;
    }
});
Object.defineProperty(exports, 'SeTranslationModule', {
    enumerable: true,
    get: function () {
        return utils.TranslationModule;
    }
});
Object.defineProperty(exports, 'TranslationModule', {
    enumerable: true,
    get: function () {
        return utils.TranslationModule;
    }
});
Object.defineProperty(exports, 'URIBuilder', {
    enumerable: true,
    get: function () {
        return utils.URIBuilder;
    }
});
Object.defineProperty(exports, 'UnauthorizedErrorInterceptor', {
    enumerable: true,
    get: function () {
        return utils.UnauthorizedErrorInterceptor;
    }
});
Object.defineProperty(exports, 'UrlUtils', {
    enumerable: true,
    get: function () {
        return utils.UrlUtils;
    }
});
Object.defineProperty(exports, 'WHO_AM_I_RESOURCE_URI_TOKEN', {
    enumerable: true,
    get: function () {
        return utils.WHO_AM_I_RESOURCE_URI_TOKEN;
    }
});
Object.defineProperty(exports, 'annotationService', {
    enumerable: true,
    get: function () {
        return utils.annotationService;
    }
});
Object.defineProperty(exports, 'booleanUtils', {
    enumerable: true,
    get: function () {
        return utils.booleanUtils;
    }
});
Object.defineProperty(exports, 'commonNgZone', {
    enumerable: true,
    get: function () {
        return utils.commonNgZone;
    }
});
Object.defineProperty(exports, 'functionsUtils', {
    enumerable: true,
    get: function () {
        return utils.functionsUtils;
    }
});
Object.defineProperty(exports, 'httpUtils', {
    enumerable: true,
    get: function () {
        return utils.httpUtils;
    }
});
Object.defineProperty(exports, 'promiseUtils', {
    enumerable: true,
    get: function () {
        return utils.promiseUtils;
    }
});
Object.defineProperty(exports, 'urlUtils', {
    enumerable: true,
    get: function () {
        return utils.urlUtils;
    }
});
exports.$translateStaticFilesLoader = $translateStaticFilesLoader;
exports.ALERT_SERVICE_TOKEN = ALERT_SERVICE_TOKEN;
exports.ALL_PERSPECTIVE = ALL_PERSPECTIVE;
exports.ANNOUNCEMENT_DATA = ANNOUNCEMENT_DATA;
exports.AbstractAngularJSBasedCustomElement = AbstractAngularJSBasedCustomElement;
exports.AbstractDecorator = AbstractDecorator;
exports.ActionableSearchItemComponent = ActionableSearchItemComponent;
exports.AlertServiceProvidersModule = AlertServiceProvidersModule;
exports.AngularJSBootstrapIndicatorService = AngularJSBootstrapIndicatorService;
exports.AngularJSLazyDependenciesService = AngularJSLazyDependenciesService;
exports.ApiUtils = ApiUtils;
exports.AuthenticationManager = AuthenticationManager;
exports.AuthorizationService = AuthorizationService;
exports.BooleanComponent = BooleanComponent;
exports.BooleanModule = BooleanModule;
exports.CATALOG_DETAILS_COLUMNS = CATALOG_DETAILS_COLUMNS;
exports.CATALOG_DETAILS_ITEM_DATA = CATALOG_DETAILS_ITEM_DATA;
exports.CATALOG_VERSION_PERMISSIONS_RESOURCE_URI_CONSTANT = CATALOG_VERSION_PERMISSIONS_RESOURCE_URI_CONSTANT;
exports.CATALOG_VERSION_UUID_ATTRIBUTE = CATALOG_VERSION_UUID_ATTRIBUTE;
exports.CLICK_DROPDOWN = CLICK_DROPDOWN;
exports.CLICK_DROPDOWN_TOKEN = CLICK_DROPDOWN_TOKEN;
exports.CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN = CLIENT_PAGED_LIST_CELL_COMPONENT_DATA_TOKEN;
exports.CLOSE_CTX_MENU = CLOSE_CTX_MENU;
exports.CMSWEBSERVICES_PATH = CMSWEBSERVICES_PATH;
exports.COLLAPSIBLE_CONTAINER_CONSTANTS = COLLAPSIBLE_CONTAINER_CONSTANTS;
exports.COLLAPSIBLE_DEFAULT_CONFIGURATION = COLLAPSIBLE_DEFAULT_CONFIGURATION;
exports.COMPONENT_CLASS = COMPONENT_CLASS;
exports.CONFIGURATION_URI = CONFIGURATION_URI;
exports.CONTAINER_ID_ATTRIBUTE = CONTAINER_ID_ATTRIBUTE;
exports.CONTAINER_TYPE_ATTRIBUTE = CONTAINER_TYPE_ATTRIBUTE;
exports.CONTENT_SLOT_TYPE = CONTENT_SLOT_TYPE;
exports.CONTEXT_CATALOG = CONTEXT_CATALOG;
exports.CONTEXT_CATALOG_VERSION = CONTEXT_CATALOG_VERSION;
exports.CONTEXT_SITE_ID = CONTEXT_SITE_ID;
exports.CONTRACT_CHANGE_LISTENER_COMPONENT_PROCESS_STATUS = CONTRACT_CHANGE_LISTENER_COMPONENT_PROCESS_STATUS;
exports.CONTRACT_CHANGE_LISTENER_PROCESS_EVENTS = CONTRACT_CHANGE_LISTENER_PROCESS_EVENTS;
exports.CSS_CLASSNAMES = CSS_CLASSNAMES;
exports.CTX_MENU_DROPDOWN_IS_OPEN = CTX_MENU_DROPDOWN_IS_OPEN;
exports.ClickOutsideDirective = ClickOutsideDirective;
exports.ClickOutsideModule = ClickOutsideModule;
exports.ClientPagedListModule = ClientPagedListModule;
exports.CollapsibleContainerComponent = CollapsibleContainerComponent;
exports.CollapsibleContainerContentComponent = CollapsibleContainerContentComponent;
exports.CollapsibleContainerHeaderComponent = CollapsibleContainerHeaderComponent;
exports.CollapsibleContainerModule = CollapsibleContainerModule;
exports.CompileHtmlDirective = CompileHtmlDirective;
exports.CompileHtmlLegacyDirective = CompileHtmlLegacyDirective;
exports.CompileHtmlModule = CompileHtmlModule;
exports.ConfigModule = ConfigModule;
exports.ConfirmDialogComponent = ConfirmDialogComponent;
exports.ContentCatalogRestService = ContentCatalogRestService;
exports.CrossFrameEventService = CrossFrameEventService;
exports.CrossFrameEventServiceGateway = CrossFrameEventServiceGateway;
exports.CustomComponentOutletDirective = CustomComponentOutletDirective;
exports.CustomComponentOutletDirectiveModule = CustomComponentOutletDirectiveModule;
exports.CustomDropdownPopulatorsToken = CustomDropdownPopulatorsToken;
exports.CustomHandlingStrategy = CustomHandlingStrategy;
exports.DATA_TABLE_COMPONENT_DATA = DATA_TABLE_COMPONENT_DATA;
exports.DATE_CONSTANTS = DATE_CONSTANTS;
exports.DEFAULT_AUTHENTICATION_CLIENT_ID = DEFAULT_AUTHENTICATION_CLIENT_ID;
exports.DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION = DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION$1;
exports.DEFAULT_LANGUAGE = DEFAULT_LANGUAGE;
exports.DIBridgeModule = DIBridgeModule;
exports.DIBridgeUtils = DIBridgeUtils;
exports.DINameUtils = DINameUtils;
exports.DOMAIN_TOKEN = DOMAIN_TOKEN;
exports.DO_NOT_USE_STORAGE_MANAGER_TOKEN = DO_NOT_USE_STORAGE_MANAGER_TOKEN;
exports.DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME = DRAG_AND_DROP_CROSS_ORIGIN_BEFORE_TIME;
exports.DROPDOWN_IMPLEMENTATION_SUFFIX = DROPDOWN_IMPLEMENTATION_SUFFIX;
exports.DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN = DROPDOWN_IMPLEMENTATION_SUFFIX_TOKEN;
exports.DROPDOWN_MENU_ITEM_DATA = DROPDOWN_MENU_ITEM_DATA;
exports.DataTableComponent = DataTableComponent;
exports.DateUtils = DateUtils;
exports.DiscardablePromiseUtils = DiscardablePromiseUtils;
exports.DragAndDropScrollingService = DragAndDropScrollingService;
exports.DragAndDropService = DragAndDropService;
exports.DragAndDropServiceModule = DragAndDropServiceModule;
exports.DropdownMenuComponent = DropdownMenuComponent;
exports.DropdownMenuItemDefaultComponent = DropdownMenuItemDefaultComponent;
exports.DropdownMenuModule = DropdownMenuModule;
exports.DropdownPopulatorInterface = DropdownPopulatorInterface;
exports.DropdownPopulatorModule = DropdownPopulatorModule;
exports.DynamicPagedListComponent = DynamicPagedListComponent;
exports.DynamicPagedListModule = DynamicPagedListModule;
exports.ELEMENT_UUID_ATTRIBUTE = ELEMENT_UUID_ATTRIBUTE;
exports.ENUM_RESOURCE_URI = ENUM_RESOURCE_URI;
exports.EVENT_CONTENT_CATALOG_UPDATE = EVENT_CONTENT_CATALOG_UPDATE;
exports.EVENT_NOTIFICATION_CHANGED = EVENT_NOTIFICATION_CHANGED;
exports.EVENT_OUTER_FRAME_CLICKED = EVENT_OUTER_FRAME_CLICKED;
exports.EVENT_PERSPECTIVE_ADDED = EVENT_PERSPECTIVE_ADDED;
exports.EVENT_PERSPECTIVE_CHANGED = EVENT_PERSPECTIVE_CHANGED;
exports.EVENT_PERSPECTIVE_REFRESHED = EVENT_PERSPECTIVE_REFRESHED;
exports.EVENT_PERSPECTIVE_UNLOADING = EVENT_PERSPECTIVE_UNLOADING;
exports.EVENT_PERSPECTIVE_UPDATED = EVENT_PERSPECTIVE_UPDATED;
exports.EVENT_SMARTEDIT_COMPONENT_UPDATED = EVENT_SMARTEDIT_COMPONENT_UPDATED;
exports.EVENT_STRICT_PREVIEW_MODE_REQUESTED = EVENT_STRICT_PREVIEW_MODE_REQUESTED;
exports.EXPERIENCE_STORAGE_KEY = EXPERIENCE_STORAGE_KEY;
exports.EXTENDED_VIEW_PORT_MARGIN = EXTENDED_VIEW_PORT_MARGIN;
exports.EXTENDED_VIEW_PORT_MARGIN_TOKEN = EXTENDED_VIEW_PORT_MARGIN_TOKEN;
exports.EditableListComponent = EditableListComponent;
exports.EditableListDefaultItem = EditableListDefaultItem;
exports.EditableListModule = EditableListModule;
exports.EditableListNodeItem = EditableListNodeItem;
exports.EditorFieldMappingService = EditorFieldMappingService;
exports.EventMessageComponent = EventMessageComponent;
exports.FetchEnumDataHandler = FetchEnumDataHandler;
exports.FilterByFieldPipe = FilterByFieldPipe;
exports.FilterByFieldPipeModule = FilterByFieldPipeModule;
exports.FrequentlyChangingContentName = FrequentlyChangingContentName;
exports.FunctionsModule = FunctionsModule;
exports.FundamentalsModule = FundamentalsModule;
exports.GENERIC_EDITOR_LOADED_EVENT = GENERIC_EDITOR_LOADED_EVENT;
exports.GENERIC_EDITOR_LOADED_EVENT_CONSTANT = GENERIC_EDITOR_LOADED_EVENT_CONSTANT;
exports.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT = GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT;
exports.GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT_CONSTANT = GENERIC_EDITOR_UNRELATED_VALIDATION_MESSAGES_EVENT_CONSTANT;
exports.GENERIC_EDITOR_WIDGET_DATA = GENERIC_EDITOR_WIDGET_DATA;
exports.GatewayFactory = GatewayFactory;
exports.GatewayProxied = GatewayProxied;
exports.GatewayProxiedAnnotationFactory = GatewayProxiedAnnotationFactory;
exports.GatewayProxy = GatewayProxy;
exports.GenericEditorBreadcrumbComponent = GenericEditorBreadcrumbComponent;
exports.GenericEditorComponent = GenericEditorComponent$1;
exports.GenericEditorDropdownComponent = GenericEditorDropdownComponent;
exports.GenericEditorDropdownModule = GenericEditorDropdownModule;
exports.GenericEditorDropdownServiceFactory = GenericEditorDropdownServiceFactory;
exports.GenericEditorFactoryService = GenericEditorFactoryService;
exports.GenericEditorFieldComponent = GenericEditorFieldComponent;
exports.GenericEditorModule = GenericEditorModule;
exports.GenericEditorSanitizationService = GenericEditorSanitizationService;
exports.GenericEditorStackService = GenericEditorStackService;
exports.GenericEditorTabService = GenericEditorTabService;
exports.GenericEditorWidgetModule = GenericEditorWidgetModule;
exports.HEART_BEAT_TIMEOUT_THRESHOLD_MS = HEART_BEAT_TIMEOUT_THRESHOLD_MS;
exports.HEART_BEAT_TIMEOUT_THRESHOLD_MS_TOKEN = HEART_BEAT_TIMEOUT_THRESHOLD_MS_TOKEN;
exports.HIDE_SLOT_MENU = HIDE_SLOT_MENU;
exports.HIDE_TOOLBAR_ITEM_CONTEXT = HIDE_TOOLBAR_ITEM_CONTEXT;
exports.HasOperationPermissionBaseDirective = HasOperationPermissionBaseDirective;
exports.HasOperationPermissionDirectiveModule = HasOperationPermissionDirectiveModule;
exports.HeaderLanguageDropdownComponent = HeaderLanguageDropdownComponent;
exports.HelpComponent = HelpComponent;
exports.HelpModule = HelpModule;
exports.I18N_LANGUAGES_RESOURCE_URI = I18N_LANGUAGES_RESOURCE_URI;
exports.I18N_RESOURCE_URI = I18N_RESOURCE_URI;
exports.IAlertService = IAlertService;
exports.IAnnouncementService = IAnnouncementService;
exports.ICatalogDetailsService = ICatalogDetailsService;
exports.ICatalogService = ICatalogService;
exports.ICatalogVersionPermissionService = ICatalogVersionPermissionService;
exports.IConfirmationModalService = IConfirmationModalService;
exports.IContextualMenuService = IContextualMenuService;
exports.ID_ATTRIBUTE = ID_ATTRIBUTE;
exports.IDecoratorService = IDecoratorService;
exports.IDragAndDropCrossOrigin = IDragAndDropCrossOrigin;
exports.IDragEventType = IDragEventType;
exports.IDropdownPopulatorInterface = IDropdownPopulatorInterface;
exports.IExperienceService = IExperienceService;
exports.IFeatureService = IFeatureService;
exports.IGenericEditorDropdownServiceConstructor = IGenericEditorDropdownServiceConstructor;
exports.IIframeClickDetectionService = IIframeClickDetectionService;
exports.ILegacyDecoratorToCustomElementConverter = ILegacyDecoratorToCustomElementConverter;
exports.INotificationMouseLeaveDetectionService = INotificationMouseLeaveDetectionService;
exports.INotificationService = INotificationService;
exports.IPageInfoService = IPageInfoService;
exports.IPermissionService = IPermissionService;
exports.IPerspectiveService = IPerspectiveService;
exports.IPositionRegistry = IPositionRegistry;
exports.IPreviewService = IPreviewService;
exports.IRenderService = IRenderService;
exports.IResizeListener = IResizeListener;
exports.IRestServiceFactory = IRestServiceFactory;
exports.ISmartEditContractChangeListener = ISmartEditContractChangeListener;
exports.IStorageGateway = IStorageGateway;
exports.IStorageManager = IStorageManager;
exports.IStorageManagerFactory = IStorageManagerFactory;
exports.IStorageManagerGateway = IStorageManagerGateway;
exports.IStoragePropertiesService = IStoragePropertiesService;
exports.ITEM_COMPONENT_DATA_TOKEN = ITEM_COMPONENT_DATA_TOKEN;
exports.ITemplateCacheService = ITemplateCacheService;
exports.IToolbarService = IToolbarService;
exports.IToolbarServiceFactory = IToolbarServiceFactory;
exports.IUIBootstrapModalService = IUIBootstrapModalService;
exports.IUIBootstrapModalStackService = IUIBootstrapModalStackService;
exports.IUrlService = IUrlService;
exports.IWaitDialogService = IWaitDialogService;
exports.InViewElementObserver = InViewElementObserver;
exports.IncludeReplaceDirective = IncludeReplaceDirective;
exports.InfiniteScrollingComponent = InfiniteScrollingComponent;
exports.InfiniteScrollingModule = InfiniteScrollingModule;
exports.InterceptorHelper = InterceptorHelper;
exports.JQueryUtilsService = JQueryUtilsService;
exports.L10nFilter = L10nFilter;
exports.L10nModule = L10nModule;
exports.L10nPipe = L10nPipe;
exports.L10nPipeModule = L10nPipeModule;
exports.L10nService = L10nService;
exports.LANGUAGE_RESOURCE_URI = LANGUAGE_RESOURCE_URI;
exports.LINKED_DROPDOWN = LINKED_DROPDOWN;
exports.LINKED_DROPDOWN_TOKEN = LINKED_DROPDOWN_TOKEN;
exports.LanguageService = LanguageService;
exports.LanguageServiceGateway = LanguageServiceGateway;
exports.LegacyDynamicPagedListComponent = LegacyDynamicPagedListComponent;
exports.LegacyGEWidgetToCustomElementConverter = LegacyGEWidgetToCustomElementConverter;
exports.LegacyHasOperationPermissionDirective = LegacyHasOperationPermissionDirective;
exports.LegacySmarteditCommonsModule = LegacySmarteditCommonsModule;
exports.MEDIA_PATH = MEDIA_PATH;
exports.MEDIA_RESOURCE_URI = MEDIA_RESOURCE_URI;
exports.MUTATION_TYPES = MUTATION_TYPES;
exports.MessageComponent = MessageComponent;
exports.MessageGateway = MessageGateway;
exports.MessageModule = MessageModule;
exports.ModalManager = ModalManager;
exports.ModalService = ModalService;
exports.ModalServiceModule = ModalServiceModule;
exports.ModalWizard = ModalWizard;
exports.ModalWizardNavBarComponent = ModalWizardNavBarComponent;
exports.ModalWizardStepOutletComponent = ModalWizardStepOutletComponent;
exports.ModalWizardTemplateComponent = ModalWizardTemplateComponent;
exports.ModuleUtils = ModuleUtils;
exports.MoreTextComponent = MoreTextComponent;
exports.MoreTextModule = MoreTextModule;
exports.NG_ROUTE_PREFIX = NG_ROUTE_PREFIX;
exports.NG_ROUTE_WILDCARD = NG_ROUTE_WILDCARD;
exports.NONE_PERSPECTIVE = NONE_PERSPECTIVE;
exports.NamespacedStorageManager = NamespacedStorageManager;
exports.NavigationNodeItem = NavigationNodeItem;
exports.NgIncludeDirective = NgIncludeDirective;
exports.NgTreeModule = NgTreeModule$1;
exports.NodeUtils = NodeUtils;
exports.NonValidationErrorInterceptor = NonValidationErrorInterceptor;
exports.OPERATION_CONTEXT = OPERATION_CONTEXT;
exports.OVERLAY_COMPONENT_CLASS = OVERLAY_COMPONENT_CLASS;
exports.OVERLAY_DISABLED_EVENT = OVERLAY_DISABLED_EVENT;
exports.OVERLAY_ID = OVERLAY_ID;
exports.OVERLAY_RERENDERED_EVENT = OVERLAY_RERENDERED_EVENT;
exports.ObjectUtils = ObjectUtils;
exports.OptionsDropdownPopulator = OptionsDropdownPopulator;
exports.PAGE_CONTEXT_CATALOG = PAGE_CONTEXT_CATALOG;
exports.PAGE_CONTEXT_CATALOG_VERSION = PAGE_CONTEXT_CATALOG_VERSION;
exports.PAGE_CONTEXT_SITE_ID = PAGE_CONTEXT_SITE_ID;
exports.PERSPECTIVE_SELECTOR_WIDGET_KEY = PERSPECTIVE_SELECTOR_WIDGET_KEY;
exports.POPUP_OVERLAY_DATA = POPUP_OVERLAY_DATA;
exports.PREVIEW_RESOURCE_URI = PREVIEW_RESOURCE_URI;
exports.PREVIOUS_USERNAME_HASH = PREVIOUS_USERNAME_HASH;
exports.PRODUCT_LIST_RESOURCE_API = PRODUCT_LIST_RESOURCE_API;
exports.PRODUCT_RESOURCE_API = PRODUCT_RESOURCE_API;
exports.PageSensitiveDirective = PageSensitiveDirective;
exports.PaginationComponent = PaginationComponent;
exports.PaginationModule = PaginationModule;
exports.PermissionsRestService = PermissionsRestService;
exports.PolyfillService = PolyfillService;
exports.PopupOverlayComponent = PopupOverlayComponent;
exports.PopupOverlayModule = PopupOverlayModule;
exports.PreventVerticalOverflowComponent = PreventVerticalOverflowComponent;
exports.PreventVerticalOverflowModule = PreventVerticalOverflowModule;
exports.PreviewErrorInterceptor = PreviewErrorInterceptor;
exports.PriorityService = PriorityService;
exports.ProductCatalogRestService = ProductCatalogRestService;
exports.PropertyPipe = PropertyPipe;
exports.PropertyPipeModule = PropertyPipeModule;
exports.REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT = REFRESH_CONTEXTUAL_MENU_ITEMS_EVENT;
exports.RESOLVED_LOCALE_TO_CKEDITOR_LOCALE_MAP = RESOLVED_LOCALE_TO_CKEDITOR_LOCALE_MAP;
exports.RICH_TEXT_CONFIGURATION = RICH_TEXT_CONFIGURATION;
exports.RarelyChangingContentName = RarelyChangingContentName;
exports.RecompileDomDirective = RecompileDomDirective;
exports.ResizeObserverDirective = ResizeObserverDirective;
exports.ResizeObserverModule = ResizeObserverModule;
exports.ResourceNotFoundErrorInterceptor = ResourceNotFoundErrorInterceptor;
exports.ReversePipe = ReversePipe;
exports.ReversePipeModule = ReversePipeModule;
exports.RichTextFieldComponent = RichTextFieldComponent;
exports.RichTextFieldLocalizationService = RichTextFieldLocalizationService;
exports.RichTextFieldModule = RichTextFieldModule;
exports.RichTextLoaderService = RichTextLoaderService;
exports.SCROLL_AREA_CLASS = SCROLL_AREA_CLASS;
exports.SEDropdownServiceFactory = GenericEditorDropdownServiceFactory;
exports.SEND_MOUSE_POSITION_THROTTLE = SEND_MOUSE_POSITION_THROTTLE;
exports.SETTINGS_URI = SETTINGS_URI;
exports.SHOW_SLOT_MENU = SHOW_SLOT_MENU;
exports.SHOW_TOOLBAR_ITEM_CONTEXT = SHOW_TOOLBAR_ITEM_CONTEXT;
exports.SITES_RESOURCE_URI = SITES_RESOURCE_URI;
exports.SMARTEDITCONTAINER_COMPONENT_NAME = SMARTEDITCONTAINER_COMPONENT_NAME;
exports.SMARTEDITLOADER_COMPONENT_NAME = SMARTEDITLOADER_COMPONENT_NAME;
exports.SMARTEDIT_ATTRIBUTE_PREFIX = SMARTEDIT_ATTRIBUTE_PREFIX;
exports.SMARTEDIT_COMPONENT_NAME = SMARTEDIT_COMPONENT_NAME;
exports.SMARTEDIT_COMPONENT_PROCESS_STATUS = SMARTEDIT_COMPONENT_PROCESS_STATUS;
exports.SMARTEDIT_DRAG_AND_DROP_EVENTS = SMARTEDIT_DRAG_AND_DROP_EVENTS;
exports.SMARTEDIT_ELEMENT_HOVERED = SMARTEDIT_ELEMENT_HOVERED;
exports.SMARTEDIT_IFRAME_DRAG_AREA = SMARTEDIT_IFRAME_DRAG_AREA;
exports.SMARTEDIT_IFRAME_WRAPPER_ID = SMARTEDIT_IFRAME_WRAPPER_ID;
exports.SMARTEDIT_INNER_FILES = SMARTEDIT_INNER_FILES;
exports.SMARTEDIT_INNER_FILES_POST = SMARTEDIT_INNER_FILES_POST;
exports.SMARTEDIT_LOGIN_DIALOG_RESOURCES = SMARTEDIT_LOGIN_DIALOG_RESOURCES;
exports.SMARTEDIT_RESOURCE_URI_REGEXP = SMARTEDIT_RESOURCE_URI_REGEXP;
exports.SMARTEDIT_ROOT = SMARTEDIT_ROOT;
exports.SSO_AUTHENTICATION_ENTRY_POINT = SSO_AUTHENTICATION_ENTRY_POINT;
exports.SSO_LOGOUT_ENTRY_POINT = SSO_LOGOUT_ENTRY_POINT;
exports.SSO_OAUTH2_AUTHENTICATION_ENTRY_POINT = SSO_OAUTH2_AUTHENTICATION_ENTRY_POINT;
exports.STORAGE_PROPERTIES_TOKEN = STORAGE_PROPERTIES_TOKEN;
exports.STORE_FRONT_CONTEXT = STORE_FRONT_CONTEXT;
exports.ScriptUtils = ScriptUtils;
exports.SeComponent = SeComponent;
exports.SeCustomComponent = SeCustomComponent;
exports.SeDecorator = SeDecorator;
exports.SeDirective = SeDirective;
exports.SeDowngradeComponent = SeDowngradeComponent;
exports.SeDowngradeService = SeDowngradeService;
exports.SeEntryModule = SeEntryModule;
exports.SeFilter = SeFilter;
exports.SeGenericEditorModule = SeGenericEditorModule;
exports.SeInjectable = SeInjectable;
exports.SeModule = SeModule;
exports.SeRouteModule = SeRouteModule;
exports.SeRouteService = SeRouteService;
exports.SeValidationMessageParser = SeValidationMessageParser;
exports.SelectComponent = SelectComponent;
exports.SelectModule = SelectModule;
exports.SettingsService = SettingsService;
exports.SharedComponentsModule = SharedComponentsModule;
exports.ShortStringComponent = ShortStringComponent;
exports.SliderPanelComponent = SliderPanelComponent;
exports.SliderPanelModule = SliderPanelModule;
exports.SliderPanelServiceFactory = SliderPanelServiceFactory;
exports.SmarteditBootstrapGateway = SmarteditBootstrapGateway;
exports.SmarteditCommonsModule = SmarteditCommonsModule;
exports.SmarteditConstantsModule = SmarteditConstantsModule;
exports.SmarteditErrorHandler = SmarteditErrorHandler;
exports.SmarteditRoutingService = SmarteditRoutingService;
exports.SpinnerComponent = SpinnerComponent;
exports.SpinnerModule = SpinnerModule;
exports.StartFromPipe = StartFromPipe;
exports.StartFromPipeModule = StartFromPipeModule;
exports.StorageManagerFactory = StorageManagerFactory;
exports.StorageNamespaceConverter = StorageNamespaceConverter;
exports.StringUtils = StringUtils;
exports.SystemEventService = SystemEventService;
exports.TAB_DATA = TAB_DATA;
exports.THROTTLE_SCROLLING_DELAY = THROTTLE_SCROLLING_DELAY;
exports.TOOLBAR_ITEM = TOOLBAR_ITEM;
exports.TREE_NODE = TREE_NODE;
exports.TYPES_RESOURCE_URI = TYPES_RESOURCE_URI;
exports.TYPE_ATTRIBUTE = TYPE_ATTRIBUTE;
exports.TabComponent = TabComponent;
exports.TabsComponent = TabsComponent;
exports.TabsModule = TabsModule;
exports.TemplateCacheDecoratorModule = TemplateCacheDecoratorModule;
exports.TestModeService = TestModeService;
exports.TextTruncateService = TextTruncateService;
exports.Timer = Timer;
exports.TimerService = TimerService;
exports.TooltipModule = TooltipModule;
exports.TranslationServiceModule = TranslationServiceModule;
exports.TreeComponent = TreeComponent;
exports.TreeDndOptionFactory = TreeDndOptionFactory;
exports.TreeDragAndDropEvent = TreeDragAndDropEvent;
exports.TreeModule = TreeModule;
exports.TreeNestedDataSource = TreeNestedDataSource;
exports.TreeNodeItem = TreeNodeItem;
exports.TreeNodeRendererComponent = TreeNodeRendererComponent;
exports.TreeService = TreeService;
exports.TreeServiceFactory = TreeServiceFactory;
exports.TruncatedText = TruncatedText;
exports.UUID_ATTRIBUTE = UUID_ATTRIBUTE;
exports.UriDropdownPopulator = UriDropdownPopulator;
exports.VALIDATION_MESSAGE_TYPES = VALIDATION_MESSAGE_TYPES;
exports.WHO_AM_I_RESOURCE_URI = WHO_AM_I_RESOURCE_URI;
exports.WIZARD_API = WIZARD_API;
exports.WIZARD_MANAGER = WIZARD_MANAGER;
exports.WaitDialogComponent = WaitDialogComponent;
exports.WindowUtils = WindowUtils;
exports.WizardModule = WizardModule;
exports.WizardService = WizardService;
exports.YCollapsibleContainerComponent = YCollapsibleContainerComponent;
exports.YDropDownMenuComponent = YDropDownMenuComponent;
exports.YEditableListModule = YEditableListModule;
exports.YEventMessageComponent = YEventMessageComponent;
exports.YHelpComponent = YHelpComponent;
exports.YHelpModule = YHelpModule;
exports.YInfiniteScrollingComponent = YInfiniteScrollingComponent;
exports.YJQUERY_TOKEN = YJQUERY_TOKEN;
exports.YMessageComponent = YMessageComponent;
exports.YMoreTextComponent = YMoreTextComponent;
exports.YSelectComponent = YSelectComponent;
exports.YSelectModule = YSelectModule;
exports.YSliderPanelComponent = YSliderPanelComponent;
exports.YTreeDndEvent = YTreeDndEvent;
exports.YjqueryModule = YjqueryModule;
exports.apiUtils = apiUtils;
exports.authorizationEvictionTag = authorizationEvictionTag;
exports.catalogEvictionTag = catalogEvictionTag;
exports.catalogSyncedEvictionTag = catalogSyncedEvictionTag;
exports.contentCatalogUpdateEvictionTag = contentCatalogUpdateEvictionTag;
exports.dateUtils = dateUtils;
exports.defaultButtonOptions = defaultButtonOptions;
exports.diBridgeUtils = diBridgeUtils;
exports.diNameUtils = diNameUtils;
exports.frequentlyChangingContent = frequentlyChangingContent;
exports.genericEditorDropdownComponentOnInit = genericEditorDropdownComponentOnInit;
exports.getLocalizedFilterFn = getLocalizedFilterFn;
exports.instrument = instrument;
exports.modalControllerClassFactory = modalControllerClassFactory;
exports.moduleUtils = moduleUtils;
exports.nodeUtils = nodeUtils;
exports.objectToArray = objectToArray;
exports.objectUtils = objectUtils;
exports.operationContextCMSPredicate = operationContextCMSPredicate;
exports.operationContextInteractivePredicate = operationContextInteractivePredicate;
exports.operationContextNonInteractivePredicate = operationContextNonInteractivePredicate;
exports.operationContextToolingPredicate = operationContextToolingPredicate;
exports.pageChangeEvictionTag = pageChangeEvictionTag;
exports.pageCreationEvictionTag = pageCreationEvictionTag;
exports.pageDeletionEvictionTag = pageDeletionEvictionTag;
exports.pageEvictionTag = pageEvictionTag;
exports.pageRestoredEvictionTag = pageRestoredEvictionTag;
exports.pageUpdateEvictionTag = pageUpdateEvictionTag;
exports.parseComponentSelector = parseComponentSelector;
exports.parseDirectiveBindings = parseDirectiveBindings;
exports.parseDirectiveName = parseDirectiveName;
exports.parseValidationMessage = parseValidationMessage;
exports.perspectiveChangedEvictionTag = perspectiveChangedEvictionTag;
exports.rarelyChangingContent = rarelyChangingContent;
exports.registerCustomComponents = registerCustomComponents;
exports.scriptUtils = scriptUtils;
exports.seCustomComponents = seCustomComponents;
exports.servicesToBeDowngraded = servicesToBeDowngraded;
exports.setupL10nFilter = setupL10nFilter;
exports.stringUtils = stringUtils;
exports.userEvictionTag = userEvictionTag;
exports.windowUtils = windowUtils;
exports.yjQueryServiceFactory = yjQueryServiceFactory;
